# 1 ".qccgh0h9m/tube_bp_rel.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 342 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 ".qccgh0h9m/tube_bp_rel.c" 2
# 1 "tube_bp_rel-cpp.c"
# 1 "<built-in>"
# 1 "<built-in>"
# 342 "<built-in>"
# 1 "<command line>"
# 1 "<built-in>"
# 1 "tube_bp_rel-cpp.c"
# 1 "/Users/weugene/basilisk/src/common.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 1 3 4
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/Availability.h" 1 3 4
# 232 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/Availability.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityInternal.h" 1 3 4
# 233 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/Availability.h" 2 3 4
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 1 3 4
# 608 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_symbol_aliasing.h" 1 3 4
# 609 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 2 3 4
# 674 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_posix_availability.h" 1 3 4
# 675 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 2 3 4
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types.h" 1 3 4
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_types.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/_types.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/_types.h" 3 4
typedef signed char __int8_t;



typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/_types.h" 3 4
typedef int __darwin_ct_rune_t;





typedef union {
 char __mbstate8[128];
 long long _mbstateL;
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t;


typedef long int __darwin_ptrdiff_t;







typedef long unsigned int __darwin_size_t;





typedef __builtin_va_list __darwin_va_list;





typedef int __darwin_wchar_t;




typedef __darwin_wchar_t __darwin_rune_t;


typedef int __darwin_wint_t;




typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_types.h" 2 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 2 3 4
# 55 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 3 4
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;

typedef __darwin_ino64_t __darwin_ino_t;



typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_types.h" 1 3 4
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_types.h" 3 4
struct __darwin_pthread_handler_rec {
 void (*__routine)(void *);
 void *__arg;
 struct __darwin_pthread_handler_rec *__next;
};

struct _opaque_pthread_attr_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_cond_t {
 long __sig;
 char __opaque[40];
};

struct _opaque_pthread_condattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_mutex_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_mutexattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_once_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_rwlock_t {
 long __sig;
 char __opaque[192];
};

struct _opaque_pthread_rwlockattr_t {
 long __sig;
 char __opaque[16];
};

struct _opaque_pthread_t {
 long __sig;
 struct __darwin_pthread_handler_rec *__cleanup_stack;
 char __opaque[8176];
};

typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t *__darwin_pthread_t;
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 2 3 4
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types.h" 2 3 4
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types.h" 3 4
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;

typedef __uint32_t __darwin_wctype_t;
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 1 3 4
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 3 4
typedef enum {
 P_ALL,
 P_PID,
 P_PGID
} idtype_t;






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_pid_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_pid_t.h" 3 4
typedef __darwin_pid_t pid_t;
# 90 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_id_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_id_t.h" 3 4
typedef __darwin_id_t id_t;
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 2 3 4
# 109 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 1 3 4
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/appleapiopts.h" 1 3 4
# 74 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4








# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/signal.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/signal.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/signal.h" 1 3 4
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/signal.h" 3 4
typedef int sig_atomic_t;
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/signal.h" 2 3 4
# 83 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4
# 146 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_mcontext.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_mcontext.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/_mcontext.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/_mcontext.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/machine/_structs.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/machine/_structs.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 1 3 4
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/types.h" 1 3 4
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/types.h" 1 3 4
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int8_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int8_t.h" 3 4
typedef signed char int8_t;
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int16_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int16_t.h" 3 4
typedef short int16_t;
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int32_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int32_t.h" 3 4
typedef int int32_t;
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int64_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int64_t.h" 3 4
typedef long long int64_t;
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/types.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int8_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int8_t.h" 3 4
typedef unsigned char u_int8_t;
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int16_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int16_t.h" 3 4
typedef unsigned short u_int16_t;
# 83 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int32_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int32_t.h" 3 4
typedef unsigned int u_int32_t;
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int64_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int64_t.h" 3 4
typedef unsigned long long u_int64_t;
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/types.h" 2 3 4


typedef int64_t register_t;





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_intptr_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_intptr_t.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/types.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_intptr_t.h" 2 3 4

typedef __darwin_intptr_t intptr_t;
# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_uintptr_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_uintptr_t.h" 3 4
typedef unsigned long uintptr_t;
# 94 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/types.h" 2 3 4
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/types.h" 3 4
typedef u_int64_t syscall_arg_t;
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/types.h" 2 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 2 3 4
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_thread_state
{
    unsigned int __eax;
    unsigned int __ebx;
    unsigned int __ecx;
    unsigned int __edx;
    unsigned int __edi;
    unsigned int __esi;
    unsigned int __ebp;
    unsigned int __esp;
    unsigned int __ss;
    unsigned int __eflags;
    unsigned int __eip;
    unsigned int __cs;
    unsigned int __ds;
    unsigned int __es;
    unsigned int __fs;
    unsigned int __gs;
};
# 92 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_control
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
      :2,
    __pc :2,





    __rc :2,






             :1,
      :3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
# 150 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_status
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
    __stkflt :1,
    __errsumm :1,
    __c0 :1,
    __c1 :1,
    __c2 :1,
    __tos :3,
    __c3 :1,
    __busy :1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
# 194 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_mmst_reg
{
 char __mmst_reg[10];
 char __mmst_rsrv[6];
};
# 213 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_xmm_reg
{
 char __xmm_reg[16];
};
# 229 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_ymm_reg
{
 char __ymm_reg[32];
};
# 245 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_zmm_reg
{
 char __zmm_reg[64];
};
# 259 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_opmask_reg
{
 char __opmask_reg[8];
};
# 281 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_float_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
};


struct __darwin_i386_avx_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
};


struct __darwin_i386_avx512_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_opmask_reg __fpu_k0;
 struct __darwin_opmask_reg __fpu_k1;
 struct __darwin_opmask_reg __fpu_k2;
 struct __darwin_opmask_reg __fpu_k3;
 struct __darwin_opmask_reg __fpu_k4;
 struct __darwin_opmask_reg __fpu_k5;
 struct __darwin_opmask_reg __fpu_k6;
 struct __darwin_opmask_reg __fpu_k7;
 struct __darwin_ymm_reg __fpu_zmmh0;
 struct __darwin_ymm_reg __fpu_zmmh1;
 struct __darwin_ymm_reg __fpu_zmmh2;
 struct __darwin_ymm_reg __fpu_zmmh3;
 struct __darwin_ymm_reg __fpu_zmmh4;
 struct __darwin_ymm_reg __fpu_zmmh5;
 struct __darwin_ymm_reg __fpu_zmmh6;
 struct __darwin_ymm_reg __fpu_zmmh7;
};
# 575 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_exception_state
{
 __uint16_t __trapno;
 __uint16_t __cpu;
 __uint32_t __err;
 __uint32_t __faultvaddr;
};
# 595 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state32
{
 unsigned int __dr0;
 unsigned int __dr1;
 unsigned int __dr2;
 unsigned int __dr3;
 unsigned int __dr4;
 unsigned int __dr5;
 unsigned int __dr6;
 unsigned int __dr7;
};
# 627 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_thread_state64
{
 __uint64_t __rax;
 __uint64_t __rbx;
 __uint64_t __rcx;
 __uint64_t __rdx;
 __uint64_t __rdi;
 __uint64_t __rsi;
 __uint64_t __rbp;
 __uint64_t __rsp;
 __uint64_t __r8;
 __uint64_t __r9;
 __uint64_t __r10;
 __uint64_t __r11;
 __uint64_t __r12;
 __uint64_t __r13;
 __uint64_t __r14;
 __uint64_t __r15;
 __uint64_t __rip;
 __uint64_t __rflags;
 __uint64_t __cs;
 __uint64_t __fs;
 __uint64_t __gs;
};
# 682 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_float_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
};


struct __darwin_x86_avx_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_xmm_reg __fpu_ymmh8;
 struct __darwin_xmm_reg __fpu_ymmh9;
 struct __darwin_xmm_reg __fpu_ymmh10;
 struct __darwin_xmm_reg __fpu_ymmh11;
 struct __darwin_xmm_reg __fpu_ymmh12;
 struct __darwin_xmm_reg __fpu_ymmh13;
 struct __darwin_xmm_reg __fpu_ymmh14;
 struct __darwin_xmm_reg __fpu_ymmh15;
};


struct __darwin_x86_avx512_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_xmm_reg __fpu_ymmh8;
 struct __darwin_xmm_reg __fpu_ymmh9;
 struct __darwin_xmm_reg __fpu_ymmh10;
 struct __darwin_xmm_reg __fpu_ymmh11;
 struct __darwin_xmm_reg __fpu_ymmh12;
 struct __darwin_xmm_reg __fpu_ymmh13;
 struct __darwin_xmm_reg __fpu_ymmh14;
 struct __darwin_xmm_reg __fpu_ymmh15;
 struct __darwin_opmask_reg __fpu_k0;
 struct __darwin_opmask_reg __fpu_k1;
 struct __darwin_opmask_reg __fpu_k2;
 struct __darwin_opmask_reg __fpu_k3;
 struct __darwin_opmask_reg __fpu_k4;
 struct __darwin_opmask_reg __fpu_k5;
 struct __darwin_opmask_reg __fpu_k6;
 struct __darwin_opmask_reg __fpu_k7;
 struct __darwin_ymm_reg __fpu_zmmh0;
 struct __darwin_ymm_reg __fpu_zmmh1;
 struct __darwin_ymm_reg __fpu_zmmh2;
 struct __darwin_ymm_reg __fpu_zmmh3;
 struct __darwin_ymm_reg __fpu_zmmh4;
 struct __darwin_ymm_reg __fpu_zmmh5;
 struct __darwin_ymm_reg __fpu_zmmh6;
 struct __darwin_ymm_reg __fpu_zmmh7;
 struct __darwin_ymm_reg __fpu_zmmh8;
 struct __darwin_ymm_reg __fpu_zmmh9;
 struct __darwin_ymm_reg __fpu_zmmh10;
 struct __darwin_ymm_reg __fpu_zmmh11;
 struct __darwin_ymm_reg __fpu_zmmh12;
 struct __darwin_ymm_reg __fpu_zmmh13;
 struct __darwin_ymm_reg __fpu_zmmh14;
 struct __darwin_ymm_reg __fpu_zmmh15;
 struct __darwin_zmm_reg __fpu_zmm16;
 struct __darwin_zmm_reg __fpu_zmm17;
 struct __darwin_zmm_reg __fpu_zmm18;
 struct __darwin_zmm_reg __fpu_zmm19;
 struct __darwin_zmm_reg __fpu_zmm20;
 struct __darwin_zmm_reg __fpu_zmm21;
 struct __darwin_zmm_reg __fpu_zmm22;
 struct __darwin_zmm_reg __fpu_zmm23;
 struct __darwin_zmm_reg __fpu_zmm24;
 struct __darwin_zmm_reg __fpu_zmm25;
 struct __darwin_zmm_reg __fpu_zmm26;
 struct __darwin_zmm_reg __fpu_zmm27;
 struct __darwin_zmm_reg __fpu_zmm28;
 struct __darwin_zmm_reg __fpu_zmm29;
 struct __darwin_zmm_reg __fpu_zmm30;
 struct __darwin_zmm_reg __fpu_zmm31;
};
# 1140 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_exception_state64
{
    __uint16_t __trapno;
    __uint16_t __cpu;
    __uint32_t __err;
    __uint64_t __faultvaddr;
};
# 1160 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state64
{
 __uint64_t __dr0;
 __uint64_t __dr1;
 __uint64_t __dr2;
 __uint64_t __dr3;
 __uint64_t __dr4;
 __uint64_t __dr5;
 __uint64_t __dr6;
 __uint64_t __dr7;
};
# 1188 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_cpmu_state64
{
 __uint64_t __ctrs[16];
};
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/machine/_structs.h" 2 3 4
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/_mcontext.h" 2 3 4




struct __darwin_mcontext32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_float_state __fs;
};


struct __darwin_mcontext_avx32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_avx_state __fs;
};



struct __darwin_mcontext_avx512_32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_avx512_state __fs;
};
# 97 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/_mcontext.h" 3 4
struct __darwin_mcontext64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_float_state64 __fs;
};


struct __darwin_mcontext_avx64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_avx_state64 __fs;
};



struct __darwin_mcontext_avx512_64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_avx512_state64 __fs;
};
# 156 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/_mcontext.h" 3 4
typedef struct __darwin_mcontext64 *mcontext_t;
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_mcontext.h" 2 3 4
# 147 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_attr_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_attr_t.h" 3 4
typedef __darwin_pthread_attr_t pthread_attr_t;
# 149 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_sigaltstack.h" 1 3 4
# 42 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_sigaltstack.h" 3 4
struct __darwin_sigaltstack
{
 void *ss_sp;
 __darwin_size_t ss_size;
 int ss_flags;
};
typedef struct __darwin_sigaltstack stack_t;
# 151 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ucontext.h" 1 3 4
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ucontext.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_mcontext.h" 1 3 4
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ucontext.h" 2 3 4


struct __darwin_ucontext
{
 int uc_onstack;
 __darwin_sigset_t uc_sigmask;
 struct __darwin_sigaltstack uc_stack;
 struct __darwin_ucontext *uc_link;
 __darwin_size_t uc_mcsize;
 struct __darwin_mcontext64 *uc_mcontext;

 struct __darwin_mcontext64 __mcontext_data;

};


typedef struct __darwin_ucontext ucontext_t;
# 152 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_sigset_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_sigset_t.h" 3 4
typedef __darwin_sigset_t sigset_t;
# 155 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 3 4
typedef __darwin_size_t size_t;
# 156 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_uid_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_uid_t.h" 3 4
typedef __darwin_uid_t uid_t;
# 157 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4

union sigval {

 int sival_int;
 void *sival_ptr;
};





struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 void (*sigev_notify_function)(union sigval);
 pthread_attr_t *sigev_notify_attributes;
};


typedef struct __siginfo {
 int si_signo;
 int si_errno;
 int si_code;
 pid_t si_pid;
 uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 long si_band;
 unsigned long __pad[7];
} siginfo_t;
# 269 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
union __sigaction_u {
 void (*__sa_handler)(int);
 void (*__sa_sigaction)(int, struct __siginfo *,
         void *);
};


struct __sigaction {
 union __sigaction_u __sigaction_u;
 void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
 sigset_t sa_mask;
 int sa_flags;
};




struct sigaction {
 union __sigaction_u __sigaction_u;
 sigset_t sa_mask;
 int sa_flags;
};
# 367 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
struct sigstack {
 char *ss_sp;
 int ss_onstack;
};
# 390 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
void (*signal(int, void (*)(int)))(int);
# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 1 3 4
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_timeval.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_timeval.h" 3 4
struct timeval
{
 __darwin_time_t tv_sec;
 __darwin_suseconds_t tv_usec;
};
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 2 3 4








typedef __uint64_t rlim_t;
# 152 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;

 long ru_opaque[14];
# 180 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
};
# 366 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
struct rlimit {
 rlim_t rlim_cur;
 rlim_t rlim_max;
};
# 437 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
int getpriority(int, id_t);



int getrlimit(int, struct rlimit *) __asm("_" "getrlimit" );
int getrusage(int, struct rusage *);
int setpriority(int, id_t, int);



int setrlimit(int, const struct rlimit *) __asm("_" "setrlimit" );
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 2 3 4
# 248 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 3 4
pid_t wait(int *) __asm("_" "wait" );
pid_t waitpid(pid_t, int *, int) __asm("_" "waitpid" );

int waitid(idtype_t, id_t, siginfo_t *, int) __asm("_" "waitid" );
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_wchar_t.h" 3 4
typedef __darwin_wchar_t wchar_t;
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4

typedef struct {
 int quot;
 int rem;
} div_t;

typedef struct {
 long quot;
 long rem;
} ldiv_t;


typedef struct {
 long long quot;
 long long rem;
} lldiv_t;



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_null.h" 1 3 4
# 101 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4
# 118 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 3 4
extern int __mb_cur_max;
# 128 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/malloc/_malloc.h" 1 3 4
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/malloc/_malloc.h" 3 4
void *malloc(size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1)));
void *calloc(size_t __count, size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1,2)));
void free(void *);
void *realloc(void *__ptr, size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2)));



int posix_memalign(void **__memptr, size_t __alignment, size_t __size) __attribute__((availability(macosx,introduced=10.6)));
# 129 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4


void abort(void) __attribute__((noreturn));
int abs(int) __attribute__((const));
int atexit(void (* _Nonnull)(void));
double atof(const char *);
int atoi(const char *);
long atol(const char *);

long long
  atoll(const char *);

void *bsearch(const void *__key, const void *__base, size_t __nel,
     size_t __width, int (* _Nonnull __compar)(const void *, const void *));

div_t div(int, int) __attribute__((const));
void exit(int) __attribute__((noreturn));

char *getenv(const char *);
long labs(long) __attribute__((const));
ldiv_t ldiv(long, long) __attribute__((const));

long long
  llabs(long long);
lldiv_t lldiv(long long, long long);


int mblen(const char *__s, size_t __n);
size_t mbstowcs(wchar_t * restrict , const char * restrict, size_t);
int mbtowc(wchar_t * restrict, const char * restrict, size_t);

void qsort(void *__base, size_t __nel, size_t __width,
     int (* _Nonnull __compar)(const void *, const void *));
int rand(void) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));

void srand(unsigned) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
double strtod(const char *, char **) __asm("_" "strtod" );
float strtof(const char *, char **) __asm("_" "strtof" );
long strtol(const char *__str, char **__endptr, int __base);
long double
  strtold(const char *, char **);

long long
  strtoll(const char *__str, char **__endptr, int __base);

unsigned long
  strtoul(const char *__str, char **__endptr, int __base);

unsigned long long
  strtoull(const char *__str, char **__endptr, int __base);
# 187 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 3 4
__attribute__((__availability__(swift, unavailable, message="Use posix_spawn APIs or NSTask instead.")))
__attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,unavailable)))
__attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)))
int system(const char *) __asm("_" "system" );



size_t wcstombs(char * restrict, const wchar_t * restrict, size_t);
int wctomb(char *, wchar_t);


void _Exit(int) __attribute__((noreturn));
long a64l(const char *);
double drand48(void);
char *ecvt(double, int, int *restrict, int *restrict);
double erand48(unsigned short[3]);
char *fcvt(double, int, int *restrict, int *restrict);
char *gcvt(double, int, char *);
int getsubopt(char **, char * const *, char **);
int grantpt(int);

char *initstate(unsigned, char *, size_t);



long jrand48(unsigned short[3]) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
char *l64a(long);
void lcong48(unsigned short[7]);
long lrand48(void) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
char *mktemp(char *);
int mkstemp(char *);
long mrand48(void) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
long nrand48(unsigned short[3]) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
int posix_openpt(int);
char *ptsname(int);





int putenv(char *) __asm("_" "putenv" );
long random(void) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
int rand_r(unsigned *) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));



char *realpath(const char * restrict, char * restrict) __asm("_" "realpath" );

unsigned short
 *seed48(unsigned short[3]);
int setenv(const char * __name, const char * __value, int __overwrite) __asm("_" "setenv" );

void setkey(const char *) __asm("_" "setkey" );



char *setstate(const char *);
void srand48(long);

void srandom(unsigned);



int unlockpt(int);

int unsetenv(const char *) __asm("_" "unsetenv" );
# 2 "/Users/weugene/basilisk/src/common.h" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 1 3 4
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 1 3 4
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_va_list.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_va_list.h" 3 4
typedef __darwin_va_list va_list;
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/stdio.h" 1 3 4
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/stdio.h" 3 4
int renameat(int, const char *, int, const char *) __attribute__((availability(macosx,introduced=10.10)));
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 2 3 4

typedef __darwin_off_t fpos_t;
# 92 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 3 4
struct __sbuf {
 unsigned char *_base;
 int _size;
};


struct __sFILEX;
# 126 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 3 4
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (* _Nullable _close)(void *);
 int (* _Nullable _read) (void *, char *, int);
 fpos_t (* _Nullable _seek) (void *, fpos_t, int);
 int (* _Nullable _write)(void *, const char *, int);


 struct __sbuf _ub;
 struct __sFILEX *_extra;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;
} FILE;
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 2 3 4


extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;
# 142 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE * restrict, fpos_t *);
char *fgets(char * restrict, int, FILE *);



FILE *fopen(const char * restrict __filename, const char * restrict __mode) __asm("_" "fopen" );

int fprintf(FILE * restrict, const char * restrict, ...) __attribute__((__format__ (__printf__, 2, 3)));
int fputc(int, FILE *);
int fputs(const char * restrict, FILE * restrict) __asm("_" "fputs" );
size_t fread(void * restrict __ptr, size_t __size, size_t __nitems, FILE * restrict __stream);
FILE *freopen(const char * restrict, const char * restrict,
                 FILE * restrict) __asm("_" "freopen" );
int fscanf(FILE * restrict, const char * restrict, ...) __attribute__((__format__ (__scanf__, 2, 3)));
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void * restrict __ptr, size_t __size, size_t __nitems, FILE * restrict __stream) __asm("_" "fwrite" );
int getc(FILE *);
int getchar(void);
char *gets(char *);
void perror(const char *);
int printf(const char * restrict, ...) __attribute__((__format__ (__printf__, 1, 2)));
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename (const char *__old, const char *__new);
void rewind(FILE *);
int scanf(const char * restrict, ...) __attribute__((__format__ (__scanf__, 1, 2)));
void setbuf(FILE * restrict, char * restrict);
int setvbuf(FILE * restrict, char * restrict, int, size_t);
int sprintf(char * restrict, const char * restrict, ...) __attribute__((__format__ (__printf__, 2, 3))) __attribute__((__availability__(swift, unavailable, message="Use snprintf instead.")));
int sscanf(const char * restrict, const char * restrict, ...) __attribute__((__format__ (__scanf__, 2, 3)));
FILE *tmpfile(void);

__attribute__((__availability__(swift, unavailable, message="Use mkstemp(3) instead.")))



char *tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE * restrict, const char * restrict, va_list) __attribute__((__format__ (__printf__, 2, 0)));
int vprintf(const char * restrict, va_list) __attribute__((__format__ (__printf__, 1, 0)));
int vsprintf(char * restrict, const char * restrict, va_list) __attribute__((__format__ (__printf__, 2, 0))) __attribute__((__availability__(swift, unavailable, message="Use vsnprintf instead.")));
# 208 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
char *ctermid(char *);





FILE *fdopen(int, const char *) __asm("_" "fdopen" );

int fileno(FILE *);
# 232 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
int pclose(FILE *) __attribute__((__availability__(swift, unavailable, message="Use posix_spawn APIs or NSTask instead.")));



FILE *popen(const char *, const char *) __asm("_" "popen" ) __attribute__((__availability__(swift, unavailable, message="Use posix_spawn APIs or NSTask instead.")));
# 253 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
int __srget(FILE *);
int __svfscanf(FILE *, const char *, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int __swbuf(int, FILE *);
# 264 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
inline __attribute__ ((__always_inline__)) int __sputc(int _c, FILE *_p) {
 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf(_c, _p));
}
# 290 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);







__attribute__((__availability__(swift, unavailable, message="Use mkstemp(3) instead.")))



char *tempnam(const char *__dir, const char *__prefix) __asm("_" "tempnam" );
# 328 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_off_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_off_t.h" 3 4
typedef __darwin_off_t off_t;
# 329 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 2 3 4


int fseeko(FILE * __stream, off_t __offset, int __whence);
off_t ftello(FILE * __stream);





int snprintf(char * restrict __str, size_t __size, const char * restrict __format, ...) __attribute__((__format__ (__printf__, 3, 4)));
int vfscanf(FILE * restrict __stream, const char * restrict __format, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int vscanf(const char * restrict __format, va_list) __attribute__((__format__ (__scanf__, 1, 0)));
int vsnprintf(char * restrict __str, size_t __size, const char * restrict __format, va_list) __attribute__((__format__ (__printf__, 3, 0)));
int vsscanf(const char * restrict __str, const char * restrict __format, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
# 353 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ssize_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ssize_t.h" 3 4
typedef __darwin_ssize_t ssize_t;
# 354 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 2 3 4


int dprintf(int, const char * restrict, ...) __attribute__((__format__ (__printf__, 2, 3))) __attribute__((availability(macosx,introduced=10.7)));
int vdprintf(int, const char * restrict, va_list) __attribute__((__format__ (__printf__, 2, 0))) __attribute__((availability(macosx,introduced=10.7)));
ssize_t getdelim(char ** restrict __linep, size_t * restrict __linecapp, int __delimiter, FILE * restrict __stream) __attribute__((availability(macosx,introduced=10.7)));
ssize_t getline(char ** restrict __linep, size_t * restrict __linecapp, FILE * restrict __stream) __attribute__((availability(macosx,introduced=10.7)));
FILE *fmemopen(void * restrict __buf, size_t __size, const char * restrict __mode) __attribute__((availability(macos,introduced=10.13))) __attribute__((availability(ios,introduced=11.0))) __attribute__((availability(tvos,introduced=11.0))) __attribute__((availability(watchos,introduced=4.0)));
FILE *open_memstream(char **__bufp, size_t *__sizep) __attribute__((availability(macos,introduced=10.13))) __attribute__((availability(ios,introduced=11.0))) __attribute__((availability(tvos,introduced=11.0))) __attribute__((availability(watchos,introduced=4.0)));
# 411 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/secure/_stdio.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/secure/_stdio.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/secure/_common.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/secure/_stdio.h" 2 3 4
# 42 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/secure/_stdio.h" 3 4
extern int __sprintf_chk (char * restrict, int, size_t,
     const char * restrict, ...);
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/secure/_stdio.h" 3 4
extern int __snprintf_chk (char * restrict, size_t, int, size_t,
      const char * restrict, ...);







extern int __vsprintf_chk (char * restrict, int, size_t,
      const char * restrict, va_list);







extern int __vsnprintf_chk (char * restrict, size_t, int, size_t,
       const char * restrict, va_list);
# 412 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 2 3 4
# 3 "/Users/weugene/basilisk/src/common.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/stddef.h" 1 3 4
# 51 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 4 "/Users/weugene/basilisk/src/common.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/stdbool.h" 1 3 4
# 5 "/Users/weugene/basilisk/src/common.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/stdarg.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 48 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 6 "/Users/weugene/basilisk/src/common.h" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/string.h" 1 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/string.h" 3 4
void *memchr(const void *__s, int __c, size_t __n);
int memcmp(const void *__s1, const void *__s2, size_t __n);
void *memcpy(void *__dst, const void *__src, size_t __n);
void *memmove(void *__dst, const void *__src, size_t __len);
void *memset(void *__b, int __c, size_t __len);
char *strcat(char *__s1, const char *__s2);
char *strchr(const char *__s, int __c);
int strcmp(const char *__s1, const char *__s2);
int strcoll(const char *__s1, const char *__s2);
char *strcpy(char *__dst, const char *__src);
size_t strcspn(const char *__s, const char *__charset);
char *strerror(int __errnum) __asm("_" "strerror" );
size_t strlen(const char *__s);
char *strncat(char *__s1, const char *__s2, size_t __n);
int strncmp(const char *__s1, const char *__s2, size_t __n);
char *strncpy(char *__dst, const char *__src, size_t __n);
char *strpbrk(const char *__s, const char *__charset);
char *strrchr(const char *__s, int __c);
size_t strspn(const char *__s, const char *__charset);
char *strstr(const char *__big, const char *__little);
char *strtok(char *__str, const char *__sep);
size_t strxfrm(char *__s1, const char *__s2, size_t __n);
# 104 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/string.h" 3 4
char *strtok_r(char *__str, const char *__sep, char **__lasts);
# 116 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/string.h" 3 4
int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen);
char *strdup(const char *__s1);
void *memccpy(void *__dst, const void *__src, int __c, size_t __n);
# 130 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/string.h" 3 4
char *stpcpy(char *__dst, const char *__src);
char *stpncpy(char *__dst, const char *__src, size_t __n) __attribute__((availability(macosx,introduced=10.7)));
char *strndup(const char *__s1, size_t __n) __attribute__((availability(macosx,introduced=10.7)));
size_t strnlen(const char *__s1, size_t __n) __attribute__((availability(macosx,introduced=10.7)));
char *strsignal(int __sig);
# 190 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/string.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/secure/_string.h" 1 3 4
# 191 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/string.h" 2 3 4
# 7 "/Users/weugene/basilisk/src/common.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/float.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/float.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/float.h" 1 3 4
# 46 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/float.h" 2 3 4
# 8 "/Users/weugene/basilisk/src/common.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/limits.h" 1 3 4
# 37 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/limits.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/limits.h" 1 3 4
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/limits.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/limits.h" 1 3 4





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/limits.h" 1 3 4
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/limits.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/_limits.h" 1 3 4
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/limits.h" 2 3 4
# 7 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/limits.h" 2 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/limits.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/syslimits.h" 1 3 4
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/limits.h" 2 3 4
# 38 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/limits.h" 2 3 4
# 9 "/Users/weugene/basilisk/src/common.h" 2

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((noreturn)) __attribute__((__disable_tail_calls__));
# 11 "/Users/weugene/basilisk/src/common.h" 2

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
    typedef float float_t;
    typedef double double_t;
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern int __math_errhandling(void);
# 131 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern int __fpclassifyf(float);
extern int __fpclassifyd(double);
extern int __fpclassifyl(long double);
# 174 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
inline __attribute__ ((__always_inline__)) int __inline_isfinitef(float);
inline __attribute__ ((__always_inline__)) int __inline_isfinited(double);
inline __attribute__ ((__always_inline__)) int __inline_isfinitel(long double);
inline __attribute__ ((__always_inline__)) int __inline_isinff(float);
inline __attribute__ ((__always_inline__)) int __inline_isinfd(double);
inline __attribute__ ((__always_inline__)) int __inline_isinfl(long double);
inline __attribute__ ((__always_inline__)) int __inline_isnanf(float);
inline __attribute__ ((__always_inline__)) int __inline_isnand(double);
inline __attribute__ ((__always_inline__)) int __inline_isnanl(long double);
inline __attribute__ ((__always_inline__)) int __inline_isnormalf(float);
inline __attribute__ ((__always_inline__)) int __inline_isnormald(double);
inline __attribute__ ((__always_inline__)) int __inline_isnormall(long double);
inline __attribute__ ((__always_inline__)) int __inline_signbitf(float);
inline __attribute__ ((__always_inline__)) int __inline_signbitd(double);
inline __attribute__ ((__always_inline__)) int __inline_signbitl(long double);

inline __attribute__ ((__always_inline__)) int __inline_isfinitef(float __x) {
    return __x == __x && __builtin_fabsf(__x) != __builtin_inff();
}
inline __attribute__ ((__always_inline__)) int __inline_isfinited(double __x) {
    return __x == __x && __builtin_fabs(__x) != __builtin_inf();
}
inline __attribute__ ((__always_inline__)) int __inline_isfinitel(long double __x) {
    return __x == __x && __builtin_fabsl(__x) != __builtin_infl();
}
inline __attribute__ ((__always_inline__)) int __inline_isinff(float __x) {
    return __builtin_fabsf(__x) == __builtin_inff();
}
inline __attribute__ ((__always_inline__)) int __inline_isinfd(double __x) {
    return __builtin_fabs(__x) == __builtin_inf();
}
inline __attribute__ ((__always_inline__)) int __inline_isinfl(long double __x) {
    return __builtin_fabsl(__x) == __builtin_infl();
}
inline __attribute__ ((__always_inline__)) int __inline_isnanf(float __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_isnand(double __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_isnanl(long double __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_signbitf(float __x) {
    union { float __f; unsigned int __u; } __u;
    __u.__f = __x;
    return (int)(__u.__u >> 31);
}
inline __attribute__ ((__always_inline__)) int __inline_signbitd(double __x) {
    union { double __f; unsigned long long __u; } __u;
    __u.__f = __x;
    return (int)(__u.__u >> 63);
}

inline __attribute__ ((__always_inline__)) int __inline_signbitl(long double __x) {
    union {
        long double __ld;
        struct{ unsigned long long __m; unsigned short __sexp; } __p;
    } __u;
    __u.__ld = __x;
    return (int)(__u.__p.__sexp >> 15);
}







inline __attribute__ ((__always_inline__)) int __inline_isnormalf(float __x) {
    return __inline_isfinitef(__x) && __builtin_fabsf(__x) >= 1.17549435e-38F;
}
inline __attribute__ ((__always_inline__)) int __inline_isnormald(double __x) {
    return __inline_isfinited(__x) && __builtin_fabs(__x) >= 2.2250738585072014e-308;
}
inline __attribute__ ((__always_inline__)) int __inline_isnormall(long double __x) {
    return __inline_isfinitel(__x) && __builtin_fabsl(__x) >= 3.36210314311209350626e-4932L;
}
# 308 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern float acosf(float);
extern double acos(double);
extern long double acosl(long double);

extern float asinf(float);
extern double asin(double);
extern long double asinl(long double);

extern float atanf(float);
extern double atan(double);
extern long double atanl(long double);

extern float atan2f(float, float);
extern double atan2(double, double);
extern long double atan2l(long double, long double);

extern float cosf(float);
extern double cos(double);
extern long double cosl(long double);

extern float sinf(float);
extern double sin(double);
extern long double sinl(long double);

extern float tanf(float);
extern double tan(double);
extern long double tanl(long double);

extern float acoshf(float);
extern double acosh(double);
extern long double acoshl(long double);

extern float asinhf(float);
extern double asinh(double);
extern long double asinhl(long double);

extern float atanhf(float);
extern double atanh(double);
extern long double atanhl(long double);

extern float coshf(float);
extern double cosh(double);
extern long double coshl(long double);

extern float sinhf(float);
extern double sinh(double);
extern long double sinhl(long double);

extern float tanhf(float);
extern double tanh(double);
extern long double tanhl(long double);

extern float expf(float);
extern double exp(double);
extern long double expl(long double);

extern float exp2f(float);
extern double exp2(double);
extern long double exp2l(long double);

extern float expm1f(float);
extern double expm1(double);
extern long double expm1l(long double);

extern float logf(float);
extern double log(double);
extern long double logl(long double);

extern float log10f(float);
extern double log10(double);
extern long double log10l(long double);

extern float log2f(float);
extern double log2(double);
extern long double log2l(long double);

extern float log1pf(float);
extern double log1p(double);
extern long double log1pl(long double);

extern float logbf(float);
extern double logb(double);
extern long double logbl(long double);

extern float modff(float, float *);
extern double modf(double, double *);
extern long double modfl(long double, long double *);

extern float ldexpf(float, int);
extern double ldexp(double, int);
extern long double ldexpl(long double, int);

extern float frexpf(float, int *);
extern double frexp(double, int *);
extern long double frexpl(long double, int *);

extern int ilogbf(float);
extern int ilogb(double);
extern int ilogbl(long double);

extern float scalbnf(float, int);
extern double scalbn(double, int);
extern long double scalbnl(long double, int);

extern float scalblnf(float, long int);
extern double scalbln(double, long int);
extern long double scalblnl(long double, long int);

extern float fabsf(float);
extern double fabs(double);
extern long double fabsl(long double);

extern float cbrtf(float);
extern double cbrt(double);
extern long double cbrtl(long double);

extern float hypotf(float, float);
extern double hypot(double, double);
extern long double hypotl(long double, long double);

extern float powf(float, float);
extern double pow(double, double);
extern long double powl(long double, long double);

extern float sqrtf(float);
extern double sqrt(double);
extern long double sqrtl(long double);

extern float erff(float);
extern double erf(double);
extern long double erfl(long double);

extern float erfcf(float);
extern double erfc(double);
extern long double erfcl(long double);




extern float lgammaf(float);
extern double lgamma(double);
extern long double lgammal(long double);

extern float tgammaf(float);
extern double tgamma(double);
extern long double tgammal(long double);

extern float ceilf(float);
extern double ceil(double);
extern long double ceill(long double);

extern float floorf(float);
extern double floor(double);
extern long double floorl(long double);

extern float nearbyintf(float);
extern double nearbyint(double);
extern long double nearbyintl(long double);

extern float rintf(float);
extern double rint(double);
extern long double rintl(long double);

extern long int lrintf(float);
extern long int lrint(double);
extern long int lrintl(long double);

extern float roundf(float);
extern double round(double);
extern long double roundl(long double);

extern long int lroundf(float);
extern long int lround(double);
extern long int lroundl(long double);




extern long long int llrintf(float);
extern long long int llrint(double);
extern long long int llrintl(long double);

extern long long int llroundf(float);
extern long long int llround(double);
extern long long int llroundl(long double);


extern float truncf(float);
extern double trunc(double);
extern long double truncl(long double);

extern float fmodf(float, float);
extern double fmod(double, double);
extern long double fmodl(long double, long double);

extern float remainderf(float, float);
extern double remainder(double, double);
extern long double remainderl(long double, long double);

extern float remquof(float, float, int *);
extern double remquo(double, double, int *);
extern long double remquol(long double, long double, int *);

extern float copysignf(float, float);
extern double copysign(double, double);
extern long double copysignl(long double, long double);

extern float nanf(const char *);
extern double nan(const char *);
extern long double nanl(const char *);

extern float nextafterf(float, float);
extern double nextafter(double, double);
extern long double nextafterl(long double, long double);

extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);

extern float fdimf(float, float);
extern double fdim(double, double);
extern long double fdiml(long double, long double);

extern float fmaxf(float, float);
extern double fmax(double, double);
extern long double fmaxl(long double, long double);

extern float fminf(float, float);
extern double fmin(double, double);
extern long double fminl(long double, long double);

extern float fmaf(float, float, float);
extern double fma(double, double, double);
extern long double fmal(long double, long double, long double);
# 551 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern float __inff(void)
__attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="use `(float)INFINITY` instead"))) __attribute__((availability(ios,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)));
extern double __inf(void)
__attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="use `INFINITY` instead"))) __attribute__((availability(ios,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)));
extern long double __infl(void)
__attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="use `(long double)INFINITY` instead"))) __attribute__((availability(ios,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)));
extern float __nan(void)
__attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="use `NAN` instead"))) __attribute__((availability(ios,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)));
# 586 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern float __exp10f(float) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern double __exp10(double) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));





inline __attribute__ ((__always_inline__)) void __sincosf(float __x, float *__sinp, float *__cosp);
inline __attribute__ ((__always_inline__)) void __sincos(double __x, double *__sinp, double *__cosp);
# 603 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern float __cospif(float) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern double __cospi(double) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern float __sinpif(float) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern double __sinpi(double) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern float __tanpif(float) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern double __tanpi(double) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
# 634 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
inline __attribute__ ((__always_inline__)) void __sincospif(float __x, float *__sinp, float *__cosp);
inline __attribute__ ((__always_inline__)) void __sincospi(double __x, double *__sinp, double *__cosp);






struct __float2 { float __sinval; float __cosval; };
struct __double2 { double __sinval; double __cosval; };

extern struct __float2 __sincosf_stret(float);
extern struct __double2 __sincos_stret(double);
extern struct __float2 __sincospif_stret(float);
extern struct __double2 __sincospi_stret(double);

inline __attribute__ ((__always_inline__)) void __sincosf(float __x, float *__sinp, float *__cosp) {
    const struct __float2 __stret = __sincosf_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

inline __attribute__ ((__always_inline__)) void __sincos(double __x, double *__sinp, double *__cosp) {
    const struct __double2 __stret = __sincos_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

inline __attribute__ ((__always_inline__)) void __sincospif(float __x, float *__sinp, float *__cosp) {
    const struct __float2 __stret = __sincospif_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

inline __attribute__ ((__always_inline__)) void __sincospi(double __x, double *__sinp, double *__cosp) {
    const struct __double2 __stret = __sincospi_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}







extern double j0(double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double j1(double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double jn(int, double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double y0(double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double y1(double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double yn(int, double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double scalb(double, double);
extern int signgam;
# 13 "/Users/weugene/basilisk/src/common.h" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 1 3 4
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_clock_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_clock_t.h" 3 4
typedef __darwin_clock_t clock_t;
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_time_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_time_t.h" 3 4
typedef __darwin_time_t time_t;
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_timespec.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_timespec.h" 3 4
struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 2 3 4

struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 char *tm_zone;
};
# 97 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 3 4
extern char *tzname[];


extern int getdate_err;

extern long timezone __asm("_" "timezone" );

extern int daylight;


char *asctime(const struct tm *);
clock_t clock(void) __asm("_" "clock" );
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_" "mktime" );
size_t strftime(char * restrict, size_t, const char * restrict, const struct tm * restrict) __asm("_" "strftime" );
char *strptime(const char * restrict, const char * restrict, struct tm * restrict) __asm("_" "strptime" );
time_t time(time_t *);


void tzset(void);



char *asctime_r(const struct tm * restrict, char * restrict);
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t * restrict, struct tm * restrict);
struct tm *localtime_r(const time_t * restrict, struct tm * restrict);
# 141 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 3 4
int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp) __asm("_" "nanosleep" );
# 152 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 3 4
typedef enum {
_CLOCK_REALTIME __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 0,

_CLOCK_MONOTONIC __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 6,
# 167 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 3 4
_CLOCK_PROCESS_CPUTIME_ID __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 12,

_CLOCK_THREAD_CPUTIME_ID __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 16

} clockid_t;

__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)))
int clock_getres(clockid_t __clock_id, struct timespec *__res);

__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)))
int clock_gettime(clockid_t __clock_id, struct timespec *__tp);






__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,unavailable)))
__attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable)))
int clock_settime(clockid_t __clock_id, const struct timespec *__tp);
# 14 "/Users/weugene/basilisk/src/common.h" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/time.h" 1 3 4
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/time.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_def.h" 1 3 4
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_def.h" 3 4
typedef struct fd_set {
 __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0) ? ((1024) / ((sizeof(__int32_t) * 8))) : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;



static __inline int
__darwin_fd_isset(int _n, const struct fd_set *_p)
{
 return (_p->fds_bits[(unsigned long)_n/(sizeof(__int32_t) * 8)] & ((__int32_t)(((unsigned long)1)<<((unsigned long)_n % (sizeof(__int32_t) * 8)))));
}
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/time.h" 2 3 4
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/time.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_suseconds_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_suseconds_t.h" 3 4
typedef __darwin_suseconds_t suseconds_t;
# 86 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/time.h" 2 3 4





struct itimerval {
 struct timeval it_interval;
 struct timeval it_value;
};
# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/time.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_setsize.h" 1 3 4
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_set.h" 1 3 4
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_clr.h" 1 3 4
# 113 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_isset.h" 1 3 4
# 114 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_zero.h" 1 3 4
# 115 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/time.h" 2 3 4
# 196 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/time.h" 3 4
int getitimer(int, struct itimerval *);
int gettimeofday(struct timeval * restrict, void * restrict);


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_select.h" 1 3 4
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_select.h" 3 4
int select(int, fd_set * restrict, fd_set * restrict,
  fd_set * restrict, struct timeval * restrict)




  __asm("_" "select" "$1050")




  ;
# 200 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/time.h" 2 3 4

int setitimer(int, const struct itimerval * restrict,
  struct itimerval * restrict);
int utimes(const char *, const struct timeval *);
# 15 "/Users/weugene/basilisk/src/common.h" 2
# 367 "/Users/weugene/basilisk/src/common.h"
typedef struct {
  void * p;
  long max, len;
} Array;

Array * array_new()
{
  Array * a = ((Array *) malloc((1)*sizeof(Array)));
  a->p = ((void*)0);
  a->max = a->len = 0;
  return a;
}

void array_free (Array * a)
{
  free(a->p);
  free(a);
}

void array_append (Array * a, void * elem, size_t size)
{
  if (a->len + size >= a->max) {
    a->max += ((size) > (4096) ? (size) : (4096));
    a->p = realloc(a->p,a->max);
  }
  __builtin___memcpy_chk (((char *)a->p) + a->len, elem, size, __builtin_object_size (((char *)a->p) + a->len, 0));
  a->len += size;
}

void * array_shrink (Array * a)
{
  void * p = realloc(a->p,a->len);
  free(a);
  return p;
}
# 796 "/Users/weugene/basilisk/src/common.h"
void init_solver()
{
# 808 "/Users/weugene/basilisk/src/common.h"
}
# 818 "/Users/weugene/basilisk/src/common.h"
double _val_higher_dimension = 0.;
# 818 "/Users/weugene/basilisk/src/common.h"

double undefined;


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/stdint.h" 1 3 4
# 63 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/stdint.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 1 3 4
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint8_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint8_t.h" 3 4
typedef unsigned char uint8_t;
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint16_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint16_t.h" 3 4
typedef unsigned short uint16_t;
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint32_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint32_t.h" 3 4
typedef unsigned int uint32_t;
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint64_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint64_t.h" 3 4
typedef unsigned long long uint64_t;
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4


typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;



typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
# 58 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_intmax_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_intmax_t.h" 3 4
typedef long int intmax_t;
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uintmax_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uintmax_t.h" 3 4
typedef long unsigned int uintmax_t;
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 64 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/9.1.0/include/stdint.h" 2 3 4
# 822 "/Users/weugene/basilisk/src/common.h" 2
# 1 "/Users/weugene/basilisk/src/fp_osx.h" 1
# 84 "/Users/weugene/basilisk/src/fp_osx.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/fenv.h" 1 3 4
# 193 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/fenv.h" 3 4
typedef struct {
    unsigned short __control;
    unsigned short __status;
    unsigned int __mxcsr;
    char __reserved[8];
} fenv_t;

typedef unsigned short fexcept_t;
# 220 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/fenv.h" 3 4
extern const fenv_t _FE_DFL_ENV;
# 244 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/fenv.h" 3 4
extern const fenv_t _FE_DFL_DISABLE_SSE_DENORMS_ENV;
# 297 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/fenv.h" 3 4
extern int feclearexcept(int );
extern int fegetexceptflag(fexcept_t * , int );
extern int feraiseexcept(int );
extern int fesetexceptflag(const fexcept_t * , int );
extern int fetestexcept(int );
# 318 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/fenv.h" 3 4
extern int fegetround(void);
extern int fesetround(int );
# 351 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/fenv.h" 3 4
extern int fegetenv(fenv_t * );
extern int feholdexcept(fenv_t * );
extern int fesetenv(const fenv_t * );
extern int feupdateenv(const fenv_t * );
# 85 "/Users/weugene/basilisk/src/fp_osx.h" 2
# 159 "/Users/weugene/basilisk/src/fp_osx.h"
int
fegetexcept (void)
{
  static fenv_t fenv;

  return fegetenv (&fenv) ? -1 : (fenv.__control & 0x003f);
}

int
feenableexcept (unsigned int excepts)
{
  static fenv_t fenv;
  unsigned int new_excepts = excepts & 0x003f,
               old_excepts;

  if ( fegetenv (&fenv) ) return -1;
  old_excepts = fenv.__control & 0x003f;


  fenv.__control &= ~new_excepts;
  fenv.__mxcsr &= ~(new_excepts << 7);

  return ( fesetenv (&fenv) ? -1 : old_excepts );
}

int
fedisableexcept (unsigned int excepts)
{
  static fenv_t fenv;
  unsigned int new_excepts = excepts & 0x003f,
               old_excepts;

  if ( fegetenv (&fenv) ) return -1;
  old_excepts = fenv.__control & 0x003f;


  fenv.__control |= new_excepts;
  fenv.__mxcsr |= new_excepts << 7;

  return ( fesetenv (&fenv) ? -1 : old_excepts );
}
# 232 "/Users/weugene/basilisk/src/fp_osx.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/signal.h" 1 3 4
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/signal.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_t.h" 3 4
typedef __darwin_pthread_t pthread_t;
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/signal.h" 2 3 4







int raise(int);




void (* _Nullable bsd_signal(int, void (* _Nullable)(int)))(int);
int kill(pid_t, int) __asm("_" "kill" );
int killpg(pid_t, int) __asm("_" "killpg" );
int pthread_kill(pthread_t, int);
int pthread_sigmask(int, const sigset_t *, sigset_t *) __asm("_" "pthread_sigmask" );
int sigaction(int, const struct sigaction * restrict,
     struct sigaction * restrict);
int sigaddset(sigset_t *, int);
int sigaltstack(const stack_t * restrict, stack_t * restrict) __asm("_" "sigaltstack" ) __attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)));
int sigdelset(sigset_t *, int);
int sigemptyset(sigset_t *);
int sigfillset(sigset_t *);
int sighold(int);
int sigignore(int);
int siginterrupt(int, int);
int sigismember(const sigset_t *, int);
int sigpause(int) __asm("_" "sigpause" );
int sigpending(sigset_t *);
int sigprocmask(int, const sigset_t * restrict, sigset_t * restrict);
int sigrelse(int);
void (* _Nullable sigset(int, void (* _Nullable)(int)))(int);
int sigsuspend(const sigset_t *) __asm("_" "sigsuspend" );
int sigwait(const sigset_t * restrict, int * restrict) __asm("_" "sigwait" );
# 113 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/signal.h" 3 4
inline __attribute__ ((__always_inline__)) int
__sigbits(int __signo)
{
    return __signo > 32 ? 0 : (1 << (__signo - 1));
}
# 233 "/Users/weugene/basilisk/src/fp_osx.h" 2



static const char *fe_code_name[] = {
  "FPE_NOOP",
  "FPE_FLTDIV", "FPE_FLTINV", "FPE_FLTOVF", "FPE_FLTUND",
  "FPE_FLTRES", "FPE_FLTSUB", "FPE_INTDIV", "FPE_INTOVF"
  "FPE_UNKNOWN"
};
# 257 "/Users/weugene/basilisk/src/fp_osx.h"
void
fhdl ( int sig, siginfo_t *sip, ucontext_t *scp )
{
  int fe_code = sip->si_code;
  unsigned int excepts = fetestexcept (0x003f);

  switch (fe_code)
  {



    case 1: fe_code = 1; break;
    case 5: fe_code = 2; break;
    case 2: fe_code = 3; break;
    case 3: fe_code = 4; break;
    case 4: fe_code = 5; break;
    case 6: fe_code = 6; break;
    case 7: fe_code = 7; break;
    case 8: fe_code = 8; break;
            default: fe_code = 9;
   }

  if ( sig == 8 )
  {

    unsigned short x87cr,x87sr;
    unsigned int mxcsr;

    __asm ("fnstcw %0" : "=m" (x87cr));;
    __asm ("fnstsw %0" : "=m" (x87sr));;
    __asm ("stmxcsr %0" : "=m" (mxcsr));;
    printf ("X87CR:   0x%04X\n", x87cr);
    printf ("X87SR:   0x%04X\n", x87sr);
    printf ("MXCSR:   0x%08X\n", mxcsr);
# 300 "/Users/weugene/basilisk/src/fp_osx.h"
    printf ("signal:  SIGFPE with code %s\n", fe_code_name[fe_code]);
    printf ("invalid flag:    0x%04X\n", excepts & 0x0001);
    printf ("divByZero flag:  0x%04X\n", excepts & 0x0004);
  }
  else printf ("Signal is not SIGFPE, it's %i.\n", sig);

  abort();
}
# 823 "/Users/weugene/basilisk/src/common.h" 2



static void set_fpe (void) {
  int64_t lnan = 0x7ff0000000000001;
  (__builtin_expect(!(sizeof (int64_t) == sizeof (double)), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/common.h", 828, "sizeof (int64_t) == sizeof (double)") : (void)0);
  __builtin___memcpy_chk (&undefined, &lnan, sizeof (double), __builtin_object_size (&undefined, 0));
  feenableexcept (0x0004|0x0001);
}
# 840 "/Users/weugene/basilisk/src/common.h"
typedef struct {
  long n;
  long tn;
  int depth;
  int maxdepth;
} Grid;
Grid * grid = ((void*)0);

double X0 = 0., Y0 = 0., Z0 = 0.;

double L0 = 1.;




int N = 16;


typedef struct { int i; } scalar;

typedef struct {
  scalar x;

  scalar y;


  scalar z;

} vector;

typedef struct {
  vector x;

  vector y;


  vector z;

} tensor;

struct { int x, y, z; } Period = {0, 0, 0};

typedef struct {
  double x, y, z;
} coord;
# 897 "/Users/weugene/basilisk/src/common.h"
void normalize (coord * n)
{
  double norm = 0.;
  {
# 900 "/Users/weugene/basilisk/src/common.h"

    norm += ((n->x)*(n->x));
# 900 "/Users/weugene/basilisk/src/common.h"

    norm += ((n->y)*(n->y));
# 900 "/Users/weugene/basilisk/src/common.h"

    norm += ((n->z)*(n->z));}
  norm = sqrt(norm);
  {
# 903 "/Users/weugene/basilisk/src/common.h"

    n->x /= norm;
# 903 "/Users/weugene/basilisk/src/common.h"

    n->y /= norm;
# 903 "/Users/weugene/basilisk/src/common.h"

    n->z /= norm;}
}

struct _origin { double x, y, z; };

void origin (struct _origin p) {
  X0 = p.x; Y0 = p.y; Z0 = p.z;
}

void size (double L) {
  L0 = L;
}

double zero (double s0, double s1, double s2) { return 0.; }
# 926 "/Users/weugene/basilisk/src/common.h"
 enum { right, left, top, bottom, front, back };

int nboundary = 2*3;
# 937 "/Users/weugene/basilisk/src/common.h"
double * _constant = ((void*)0);
extern size_t datasize;
typedef struct _Point Point;
# 1 "/Users/weugene/basilisk/src/grid/boundaries.h"


typedef struct _Boundary Boundary;

struct _Boundary {
  void (* destroy) (Boundary * b);
  void (* level) (const Boundary * b, scalar * list, int l);

  void (* restriction) (const Boundary * b, scalar * list, int l);
};

static Boundary ** boundaries = ((void*)0);

void add_boundary (Boundary * b) {
  int len = 0;
  if (boundaries) {
    Boundary ** i = boundaries;
    while (*i++) len++;
  }
  boundaries = (Boundary * *) realloc(boundaries,(len + 2)*sizeof(Boundary *));
  boundaries[len] = b;
  boundaries[len+1] = ((void*)0);
}

void free_boundaries() {
  if (!boundaries)
    return;
  Boundary ** i = boundaries, * b;
  while ((b = *i++))
    if (b->destroy)
      b->destroy (b);
    else
      free(b);
  free(boundaries);
  boundaries = ((void*)0);
}
# 47 "/Users/weugene/basilisk/src/grid/boundaries.h"
typedef struct {
  Boundary parent;
  int d;
} BoxBoundary;
# 942 "/Users/weugene/basilisk/src/common.h"



typedef struct {
# 947 "/Users/weugene/basilisk/src/common.h"

  double (** boundary) (Point, Point, scalar, void *);
  double (** boundary_homogeneous) (Point, Point, scalar, void *);
  double (* gradient) (double, double, double);
  void (* delete) (scalar);
  char * name;
  struct {
    int x;

    int y;


    int z;

  } d;
  vector v;
  _Bool face, nodump, freed;
  int block;
# 17 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  void (* prolongation) (Point, scalar);
  void (* restriction) (Point, scalar);
# 8 "/Users/weugene/basilisk/src/grid/tree-common.h"

  void (* refine) (Point, scalar);
# 94 "/Users/weugene/basilisk/src/grid/tree-common.h"

  void (* coarsen) (Point, scalar);
# 27 "/Users/weugene/basilisk/src/vof.h"

  scalar * tracers, c;
  _Bool inverse;
# 81 "/Users/weugene/basilisk/src/fractions.h"

  vector n;
# 20 "/Users/weugene/basilisk/src/iforce.h"

  scalar phi;
# 456 "/Users/weugene/basilisk/src/heights.h"

  vector height;
# 23 "/Users/weugene/basilisk/src/tension.h"

  double sigma;

} _Attributes;
_Attributes * _attribute;
# 945 "/Users/weugene/basilisk/src/common.h"
# 971 "/Users/weugene/basilisk/src/common.h"
int list_len (scalar * list)
{
  if (!list) return 0;
  int ns = 0;
  if (list) for (scalar s = *list, *_i0 = list; ((scalar *)&s)->i >= 0; s = *++_i0) ns++;
  return ns;
}

scalar * list_append (scalar * list, scalar s)
{
  int len = list_len (list);
  list = (scalar *) realloc(list,(len + 2)*sizeof(scalar));
  list[len] = s;
  list[len + 1].i = -1;
  return list;
}

scalar * list_prepend (scalar * list, scalar s)
{
  int len = list_len (list);
  list = (scalar *) realloc(list,(len + 2)*sizeof(scalar));
  for (int i = len; i >= 1; i--)
    list[i] = list[i-1];
  list[0] = s;
  list[len + 1].i = -1;
  return list;
}

scalar * list_add (scalar * list, scalar s)
{
  if (list) for (scalar t = *list, *_i1 = list; ((scalar *)&t)->i >= 0; t = *++_i1)
    if (t.i == s.i)
      return list;
  return list_append (list, s);
}

int list_lookup (scalar * l, scalar s)
{
  if (l != ((void*)0))
    if (l) for (scalar s1 = *l, *_i2 = l; ((scalar *)&s1)->i >= 0; s1 = *++_i2)
      if (s1.i == s.i)
 return 1;
  return 0;
}

scalar * list_copy (scalar * l)
{
  scalar * list = ((void*)0);
  if (l != ((void*)0))
    if (l) for (scalar s = *l, *_i3 = l; ((scalar *)&s)->i >= 0; s = *++_i3)
      list = list_append (list, s);
  return list;
}

scalar * list_concat (scalar * l1, scalar * l2)
{
  scalar * l3 = list_copy (l1);
  if (l2) for (scalar s = *l2, *_i4 = l2; ((scalar *)&s)->i >= 0; s = *++_i4)
    l3 = list_append (l3, s);
  return l3;
}

void list_print (scalar * l, FILE * fp)
{
  int i = 0;
  if (l) for (scalar s = *l, *_i5 = l; ((scalar *)&s)->i >= 0; s = *++_i5)
    fprintf (fp, "%s%s", i++ == 0 ? "{" : ",", _attribute[s.i].name);
  fputs (i > 0 ? "}\n" : "{}\n", fp);
}

int vectors_len (vector * list)
{
  if (!list) return 0;
  int nv = 0;
  if (list) for (vector v = *list, *_i6 = list; ((scalar *)&v)->i >= 0; v = *++_i6) nv++;
  return nv;
}

vector * vectors_append (vector * list, vector v)
{
  int len = vectors_len (list);
  list = (vector *) realloc(list,(len + 2)*sizeof(vector));
  list[len] = v;
  list[len + 1] = (vector){{-1}};
  return list;
}

vector * vectors_add (vector * list, vector v)
{
  if (list) for (vector w = *list, *_i7 = list; ((scalar *)&w)->i >= 0; w = *++_i7) {
    _Bool id = 1;
    {
# 1062 "/Users/weugene/basilisk/src/common.h"

      if (w.x.i != v.x.i)
 id = 0;
# 1062 "/Users/weugene/basilisk/src/common.h"

      if (w.y.i != v.y.i)
 id = 0;
# 1062 "/Users/weugene/basilisk/src/common.h"

      if (w.z.i != v.z.i)
 id = 0;}
    if (id)
      return list;
  }
  return vectors_append (list, v);
}

vector * vectors_copy (vector * l)
{
  vector * list = ((void*)0);
  if (l != ((void*)0))
    if (l) for (vector v = *l, *_i8 = l; ((scalar *)&v)->i >= 0; v = *++_i8)
      list = vectors_append (list, v);
  return list;
}

vector * vectors_from_scalars (scalar * s)
{
  vector * list = ((void*)0);
  while (s->i >= 0) {
    vector v;
    {
# 1085 "/Users/weugene/basilisk/src/common.h"
 {
      (__builtin_expect(!(s->i >= 0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/common.h", 1086, "s->i >= 0") : (void)0);
      v.x = *s++;
    }
# 1085 "/Users/weugene/basilisk/src/common.h"
 {
      (__builtin_expect(!(s->i >= 0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/common.h", 1086, "s->i >= 0") : (void)0);
      v.y = *s++;
    }
# 1085 "/Users/weugene/basilisk/src/common.h"
 {
      (__builtin_expect(!(s->i >= 0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/common.h", 1086, "s->i >= 0") : (void)0);
      v.z = *s++;
    }}
    list = vectors_append (list, v);
  }
  return list;
}

int tensors_len (tensor * list)
{
  if (!list) return 0;
  int nt = 0;
  if (list) for (tensor t = *list, *_i9 = list; ((scalar *)&t)->i >= 0; t = *++_i9) nt++;
  return nt;
}

tensor * tensors_append (tensor * list, tensor t)
{
  int len = tensors_len (list);
  list = (tensor *) realloc(list,(len + 2)*sizeof(tensor));
  list[len] = t;
  list[len + 1] = (tensor){{{-1}}};
  return list;
}

tensor * tensors_from_vectors (vector * v)
{
  tensor * list = ((void*)0);
  while (v->x.i >= 0) {
    tensor t;
    {
# 1116 "/Users/weugene/basilisk/src/common.h"
 {
      (__builtin_expect(!(v->x.i >= 0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/common.h", 1117, "v->x.i >= 0") : (void)0);
      t.x = *v++;
    }
# 1116 "/Users/weugene/basilisk/src/common.h"
 {
      (__builtin_expect(!(v->y.i >= 0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/common.h", 1117, "v->y.i >= 0") : (void)0);
      t.y = *v++;
    }
# 1116 "/Users/weugene/basilisk/src/common.h"
 {
      (__builtin_expect(!(v->z.i >= 0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/common.h", 1117, "v->z.i >= 0") : (void)0);
      t.z = *v++;
    }}
    list = tensors_append (list, t);
  }
  return list;
}

scalar * all = ((void*)0);



scalar (* init_scalar) (scalar, const char *);
scalar (* init_vertex_scalar) (scalar, const char *);
vector (* init_vector) (vector, const char *);
tensor (* init_tensor) (tensor, const char *);
vector (* init_face_vector) (vector, const char *);





typedef struct _Event Event;
typedef int (* Expr) (int *, double *, Event *);

struct _Event {
  int last, nexpr;
  int (* action) (const int, const double, Event *);
  Expr expr[3];
  int * arrayi;
  double * arrayt;
  char * file;
  int line;
  char * name;
  double t;
  int i, a;
  void * data;
  Event * next;
};

static Event * Events = ((void*)0);

int iter = 0, inext = 0;
double t = 0, tnext = 0;
void init_events (void);
void event_register (Event event);
void _init_solver (void);







typedef struct {
  clock_t c;
  struct timeval tv;
  double tm;
} timer;

timer timer_start (void)
{
  timer t;
  t.c = clock();
  gettimeofday (&t.tv, ((void*)0));



  return t;
}

double timer_elapsed (timer t)
{
  struct timeval tvend;
  gettimeofday (&tvend, ((void*)0));
  return ((tvend.tv_sec - t.tv.tv_sec) +
   (tvend.tv_usec - t.tv.tv_usec)/1e6);
}


vector zerof= {{65536 + 0},{65536 + 1},{65536 + 2}};
vector unityf= {{65536 + 3},{65536 + 4},{65536 + 5}};
scalar unity= {65536 + 6};
scalar zeroc= {65536 + 7};



 vector fm = {{65536 + 3},{65536 + 4},{65536 + 5}};
 scalar cm = {(65536 + 6)};
# 1219 "/Users/weugene/basilisk/src/common.h"
static FILE ** qpopen_pipes = ((void*)0);

FILE * qpopen (const char * command, const char * type)
{
  if (0 > 0)
    return fopen ("/dev/null", type);
  FILE * fp = popen (command, type);
  if (fp) {
    FILE ** i = qpopen_pipes;
    int n = 0;
    while (i && *i) { n++; i++; }
    qpopen_pipes = (FILE * *) realloc(qpopen_pipes,(n + 2)*sizeof(FILE *));
    qpopen_pipes[n] = fp;
    qpopen_pipes[n+1] = ((void*)0);
  }
  return fp;
}

int qpclose (FILE * fp)
{
  if (0 > 0)
    return fclose (fp);
  FILE ** i = qpopen_pipes;
  while (i && *i) {
    if (*i == fp)
      *i = (FILE *) 1;
    i++;
  }
  return pclose (fp);
}

static void qpclose_all()
{
  FILE ** i = qpopen_pipes;
  while (i && *i) {
    if (*i != (FILE *) 1)
      pclose (*i);
    i++;
  }
  free(qpopen_pipes);
  qpopen_pipes = ((void*)0);
}






FILE * lfopen (const char * name, const char * mode)
{
  char fname[80];
  __builtin___sprintf_chk (fname, 0, __builtin_object_size (fname, 2 > 1 ? 1 : 0), "%s-%d", name, 0);
  return fopen (fname, mode);
}



void * matrix_new (int n, int p, size_t size)
{
  void ** m = ((void * *) malloc((n)*sizeof(void *)));
  char * a = ((char *) malloc((n*p*size)*sizeof(char)));
  for (int i = 0; i < n; i++)
    m[i] = a + i*p*size;
  return m;
}

double matrix_inverse (double ** m, int n, double pivmin)
{
  int indxc[n], indxr[n], ipiv[n];
  int i, icol = 0, irow = 0, j, k, l, ll;
  double big, dum, pivinv, minpiv = ((double)1e30);

  for (j = 0; j < n; j++)
    ipiv[j] = -1;

  for (i = 0; i < n; i++) {
    big = 0.0;
    for (j = 0; j < n; j++)
      if (ipiv[j] != 0)
 for (k = 0; k < n; k++) {
   if (ipiv[k] == -1) {
     if (fabs (m[j][k]) >= big) {
       big = fabs (m[j][k]);
       irow = j;
       icol = k;
     }
   }
 }
    ipiv[icol]++;
    if (irow != icol)
      for (l = 0; l < n; l++)
 { double tmp = m[irow][l]; m[irow][l] = m[icol][l]; m[icol][l] = tmp; };
    indxr[i] = irow;
    indxc[i] = icol;
    if (fabs (m[icol][icol]) <= pivmin)
      return 0.;
    if (fabs (m[icol][icol]) < minpiv)
      minpiv = fabs (m[icol][icol]);
    pivinv = 1.0/m[icol][icol];
    m[icol][icol] = 1.0;
    for (l = 0; l < n; l++) m[icol][l] *= pivinv;
    for (ll = 0; ll < n; ll++)
      if (ll != icol) {
 dum = m[ll][icol];
 m[ll][icol] = 0.0;
 for (l = 0; l < n; l++)
   m[ll][l] -= m[icol][l]*dum;
      }
  }
  for (l = n - 1; l >= 0; l--) {
    if (indxr[l] != indxc[l])
      for (k = 0; k < n; k++)
 { double tmp = m[k][indxr[l]]; m[k][indxr[l]] = m[k][indxc[l]]; m[k][indxc[l]] = tmp; };
  }
  return minpiv;
}

void matrix_free (void * m)
{
  free(((void **) m)[0]);
  free(m);
}



typedef void (* free_solver_func) (void);

static Array * free_solver_funcs = ((void*)0);

void free_solver_func_add (free_solver_func func)
{
  if (!free_solver_funcs)
    free_solver_funcs = array_new();
  array_append (free_solver_funcs, &func, sizeof(free_solver_func));
}



static char * display_defaults = ((void*)0);

struct _display {
  const char * commands;
  _Bool overwrite;
};

static void free_display_defaults() {
  free(display_defaults);
}

void display (struct _display p)
{
  if (display_defaults == ((void*)0))
    free_solver_func_add (free_display_defaults);
  if (p.overwrite) {
    free(display_defaults);
    display_defaults = malloc(strlen(p.commands) + 2);
    __builtin___strcpy_chk (display_defaults, "@", __builtin_object_size (display_defaults, 2 > 1 ? 1 : 0));
    __builtin___strcat_chk (display_defaults, p.commands, __builtin_object_size (display_defaults, 2 > 1 ? 1 : 0));
  }
  else {
    if (!display_defaults)
      display_defaults = strdup("@");
    display_defaults =
      realloc(display_defaults,strlen(display_defaults) + strlen(p.commands) + 1);

    __builtin___strcat_chk (display_defaults, p.commands, __builtin_object_size (display_defaults, 2 > 1 ? 1 : 0));
  }
}
# 14 "tube_bp_rel-cpp.c"
static double _boundary0 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary0_homogeneous (Point point, Point neighbor, scalar _s, void * data);
static double _boundary1 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary1_homogeneous (Point point, Point neighbor, scalar _s, void * data);
static double _boundary2 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary2_homogeneous (Point point, Point neighbor, scalar _s, void * data);
static double _boundary3 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary3_homogeneous (Point point, Point neighbor, scalar _s, void * data);
static double _boundary4 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary4_homogeneous (Point point, Point neighbor, scalar _s, void * data);
static double _boundary5 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary5_homogeneous (Point point, Point neighbor, scalar _s, void * data);
static double _boundary6 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary6_homogeneous (Point point, Point neighbor, scalar _s, void * data);
static double _boundary7 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary7_homogeneous (Point point, Point neighbor, scalar _s, void * data);
static double _boundary8 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary8_homogeneous (Point point, Point neighbor, scalar _s, void * data);
static double _boundary9 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary9_homogeneous (Point point, Point neighbor, scalar _s, void * data);
static double _boundary10 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary10_homogeneous (Point point, Point neighbor, scalar _s, void * data);
static double _boundary11 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary11_homogeneous (Point point, Point neighbor, scalar _s, void * data);
static double _boundary12 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary12_homogeneous (Point point, Point neighbor, scalar _s, void * data);
static double _boundary13 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary13_homogeneous (Point point, Point neighbor, scalar _s, void * data);
static double _boundary14 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary14_homogeneous (Point point, Point neighbor, scalar _s, void * data);
static double _boundary15 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary15_homogeneous (Point point, Point neighbor, scalar _s, void * data);
static double _boundary16 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary16_homogeneous (Point point, Point neighbor, scalar _s, void * data);
static double _boundary17 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary17_homogeneous (Point point, Point neighbor, scalar _s, void * data);
# 1 "tube_bp_rel.c"
# 13 "tube_bp_rel.c"
scalar fs= {0};
 vector target_Uv;
vector define_v(void);
# 1 "./grid/octree.h"
# 1 "/Users/weugene/basilisk/src/grid/octree.h"
# 1 "./grid/tree.h"
# 1 "/Users/weugene/basilisk/src/grid/tree.h"
# 1 "./grid/mempool.h"
# 1 "/Users/weugene/basilisk/src/grid/mempool.h"





typedef struct _Pool Pool;

struct _Pool {
  Pool * next;
};

typedef struct {
  char * first, * lastb;
  size_t size;
  size_t poolsize;
  Pool * pool, * last;
} Mempool;

typedef struct {
  char * next;
} FreeBlock;

Mempool * mempool_new (size_t poolsize, size_t size)
{

  (__builtin_expect(!(poolsize % 8 == 0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/mempool.h", 26, "poolsize % 8 == 0") : (void)0);
  (__builtin_expect(!(size >= sizeof(FreeBlock)), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/mempool.h", 27, "size >= sizeof(FreeBlock)") : (void)0);


  poolsize = ((1 << 20) < (poolsize + sizeof(Pool)) ? (1 << 20) : (poolsize + sizeof(Pool)));
  Mempool * m = ((Mempool *) calloc(1,sizeof(Mempool)));
  m->poolsize = poolsize;
  m->size = size;
  return m;
}

void mempool_destroy (Mempool * m)
{
  Pool * p = m->pool;
  while (p) {
    Pool * next = p->next;
    free(p);
    p = next;
  }
  free(m);
}

void * mempool_alloc (Mempool * m)
{
  if (!m->first) {

    Pool * p = (Pool *) malloc(m->poolsize);
    p->next = ((void*)0);
    if (m->last)
      m->last->next = p;
    else
      m->pool = p;
    m->last = p;
    m->first = m->lastb = ((char *)m->last) + sizeof(Pool);
    FreeBlock * b = (FreeBlock *) m->first;
    b->next = ((void*)0);
  }
  void * ret = m->first;
  FreeBlock * b = (FreeBlock *) ret;
  char * next = b->next;
  if (!next) {
    m->lastb += m->size;
    next = m->lastb;
    if (next + m->size > ((char *) m->last) + m->poolsize)
      next = ((void*)0);
    else {
      FreeBlock * b = (FreeBlock *) next;
      b->next = ((void*)0);
    }
  }
  m->first = next;





  return ret;
}

void * mempool_alloc0 (Mempool * m)
{
  void * ret = mempool_alloc (m);
  __builtin___memset_chk (ret, 0, m->size, __builtin_object_size (ret, 0));
  return ret;
}

void mempool_free (Mempool * m, void * p)
{





  FreeBlock * b = (FreeBlock *) p;
  b->next = m->first;
  m->first = (char *) p;
}
# 2 "/Users/weugene/basilisk/src/grid/tree.h"
# 22 "/Users/weugene/basilisk/src/grid/tree.h"
typedef struct {
  unsigned short flags;

  unsigned short neighbors;
  int pid;
} Cell;

enum {
  active = 1 << 0,
  leaf = 1 << 1,
  border = 1 << 2,
  vertex = 1 << 3,
  user = 4,

  face_x = 1 << 0

  , face_y = 1 << 1


  , face_z = 1 << 2

};
# 54 "/Users/weugene/basilisk/src/grid/tree.h"
typedef struct {
  int i;

  int j;


  int k;

} IndexLevel;

typedef struct {
  IndexLevel * p;
  int n, nm;
} CacheLevel;

typedef struct {
  int i;

  int j;


  int k;

  int level, flags;
} Index;

typedef struct {
  Index * p;
  int n, nm;
} Cache;




static char * new_refarray (size_t len, size_t size) {
  return (char *) calloc(len + 1,size);
}

static void refarray (void * p, size_t len, size_t size) {
  int * refcount = (int *)(((char *)p) + len*size);
  (*refcount)++;
}

static _Bool unrefarray (void * p, size_t len, size_t size) {
  int * refcount = (int *)(((char *)p) + len*size);
  (*refcount)--;
  if (*refcount == 0) {
    free(p);
    return 1;
  }
  return 0;
}




typedef struct {





  char **** m;

  Mempool * pool;
  int nc;
  int len;
} Layer;

static size_t _size (size_t depth)
{
  return (1 << depth) + 2*2;
}

static size_t poolsize (size_t depth, size_t size)
{






  return ((_size(depth))*(_size(depth))*(_size(depth)))*size;

}
# 140 "/Users/weugene/basilisk/src/grid/tree.h"

static inline
void assign_periodic_x (void ** m, int i, int nl, void * b)
{
  m[i] = b;
  if (Period.x) {
    for (int j = i; j < nl + 2*2; j += nl)
      m[j] = b;
    for (int j = i - nl; j >= 0; j -= nl)
      m[j] = b;
  }
}
# 140 "/Users/weugene/basilisk/src/grid/tree.h"

static inline
void assign_periodic_y (void ** m, int i, int nl, void * b)
{
  m[i] = b;
  if (Period.y) {
    for (int j = i; j < nl + 2*2; j += nl)
      m[j] = b;
    for (int j = i - nl; j >= 0; j -= nl)
      m[j] = b;
  }
}
# 140 "/Users/weugene/basilisk/src/grid/tree.h"

static inline
void assign_periodic_z (void ** m, int i, int nl, void * b)
{
  m[i] = b;
  if (Period.z) {
    for (int j = i; j < nl + 2*2; j += nl)
      m[j] = b;
    for (int j = i - nl; j >= 0; j -= nl)
      m[j] = b;
  }
}

static Layer * new_layer (int depth)
{
  Layer * l = ((Layer *) malloc((1)*sizeof(Layer)));
  l->len = _size (depth);
  if (depth == 0)
    l->pool = ((void*)0);
  else {
    size_t size = sizeof(Cell) + datasize;


    l->pool = mempool_new (poolsize (depth, size), (1 << 3)*size);
  }





  l->m = ((char *** *) calloc(l->len,sizeof(char ***)));

  l->nc = 0;
  return l;
}

static void destroy_layer (Layer * l)
{
  if (l->pool)
    mempool_destroy (l->pool);
  free(l->m);
  free(l);
}
# 200 "/Users/weugene/basilisk/src/grid/tree.h"
static void layer_add_row (Layer * l, int i, int j)
{
  if (!l->m[i]) {
    assign_periodic_x ((void **) l->m, i, l->len - 2*2,
         (void *) new_refarray (l->len, sizeof (char *)));
    l->nc++;
  }
  refarray (l->m[i], l->len, sizeof(char *));

  if (!l->m[i][j])
    assign_periodic_y ((void **) l->m[i], j, l->len - 2*2,
         (void *) new_refarray (l->len, sizeof (char *)));
  refarray (l->m[i][j], l->len, sizeof(char *));

}

static _Bool layer_remove_row (Layer * l, int i, int j)
{

  if (unrefarray (l->m[i][j], l->len, sizeof (char *)))
    assign_periodic_y ((void **) l->m[i], j, l->len - 2*2, ((void*)0));

  if (unrefarray (l->m[i], l->len, sizeof (char *))) {
    assign_periodic_x ((void **) l->m, i, l->len - 2*2, ((void*)0));
    if (--l->nc == 0) {
      destroy_layer (l);
      return 1;
    }
    (__builtin_expect(!(l->nc >= 0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree.h", 228, "l->nc >= 0") : (void)0);
  }
  return 0;
}




typedef struct {
  Grid g;
  Layer ** L;

  Cache leaves;
  Cache faces;
  Cache vertices;
  Cache refined;
  CacheLevel * active;
  CacheLevel * prolongation;
  CacheLevel * boundary;

  CacheLevel * restriction;

  _Bool dirty;
} Tree;



struct _Point {

  int i;

  int j;


  int k;

  int level;






};
static Point last_point;



static void cache_level_append (CacheLevel * c, Point p)
{
  if (c->n >= c->nm) {
    c->nm += 128;
    c->p = (IndexLevel *) realloc(c->p,(c->nm)*sizeof(IndexLevel));
  }
  c->p[c->n].i = p.i;

  c->p[c->n].j = p.j;


  c->p[c->n].k = p.k;

  c->n++;
}

static void cache_level_shrink (CacheLevel * c)
{
  if (c->nm > (c->n/128 + 1)*128) {
    c->nm = (c->n/128 + 1)*128;
    (__builtin_expect(!(c->nm > c->n), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree.h", 296, "c->nm > c->n") : (void)0);
    c->p = (IndexLevel *) realloc(c->p,sizeof (Index)*c->nm);
  }
}

static void cache_append (Cache * c, Point p, unsigned short flags)
{
  if (c->n >= c->nm) {
    c->nm += 128;
    c->p = (Index *) realloc(c->p,(c->nm)*sizeof(Index));
  }
  c->p[c->n].i = p.i;

  c->p[c->n].j = p.j;


  c->p[c->n].k = p.k;

  c->p[c->n].level = p.level;
  c->p[c->n].flags = flags;
  c->n++;
}

void cache_shrink (Cache * c)
{
  cache_level_shrink ((CacheLevel *)c);
}
# 378 "/Users/weugene/basilisk/src/grid/tree.h"
# 388 "/Users/weugene/basilisk/src/grid/tree.h"
# 392 "/Users/weugene/basilisk/src/grid/tree.h"
# 395 "/Users/weugene/basilisk/src/grid/tree.h"
# 404 "/Users/weugene/basilisk/src/grid/tree.h"
# 407 "/Users/weugene/basilisk/src/grid/tree.h"
# 430 "/Users/weugene/basilisk/src/grid/tree.h"
# 466 "/Users/weugene/basilisk/src/grid/tree.h"
# 1 "./grid/foreach_cell.h"
# 1 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 66 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 89 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 123 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 134 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 147 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 244 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 250 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 262 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 275 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 281 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 469 "/Users/weugene/basilisk/src/grid/tree.h"
# 504 "/Users/weugene/basilisk/src/grid/tree.h"
# 514 "/Users/weugene/basilisk/src/grid/tree.h"
# 522 "/Users/weugene/basilisk/src/grid/tree.h"
# 532 "/Users/weugene/basilisk/src/grid/tree.h"
# 541 "/Users/weugene/basilisk/src/grid/tree.h"
# 567 "/Users/weugene/basilisk/src/grid/tree.h"
# 593 "/Users/weugene/basilisk/src/grid/tree.h"
# 601 "/Users/weugene/basilisk/src/grid/tree.h"
# 624 "/Users/weugene/basilisk/src/grid/tree.h"
# 638 "/Users/weugene/basilisk/src/grid/tree.h"
# 645 "/Users/weugene/basilisk/src/grid/tree.h"
# 1 "./grid/neighbors.h"
# 1 "/Users/weugene/basilisk/src/grid/neighbors.h"
# 35 "/Users/weugene/basilisk/src/grid/neighbors.h"
# 45 "/Users/weugene/basilisk/src/grid/neighbors.h"
# 52 "/Users/weugene/basilisk/src/grid/neighbors.h"
# 649 "/Users/weugene/basilisk/src/grid/tree.h"

static inline _Bool has_local_children (Point point)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 651 "/Users/weugene/basilisk/src/grid/tree.h"

   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0))
      return 1; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  return 0;
}

static inline void cache_append_face (Point point, unsigned short flags)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 659 "/Users/weugene/basilisk/src/grid/tree.h"

  Tree * q = ((Tree *)grid);
  cache_append (&q->faces, point, flags);
# 673 "/Users/weugene/basilisk/src/grid/tree.h"
 {
# 673 "/Users/weugene/basilisk/src/grid/tree.h"

    if (flags & face_x)
      for (int i = 0; i <= 1; i++)
 for (int j = 0; j <= 1; j++)
   if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j]))))).flags & vertex)) {
     cache_append (&q->vertices, (Point) { point.i + 0, point.j + i, point.k + j, point.level }, 0);
     (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j])))).flags |= vertex;
   }
# 673 "/Users/weugene/basilisk/src/grid/tree.h"

    if (flags & face_y)
      for (int i = 0; i <= 1; i++)
 for (int j = 0; j <= 1; j++)
   if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i]))))).flags & vertex)) {
     cache_append (&q->vertices, (Point) { point.i + j, point.j + 0, point.k + i, point.level }, 0);
     (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i])))).flags |= vertex;
   }
# 673 "/Users/weugene/basilisk/src/grid/tree.h"

    if (flags & face_z)
      for (int i = 0; i <= 1; i++)
 for (int j = 0; j <= 1; j++)
   if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]))))).flags & vertex)) {
     cache_append (&q->vertices, (Point) { point.i + i, point.j + j, point.k + 0, point.level }, 0);
     (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0])))).flags |= vertex;
   }}

}



void check_periodic (Tree * q)
{
# 713 "/Users/weugene/basilisk/src/grid/tree.h"
}

static void update_cache_f (void)
{
  Tree * q = ((Tree *)grid);

  check_periodic (q);

   { { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < q->vertices.n; _k++) { point.i = q->vertices.p[_k].i; point.j = q->vertices.p[_k].j; point.k = q->vertices.p[_k].k; point.level = q->vertices.p[_k].level; _flags = q->vertices.p[_k].flags; ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 721 "/Users/weugene/basilisk/src/grid/tree.h"

    if (level <= (grid->depth) && (point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))
      (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~vertex; } } } }; }


  q->leaves.n = q->faces.n = q->vertices.n = 0;
  for (int l = 0; l <= (grid->depth); l++)
    q->active[l].n = q->prolongation[l].n =
      q->boundary[l].n = q->restriction[l].n = 0;

  const unsigned short fboundary = 1 << user;
   { { Point root = {2,2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 732 "/Users/weugene/basilisk/src/grid/tree.h"
 {



    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & active)) {


      cache_level_append (&q->active[level], point);
    }
# 756 "/Users/weugene/basilisk/src/grid/tree.h"
 if (!((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid < 0)) {

       { { int _nn = 2 + 0 ? 2 + 0 : 2; int _i = point.i, _j = point.j, _k = point.k; for (int _l = - _nn; _l <= _nn; _l++) { point.i = _i + _l; for (int _m = - _nn; _m <= _nn; _m++) { point.j = _j + _m; for (int _n = - _nn; _n <= _nn; _n++) { point.k = _k + _n; ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
 if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) && ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid < 0) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & fboundary)) {
   cache_level_append (&q->boundary[level], point);
   (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags |= fboundary;
 } } } } point.i = _i; point.j = _j; point.k = _k;}; }
    }

    else if (level > 0 && (((*((Cell *)((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+0][(point.k+2)/2+0]))))).pid == 0))
      cache_level_append (&q->restriction[level], point);

    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {
      if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0)) {
 cache_append (&q->leaves, point, 0);

 unsigned short flags = 0;
 {
# 773 "/Users/weugene/basilisk/src/grid/tree.h"

   if (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0])))).pid < 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0])))).pid >= 0) ||
       (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]))))).flags & leaf))
     flags |= face_x;
# 773 "/Users/weugene/basilisk/src/grid/tree.h"

   if (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0])))).pid < 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0])))).pid >= 0) ||
       (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]))))).flags & leaf))
     flags |= face_y;
# 773 "/Users/weugene/basilisk/src/grid/tree.h"

   if (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1])))).pid < 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1])))).pid >= 0) ||
       (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]))))).flags & leaf))
     flags |= face_z;}
 if (flags)
   cache_append (&q->faces, point, flags);
 {
# 779 "/Users/weugene/basilisk/src/grid/tree.h"

   if (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0])))).pid < 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0])))).pid >= 0) ||
       (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]))))).pid == 0) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]))))).flags & leaf)))
     cache_append (&q->faces, (Point) { point.i + 1, point.j + 0, point.k + 0, point.level }, face_x);
# 779 "/Users/weugene/basilisk/src/grid/tree.h"

   if (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0])))).pid < 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0])))).pid >= 0) ||
       (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]))))).pid == 0) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]))))).flags & leaf)))
     cache_append (&q->faces, (Point) { point.i + 0, point.j + 1, point.k + 0, point.level }, face_y);
# 779 "/Users/weugene/basilisk/src/grid/tree.h"

   if (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1])))).pid < 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1])))).pid >= 0) ||
       (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]))))).pid == 0) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]))))).flags & leaf)))
     cache_append (&q->faces, (Point) { point.i + 0, point.j + 0, point.k + 1, point.level }, face_z);}

 for (int i = 0; i <= 1; i++)

   for (int j = 0; j <= 1; j++)


     for (int k = 0; k <= 1; k++)

       if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+k]))))).flags & vertex)) {
  cache_append (&q->vertices, (Point) { point.i + i, point.j + j, point.k + k, point.level }, 0);
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+k])))).flags |= vertex;
       }

        if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors > 0)
   cache_level_append (&q->prolongation[level], point);
      }
      else if (!((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid < 0) || (((*((Cell *)((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+0][(point.k+2)/2+0]))))).pid == 0)) {

 unsigned short flags = 0;
 {
# 802 "/Users/weugene/basilisk/src/grid/tree.h"

   if ((point.i+-1 >= 0 && point.i+-1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+-1] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) &&
       (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]))))).pid == 0) && (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0])))).pid >= 0))
     flags |= face_x;
# 802 "/Users/weugene/basilisk/src/grid/tree.h"

   if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+-1 >= 0 && point.j+-1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) &&
       (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]))))).pid == 0) && (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0])))).pid >= 0))
     flags |= face_y;
# 802 "/Users/weugene/basilisk/src/grid/tree.h"

   if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+-1 >= 0 && point.k+-1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) &&
       (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]))))).pid == 0) && (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1])))).pid >= 0))
     flags |= face_z;}
 if (flags)
   cache_append_face (point, flags);
 {
# 808 "/Users/weugene/basilisk/src/grid/tree.h"

   if ((point.i+1 >= 0 && point.i+1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+1] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]))))).pid == 0) &&
       (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0])))).pid >= 0))
     cache_append_face ((Point) { point.i + 1, point.j + 0, point.k + 0, point.level }, face_x);
# 808 "/Users/weugene/basilisk/src/grid/tree.h"

   if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+1 >= 0 && point.j+1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]))))).pid == 0) &&
       (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0])))).pid >= 0))
     cache_append_face ((Point) { point.i + 0, point.j + 1, point.k + 0, point.level }, face_y);
# 808 "/Users/weugene/basilisk/src/grid/tree.h"

   if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+1 >= 0 && point.k+1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]))))).pid == 0) &&
       (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1])))).pid >= 0))
     cache_append_face ((Point) { point.i + 0, point.j + 0, point.k + 1, point.level }, face_z);}
      }

      continue;

    }
  } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }


  cache_shrink (&q->leaves);
  cache_shrink (&q->faces);
  cache_shrink (&q->vertices);
  for (int l = 0; l <= (grid->depth); l++) {
    cache_level_shrink (&q->active[l]);
    cache_level_shrink (&q->prolongation[l]);
    cache_level_shrink (&q->boundary[l]);
    cache_level_shrink (&q->restriction[l]);
}

  q->dirty = 0;


  for (int l = (grid->depth); l >= 0; l--)
     { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _boundary = ((Tree *)grid)->boundary[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = l; int _k; for (_k = 0; _k < _boundary.n; _k++) { point.i = _boundary.p[_k].i; point.j = _boundary.p[_k].j; point.k = _boundary.p[_k].k; ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 834 "/Users/weugene/basilisk/src/grid/tree.h"

      (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~fboundary; } } } }; }}; }



  grid->n = q->leaves.n;


  grid->tn = grid->n;
  grid->maxdepth = grid->depth;

}
# 851 "/Users/weugene/basilisk/src/grid/tree.h"
# 873 "/Users/weugene/basilisk/src/grid/tree.h"
# 885 "/Users/weugene/basilisk/src/grid/tree.h"
# 890 "/Users/weugene/basilisk/src/grid/tree.h"
# 900 "/Users/weugene/basilisk/src/grid/tree.h"








void reset (void * alist, double val)
{
  scalar * list = (scalar *) alist;
  Tree * q = ((Tree *)grid);

  for (int l = 0; l <= (grid->depth); l++) {
    Layer * L = q->L[l];
    for (int i = 0; i < L->len; i++)
      if (L->m[i])







 for (int j = 0; j < L->len; j++)
   if (L->m[i][j])







          for (int k = 0; k < L->len; k++)
     if (L->m[i][j][k])
       if (list) for (scalar s = *list, *_i10 = list; ((scalar *)&s)->i >= 0; s = *++_i10) {
           if (!((s).i >= 65536))
    for (int b = 0; b < _attribute[s.i].block; b++)
      ((double *)(L->m[i][j][k] + sizeof(Cell)))[s.i + b] = val;
       }


  }
}
# 952 "/Users/weugene/basilisk/src/grid/tree.h"


static void update_depth (int inc)
{
  Tree * q = ((Tree *)grid);
  grid->depth += inc;
  q->L = &(q->L[-1]);
  q->L = (Layer * *) realloc(q->L,(grid->depth + 2)*sizeof(Layer *));
  q->L = &(q->L[1]);
  if (inc > 0)
    q->L[grid->depth] = new_layer (grid->depth);
  { for (int i = 0; i <= (grid->depth) - inc; i++) free(q->active[i].p); free(q->active); q->active = ((CacheLevel *) calloc((grid->depth) + 1,sizeof(CacheLevel)));};
  { for (int i = 0; i <= (grid->depth) - inc; i++) free(q->prolongation[i].p); free(q->prolongation); q->prolongation = ((CacheLevel *) calloc((grid->depth) + 1,sizeof(CacheLevel)));};
  { for (int i = 0; i <= (grid->depth) - inc; i++) free(q->boundary[i].p); free(q->boundary); q->boundary = ((CacheLevel *) calloc((grid->depth) + 1,sizeof(CacheLevel)));};
  { for (int i = 0; i <= (grid->depth) - inc; i++) free(q->restriction[i].p); free(q->restriction); q->restriction = ((CacheLevel *) calloc((grid->depth) + 1,sizeof(CacheLevel)));};
}

static void alloc_children (Point point)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 970 "/Users/weugene/basilisk/src/grid/tree.h"

  if (point.level == grid->depth)
    update_depth (+1);
  else if ((level < (grid->depth) && point.i > 0 && point.i <= (1 << level) + 2 && point.j > 0 && point.j <= (1 << level) + 2 && point.k > 0 && point.k <= (1 << level) + 2 && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0][2*point.j-2 +0] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0][2*point.j-2 +0] [2*point.k-2 +0]))
    return;


  Layer * L = ((Tree *)grid)->L[point.level + 1];
  size_t len = sizeof(Cell) + datasize;
  char * b = (char *) mempool_alloc0 (L->pool);
  int nl = L->len - 2*2;
  int i = 2*point.i - 2;
  for (int k = 0; k < 2; k++, i++) {
# 997 "/Users/weugene/basilisk/src/grid/tree.h"
 int j = 2*point.j - 2;
    for (int l = 0; l < 2; l++, j++) {
      layer_add_row (L, i, j);
      int m = 2*point.k - 2;
      for (int n = 0; n < 2; n++, m++) {
 (__builtin_expect(!(!L->m[i][j][m]), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree.h", 1002, "!L->m[i][j][m]") : (void)0);
 assign_periodic_z ((void **) L->m[i][j], m, nl, (void *) b);
 b += len;
      }
    }

  }

  int pid = (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; {
    (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid = pid;




  } } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
}
# 1055 "/Users/weugene/basilisk/src/grid/tree.h"
static void free_children (Point point)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 1056 "/Users/weugene/basilisk/src/grid/tree.h"


  Layer * L = ((Tree *)grid)->L[point.level + 1];
  int i = 2*point.i - 2, nl = L->len - 2*2;
  (__builtin_expect(!(L->m[i][2*point.j - 2][2*point.k - 2]), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree.h", 1060, "L->m[i][2*point.j - 2][2*point.k - 2]") : (void)0);
  mempool_free (L->pool, L->m[i][2*point.j - 2][2*point.k - 2]);
  for (int k = 0; k < 2; k++, i++) {
    int j = 2*point.j - 2;
    for (int l = 0; l < 2; l++, j++) {
      int m = 2*point.k - 2;
      for (int n = 0; n < 2; n++, m++)
 assign_periodic_z ((void **) L->m[i][j], m, nl, ((void*)0));
      if (layer_remove_row (L, i, j)) {
 (__builtin_expect(!(point.level + 1 == grid->depth), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree.h", 1069, "point.level + 1 == grid->depth") : (void)0);
 update_depth (-1);
      }
    }
  }
}


void increment_neighbors (Point point)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 1078 "/Users/weugene/basilisk/src/grid/tree.h"

  ((Tree *)grid)->dirty = 1;
  if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors++ == 0)
    alloc_children (point);
   { { int _nn = 2/2 + 0 ? 2/2 + 0 : 2; int _i = point.i, _j = point.j, _k = point.k; for (int _l = - _nn; _l <= _nn; _l++) { point.i = _i + _l; for (int _m = - _nn; _m <= _nn; _m++) { point.j = _j + _m; for (int _n = - _nn; _n <= _nn; _n++) { point.k = _k + _n; ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors++ == 0)
      alloc_children (point); } } } point.i = _i; point.j = _j; point.k = _k;}; }
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors--;
}

void decrement_neighbors (Point point)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 1089 "/Users/weugene/basilisk/src/grid/tree.h"

  ((Tree *)grid)->dirty = 1;
   { { int _nn = 2/2 + 0 ? 2/2 + 0 : 2; int _i = point.i, _j = point.j, _k = point.k; for (int _l = - _nn; _l <= _nn; _l++) { point.i = _i + _l; for (int _m = - _nn; _m <= _nn; _m++) { point.j = _j + _m; for (int _n = - _nn; _n <= _nn; _n++) { point.k = _k + _n; ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) {
      (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors--;
      if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors == 0)
 free_children (point);
    } } } } point.i = _i; point.j = _j; point.k = _k;}; }
  if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors) {
    int pid = (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid;
     { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; {
      (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags = 0;
      (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid = pid;
    } } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  }
}

static void apply_periodic_elem (char ** m, int len)
{
  if (m) {
    int end = len - 2;
    for (int k = 0; k < 2; k++) {
      m[k] = m[k + end - 2];
      m[end + k] = m[k + 2];
    }
  }
}

static void apply_periodic (Tree * q)
{
# 1138 "/Users/weugene/basilisk/src/grid/tree.h"
 if (Period.z) {
    for (int i = 0; i < q->L[0]->len; i++)
      for (int j = 0; j < q->L[0]->len; j++)
 for (int k = 0; k < q->L[0]->len; k++)
   q->L[0]->m[i][j][k] = q->L[0]->m[i][j][2];
    for (int l = 1; l <= (grid->depth); l++) {
      Layer * L = q->L[l];
      for (int i = 0; i < L->len; i++)
 if (L->m[i])
   for (int j = 0; j < L->len; j++)
     apply_periodic_elem (L->m[i][j], L->len);
    }
  }

}

void realloc_scalar (int size)
{

  Tree * q = ((Tree *)grid);
  size_t oldlen = sizeof(Cell) + datasize;
  size_t newlen = oldlen + size;
  datasize += size;

  Layer * L = q->L[0];
  int len = L->len;
  for (int i = Period.x*2; i < len - Period.x*2; i++) {



    for (int j = Period.y*2; j < len - Period.y*2; j++) {



      for (int k = Period.z*2; k < len - Period.z*2; k++)
 L->m[i][j][k] = (char *) realloc(L->m[i][j][k],(newlen)*sizeof(char));

    }

  }

  for (int l = 1; l <= (grid->depth); l++) {
    Layer * L = q->L[l];
    int len = L->len;
    Mempool * oldpool = L->pool;
    L->pool = mempool_new (poolsize (l, newlen), (1 << 3)*newlen);
    for (int i = Period.x*2; i < len - Period.x*2; i += 2)
      if (L->m[i]) {
# 1194 "/Users/weugene/basilisk/src/grid/tree.h"
 for (int j = Period.y*2; j < len - Period.y*2; j += 2)
   if (L->m[i][j]) {
# 1205 "/Users/weugene/basilisk/src/grid/tree.h"
 for (int k = Period.z*2; k < len - Period.z*2; k += 2)
       if (L->m[i][j][k]) {
  char * new = (char *) mempool_alloc (L->pool);
  for (int l = 0; l < 2; l++)
    for (int m = 0; m < 2; m++)
      for (int n = 0; n < 2; n++) {
        __builtin___memcpy_chk (new, L->m[i+l][j+m][k+n], oldlen, __builtin_object_size (new, 0));
        L->m[i+l][j+m][k+n] = new;
        new += newlen;
      }
       }

   }

      }
    mempool_destroy (oldpool);
  }
  apply_periodic (q);
  check_periodic (q);
}
# 1243 "/Users/weugene/basilisk/src/grid/tree.h"
static inline void no_restriction (Point point, scalar s);

static _Bool normal_neighbor (Point point, scalar * scalars, vector * vectors)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 1246 "/Users/weugene/basilisk/src/grid/tree.h"

  for (int k = 1; k <= 2; k++)
    {
# 1248 "/Users/weugene/basilisk/src/grid/tree.h"

      for (int i = -k; i <= k; i += 2*k)
 if (((point.i+i >= 0 && point.i+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0])))).pid < 0))) {
   Point neighbor = (Point) { point.i + i, point.j + 0, point.k + 0, point.level };
   int id = (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid - 1);
   if (scalars) for (scalar s = *scalars, *_i12 = scalars; ((scalar *)&s)->i >= 0; s = *++_i12)
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = _attribute[s.i].boundary[id](neighbor, point, s, ((void*)0));
   if (vectors) for (vector v = *vectors, *_i13 = vectors; ((scalar *)&v)->i >= 0; v = *++_i13) {
     scalar vn = v.x;
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)] = _attribute[vn.i].boundary[id](neighbor, point, v.x, ((void*)0));

     scalar vt = v.y;
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)] = _attribute[vt.i].boundary[id](neighbor, point, v.y, ((void*)0));


     scalar vr = v.z;
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)] = _attribute[vr.i].boundary[id](neighbor, point, v.z, ((void*)0));

   }
   return 1;
 }
# 1248 "/Users/weugene/basilisk/src/grid/tree.h"

      for (int i = -k; i <= k; i += 2*k)
 if (((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+i >= 0 && point.j+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0])))).pid < 0))) {
   Point neighbor = (Point) { point.i + 0, point.j + i, point.k + 0, point.level };
   int id = (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid - 1);
   if (scalars) for (scalar s = *scalars, *_i12 = scalars; ((scalar *)&s)->i >= 0; s = *++_i12)
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = _attribute[s.i].boundary[id](neighbor, point, s, ((void*)0));
   if (vectors) for (vector v = *vectors, *_i13 = vectors; ((scalar *)&v)->i >= 0; v = *++_i13) {
     scalar vn = v.x;
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)] = _attribute[vn.i].boundary[id](neighbor, point, v.y, ((void*)0));

     scalar vt = v.y;
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)] = _attribute[vt.i].boundary[id](neighbor, point, v.z, ((void*)0));


     scalar vr = v.z;
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)] = _attribute[vr.i].boundary[id](neighbor, point, v.x, ((void*)0));

   }
   return 1;
 }
# 1248 "/Users/weugene/basilisk/src/grid/tree.h"

      for (int i = -k; i <= k; i += 2*k)
 if (((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+i >= 0 && point.k+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i])))).pid < 0))) {
   Point neighbor = (Point) { point.i + 0, point.j + 0, point.k + i, point.level };
   int id = (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid - 1);
   if (scalars) for (scalar s = *scalars, *_i12 = scalars; ((scalar *)&s)->i >= 0; s = *++_i12)
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = _attribute[s.i].boundary[id](neighbor, point, s, ((void*)0));
   if (vectors) for (vector v = *vectors, *_i13 = vectors; ((scalar *)&v)->i >= 0; v = *++_i13) {
     scalar vn = v.x;
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)] = _attribute[vn.i].boundary[id](neighbor, point, v.z, ((void*)0));

     scalar vt = v.y;
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)] = _attribute[vt.i].boundary[id](neighbor, point, v.x, ((void*)0));


     scalar vr = v.z;
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)] = _attribute[vr.i].boundary[id](neighbor, point, v.y, ((void*)0));

   }
   return 1;
 }}
  return 0;
}

static _Bool diagonal_neighbor_2D (Point point,
      scalar * scalars, vector * vectors)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 1274 "/Users/weugene/basilisk/src/grid/tree.h"


  for (int k = 1; k <= 2; k++)

    {
# 1278 "/Users/weugene/basilisk/src/grid/tree.h"


      for (int i = -k; i <= k; i += 2*k)
 for (int j = -k; j <= k; j += 2*k)
   if ((point.i+i >= 0 && point.i+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i] && point.j+j >= 0 && point.j+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]) && ((point.i+i >= 0 && point.i+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i] && point.j+j >= 0 && point.j+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0])))).pid < 0)) &&
       (point.i+i >= 0 && point.i+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) && ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0])))).pid < 0) &&
       (point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+j >= 0 && point.j+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j] [point.k+0]) && ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j] [point.k+0])))).pid < 0)) {
     Point n = (Point) { point.i + i, point.j + j, point.k + 0, point.level },
       n1 = (Point) { point.i + i, point.j + 0, point.k + 0, point.level }, n2 = (Point) { point.i + 0, point.j + j, point.k + 0, point.level };
     int id1 = (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0])))).pid - 1), id2 = (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j] [point.k+0])))).pid - 1);
     if (scalars) for (scalar s = *scalars, *_i14 = scalars; ((scalar *)&s)->i >= 0; s = *++_i14)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = (_attribute[s.i].boundary[id1](n,n1,s,((void*)0)) +
       _attribute[s.i].boundary[id2](n,n2,s,((void*)0)) -
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]) + sizeof(Cell)))[(s.i)]);
     if (vectors) for (vector v = *vectors, *_i15 = vectors; ((scalar *)&v)->i >= 0; v = *++_i15) {
       scalar vt = v.y, vn = v.x;
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)] = (_attribute[vt.i].boundary[id1](n,n1,v.x,((void*)0)) +
         _attribute[vn.i].boundary[id2](n,n2,v.x,((void*)0)) -
         ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]) + sizeof(Cell)))[(v.x.i)]);
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)] = (_attribute[vn.i].boundary[id1](n,n1,v.y,((void*)0)) +
         _attribute[vt.i].boundary[id2](n,n2,v.y,((void*)0)) -
         ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]) + sizeof(Cell)))[(v.y.i)]);

       scalar vr = v.z;
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)] = (_attribute[vr.i].boundary[id1](n,n1,v.z,((void*)0)) +
         _attribute[vr.i].boundary[id2](n,n2,v.z,((void*)0)) -
         ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]) + sizeof(Cell)))[(v.z.i)]);

     }
     return 1;
   }
# 1278 "/Users/weugene/basilisk/src/grid/tree.h"


      for (int i = -k; i <= k; i += 2*k)
 for (int j = -k; j <= k; j += 2*k)
   if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+i >= 0 && point.j+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] && point.k+j >= 0 && point.k+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j]) && ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+i >= 0 && point.j+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] && point.k+j >= 0 && point.k+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j])))).pid < 0)) &&
       (point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+i >= 0 && point.j+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) && ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0])))).pid < 0) &&
       (point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+j >= 0 && point.k+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+j]) && ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+j])))).pid < 0)) {
     Point n = (Point) { point.i + 0, point.j + i, point.k + j, point.level },
       n1 = (Point) { point.i + 0, point.j + i, point.k + 0, point.level }, n2 = (Point) { point.i + 0, point.j + 0, point.k + j, point.level };
     int id1 = (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0])))).pid - 1), id2 = (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+j])))).pid - 1);
     if (scalars) for (scalar s = *scalars, *_i14 = scalars; ((scalar *)&s)->i >= 0; s = *++_i14)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = (_attribute[s.i].boundary[id1](n,n1,s,((void*)0)) +
       _attribute[s.i].boundary[id2](n,n2,s,((void*)0)) -
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j]) + sizeof(Cell)))[(s.i)]);
     if (vectors) for (vector v = *vectors, *_i15 = vectors; ((scalar *)&v)->i >= 0; v = *++_i15) {
       scalar vt = v.y, vn = v.x;
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)] = (_attribute[vt.i].boundary[id1](n,n1,v.y,((void*)0)) +
         _attribute[vn.i].boundary[id2](n,n2,v.y,((void*)0)) -
         ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j]) + sizeof(Cell)))[(v.y.i)]);
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)] = (_attribute[vn.i].boundary[id1](n,n1,v.z,((void*)0)) +
         _attribute[vt.i].boundary[id2](n,n2,v.z,((void*)0)) -
         ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j]) + sizeof(Cell)))[(v.z.i)]);

       scalar vr = v.z;
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)] = (_attribute[vr.i].boundary[id1](n,n1,v.x,((void*)0)) +
         _attribute[vr.i].boundary[id2](n,n2,v.x,((void*)0)) -
         ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j]) + sizeof(Cell)))[(v.x.i)]);

     }
     return 1;
   }
# 1278 "/Users/weugene/basilisk/src/grid/tree.h"


      for (int i = -k; i <= k; i += 2*k)
 for (int j = -k; j <= k; j += 2*k)
   if ((point.i+j >= 0 && point.i+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] && point.k+i >= 0 && point.k+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i]) && ((point.i+j >= 0 && point.i+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] && point.k+i >= 0 && point.k+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i])))).pid < 0)) &&
       (point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+i >= 0 && point.k+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) && ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i])))).pid < 0) &&
       (point.i+j >= 0 && point.i+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+0]) && ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+0])))).pid < 0)) {
     Point n = (Point) { point.i + j, point.j + 0, point.k + i, point.level },
       n1 = (Point) { point.i + 0, point.j + 0, point.k + i, point.level }, n2 = (Point) { point.i + j, point.j + 0, point.k + 0, point.level };
     int id1 = (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i])))).pid - 1), id2 = (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+0])))).pid - 1);
     if (scalars) for (scalar s = *scalars, *_i14 = scalars; ((scalar *)&s)->i >= 0; s = *++_i14)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = (_attribute[s.i].boundary[id1](n,n1,s,((void*)0)) +
       _attribute[s.i].boundary[id2](n,n2,s,((void*)0)) -
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i]) + sizeof(Cell)))[(s.i)]);
     if (vectors) for (vector v = *vectors, *_i15 = vectors; ((scalar *)&v)->i >= 0; v = *++_i15) {
       scalar vt = v.y, vn = v.x;
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)] = (_attribute[vt.i].boundary[id1](n,n1,v.z,((void*)0)) +
         _attribute[vn.i].boundary[id2](n,n2,v.z,((void*)0)) -
         ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i]) + sizeof(Cell)))[(v.z.i)]);
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)] = (_attribute[vn.i].boundary[id1](n,n1,v.x,((void*)0)) +
         _attribute[vt.i].boundary[id2](n,n2,v.x,((void*)0)) -
         ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i]) + sizeof(Cell)))[(v.x.i)]);

       scalar vr = v.z;
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)] = (_attribute[vr.i].boundary[id1](n,n1,v.y,((void*)0)) +
         _attribute[vr.i].boundary[id2](n,n2,v.y,((void*)0)) -
         ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i]) + sizeof(Cell)))[(v.y.i)]);

     }
     return 1;
   }}

  return 0;
}

static _Bool diagonal_neighbor_3D (Point point,
      scalar * scalars, vector * vectors)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 1315 "/Users/weugene/basilisk/src/grid/tree.h"


  for (int n = 1; n <= 2; n++)
    for (int i = -n; i <= n; i += 2*n)
      for (int j = -n; j <= n; j += 2*n)
 for (int k = -n; k <= n; k += 2*n)
   if (((point.i+i >= 0 && point.i+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i] && point.j+j >= 0 && point.j+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] && point.k+k >= 0 && point.k+k < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+k]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+k])))).pid < 0)) &&
       ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0])))).pid < 0) &&
       ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+k])))).pid < 0) &&
       ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j] [point.k+k])))).pid < 0)) {
     Point
       n0 = (Point) { point.i + i, point.j + j, point.k + k, point.level },
       n1 = (Point) { point.i + i, point.j + j, point.k + 0, point.level },
       n2 = (Point) { point.i + i, point.j + 0, point.k + k, point.level },
       n3 = (Point) { point.i + 0, point.j + j, point.k + k, point.level };
     int
       id1 = (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0])))).pid - 1),
       id2 = (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+k])))).pid - 1),
       id3 = (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j] [point.k+k])))).pid - 1);
     if (scalars) for (scalar s = *scalars, *_i16 = scalars; ((scalar *)&s)->i >= 0; s = *++_i16)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = (_attribute[s.i].boundary[id1](n0,n1,s,((void*)0)) +
       _attribute[s.i].boundary[id2](n0,n2,s,((void*)0)) +
       _attribute[s.i].boundary[id3](n0,n3,s,((void*)0)) -
       2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+k]) + sizeof(Cell)))[(s.i)]);
     if (vectors) for (vector v = *vectors, *_i17 = vectors; ((scalar *)&v)->i >= 0; v = *++_i17) {
       scalar vt = v.y, vn = v.x, vr = v.z;
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)] = (_attribute[vt.i].boundary[id1](n0,n1,v.x,((void*)0)) +
         _attribute[vt.i].boundary[id2](n0,n2,v.x,((void*)0)) +
         _attribute[vn.i].boundary[id3](n0,n3,v.x,((void*)0)) -
         2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+k]) + sizeof(Cell)))[(v.x.i)]);
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)] = (_attribute[vt.i].boundary[id1](n0,n1,v.y,((void*)0)) +
         _attribute[vn.i].boundary[id2](n0,n2,v.y,((void*)0)) +
         _attribute[vt.i].boundary[id3](n0,n3,v.y,((void*)0)) -
         2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+k]) + sizeof(Cell)))[(v.y.i)]);
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)] = (_attribute[vn.i].boundary[id1](n0,n1,v.z,((void*)0)) +
         _attribute[vr.i].boundary[id2](n0,n2,v.z,((void*)0)) +
         _attribute[vr.i].boundary[id3](n0,n3,v.z,((void*)0)) -
         2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+k]) + sizeof(Cell)))[(v.z.i)]);
     }
     return 1;
   }

  return 0;
}
# 1361 "/Users/weugene/basilisk/src/grid/tree.h"

static Point tangential_neighbor_x (Point point, _Bool * zn)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 1363 "/Users/weugene/basilisk/src/grid/tree.h"

  for (int k = 1; k <= 2; k++)
    for (int j = -k; j <= k; j += 2*k) {
      if (((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+j >= 0 && point.j+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j] [point.k+0]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j] [point.k+0])))).pid < 0)) || ((point.i+-1 >= 0 && point.i+-1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+-1] && point.j+j >= 0 && point.j+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+j] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+j] [point.k+0]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+j] [point.k+0])))).pid < 0))) {
 *zn = 0;
 return (Point) { point.i + 0, point.j + j, point.k + 0, point.level };
      }


      if (((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+j >= 0 && point.k+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+j]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+j])))).pid < 0)) || ((point.i+-1 >= 0 && point.i+-1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+-1] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] && point.k+j >= 0 && point.k+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+j]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+j])))).pid < 0))) {
 *zn = 1;
 return (Point) { point.i + 0, point.j + 0, point.k + j, point.level };
      }

    }
  return (Point){.level = -1};
}
# 1361 "/Users/weugene/basilisk/src/grid/tree.h"

static Point tangential_neighbor_y (Point point, _Bool * zn)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 1363 "/Users/weugene/basilisk/src/grid/tree.h"

  for (int k = 1; k <= 2; k++)
    for (int j = -k; j <= k; j += 2*k) {
      if (((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+j >= 0 && point.k+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+j]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+j])))).pid < 0)) || ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+-1 >= 0 && point.j+-1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] && point.k+j >= 0 && point.k+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+j]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+j])))).pid < 0))) {
 *zn = 0;
 return (Point) { point.i + 0, point.j + 0, point.k + j, point.level };
      }


      if (((point.i+j >= 0 && point.i+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+0]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+0])))).pid < 0)) || ((point.i+j >= 0 && point.i+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j] && point.j+-1 >= 0 && point.j+-1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j][point.j+-1] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j][point.j+-1] [point.k+0]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+-1] [point.k+0])))).pid < 0))) {
 *zn = 1;
 return (Point) { point.i + j, point.j + 0, point.k + 0, point.level };
      }

    }
  return (Point){.level = -1};
}
# 1361 "/Users/weugene/basilisk/src/grid/tree.h"

static Point tangential_neighbor_z (Point point, _Bool * zn)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 1363 "/Users/weugene/basilisk/src/grid/tree.h"

  for (int k = 1; k <= 2; k++)
    for (int j = -k; j <= k; j += 2*k) {
      if (((point.i+j >= 0 && point.i+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+0]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+0])))).pid < 0)) || ((point.i+j >= 0 && point.i+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] && point.k+-1 >= 0 && point.k+-1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+-1]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+-1])))).pid < 0))) {
 *zn = 0;
 return (Point) { point.i + j, point.j + 0, point.k + 0, point.level };
      }


      if (((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+j >= 0 && point.j+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j] [point.k+0]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j] [point.k+0])))).pid < 0)) || ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+j >= 0 && point.j+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j] && point.k+-1 >= 0 && point.k+-1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j] [point.k+-1]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j] [point.k+-1])))).pid < 0))) {
 *zn = 1;
 return (Point) { point.i + 0, point.j + j, point.k + 0, point.level };
      }

    }
  return (Point){.level = -1};
}


static inline _Bool is_boundary_point (Point point) { int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 1382 "/Users/weugene/basilisk/src/grid/tree.h"

  return ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid < 0);
}

static void box_boundary_level (const Boundary * b, scalar * list, int l)
{
                       ;
  scalar * scalars = ((void*)0);
  vector * vectors = ((void*)0), * faces = ((void*)0);
  if (list) for (scalar s = *list, *_i18 = list; ((scalar *)&s)->i >= 0; s = *++_i18)
    if (!((s).i >= 65536) && _attribute[s.i].refine != no_restriction) {
      if (_attribute[s.i].v.x.i == s.i) {
 if (_attribute[s.i].face)
   faces = vectors_add (faces, _attribute[s.i].v);
 else
   vectors = vectors_add (vectors, _attribute[s.i].v);
      }
      else if (_attribute[s.i].v.x.i < 0 && _attribute[s.i].boundary[0])
 scalars = list_add (scalars, s);
    }

   { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _boundary = ((Tree *)grid)->boundary[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = l; int _k; for (_k = 0; _k < _boundary.n; _k++) { point.i = _boundary.p[_k].i; point.j = _boundary.p[_k].j; point.k = _boundary.p[_k].k; ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 1403 "/Users/weugene/basilisk/src/grid/tree.h"
 {
    if (!normal_neighbor (point, scalars, vectors) &&
 !diagonal_neighbor_2D (point, scalars, vectors) &&
 !diagonal_neighbor_3D (point, scalars, vectors)) {

      if (scalars) for (scalar s = *scalars, *_i19 = scalars; ((scalar *)&s)->i >= 0; s = *++_i19)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = undefined;
      if (vectors) for (vector v = *vectors, *_i20 = vectors; ((scalar *)&v)->i >= 0; v = *++_i20)
 {
# 1411 "/Users/weugene/basilisk/src/grid/tree.h"

   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)] = undefined;
# 1411 "/Users/weugene/basilisk/src/grid/tree.h"

   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)] = undefined;
# 1411 "/Users/weugene/basilisk/src/grid/tree.h"

   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)] = undefined;}
    }
    if (faces) {
      int id = (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid - 1);
      {
# 1416 "/Users/weugene/basilisk/src/grid/tree.h"

 for (int i = -1; i <= 1; i += 2) {

   if (((point.i+i >= 0 && point.i+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0])))).pid < 0))) {
     Point neighbor = (Point) { point.i + i, point.j + 0, point.k + 0, point.level };
     if (faces) for (vector v = *faces, *_i21 = faces; ((scalar *)&v)->i >= 0; v = *++_i21) {
       scalar vn = v.x;
       if (_attribute[vn.i].boundary[id])
  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(i + 1)/2][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)] = _attribute[vn.i].boundary[id](neighbor, point, v.x, ((void*)0));
     }
   }

   else if (i == -1) {

     _Bool zn;
     Point neighbor = tangential_neighbor_x (point, &zn);
     if (neighbor.level >= 0) {
       int id = is_boundary_point (neighbor) ?
  (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0])))).pid - 1) : (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid - 1);
       if (faces) for (vector v = *faces, *_i22 = faces; ((scalar *)&v)->i >= 0; v = *++_i22) {



  scalar vt = zn ? v.y : v.z;

  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)] = _attribute[vt.i].boundary[id](neighbor, point, v.x, ((void*)0));
       }
     }
     else

       if (faces) for (vector v = *faces, *_i23 = faces; ((scalar *)&v)->i >= 0; v = *++_i23)
  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)] = 0.;
   }

 }
# 1416 "/Users/weugene/basilisk/src/grid/tree.h"

 for (int i = -1; i <= 1; i += 2) {

   if (((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+i >= 0 && point.j+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0])))).pid < 0))) {
     Point neighbor = (Point) { point.i + 0, point.j + i, point.k + 0, point.level };
     if (faces) for (vector v = *faces, *_i21 = faces; ((scalar *)&v)->i >= 0; v = *++_i21) {
       scalar vn = v.x;
       if (_attribute[vn.i].boundary[id])
  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+(i + 1)/2] [point.k+0]) + sizeof(Cell)))[(v.y.i)] = _attribute[vn.i].boundary[id](neighbor, point, v.y, ((void*)0));
     }
   }

   else if (i == -1) {

     _Bool zn;
     Point neighbor = tangential_neighbor_y (point, &zn);
     if (neighbor.level >= 0) {
       int id = is_boundary_point (neighbor) ?
  (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0])))).pid - 1) : (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid - 1);
       if (faces) for (vector v = *faces, *_i22 = faces; ((scalar *)&v)->i >= 0; v = *++_i22) {



  scalar vt = zn ? v.y : v.z;

  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)] = _attribute[vt.i].boundary[id](neighbor, point, v.y, ((void*)0));
       }
     }
     else

       if (faces) for (vector v = *faces, *_i23 = faces; ((scalar *)&v)->i >= 0; v = *++_i23)
  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)] = 0.;
   }

 }
# 1416 "/Users/weugene/basilisk/src/grid/tree.h"

 for (int i = -1; i <= 1; i += 2) {

   if (((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+i >= 0 && point.k+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i])))).pid < 0))) {
     Point neighbor = (Point) { point.i + 0, point.j + 0, point.k + i, point.level };
     if (faces) for (vector v = *faces, *_i21 = faces; ((scalar *)&v)->i >= 0; v = *++_i21) {
       scalar vn = v.x;
       if (_attribute[vn.i].boundary[id])
  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+(i + 1)/2]) + sizeof(Cell)))[(v.z.i)] = _attribute[vn.i].boundary[id](neighbor, point, v.z, ((void*)0));
     }
   }

   else if (i == -1) {

     _Bool zn;
     Point neighbor = tangential_neighbor_z (point, &zn);
     if (neighbor.level >= 0) {
       int id = is_boundary_point (neighbor) ?
  (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1])))).pid - 1) : (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid - 1);
       if (faces) for (vector v = *faces, *_i22 = faces; ((scalar *)&v)->i >= 0; v = *++_i22) {



  scalar vt = zn ? v.y : v.z;

  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)] = _attribute[vt.i].boundary[id](neighbor, point, v.z, ((void*)0));
       }
     }
     else

       if (faces) for (vector v = *faces, *_i23 = faces; ((scalar *)&v)->i >= 0; v = *++_i23)
  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)] = 0.;
   }

 }}
    }
  } } } } }; }}; }

  free(scalars);
  free(vectors);
  free(faces);
                      ;
}
# 1467 "/Users/weugene/basilisk/src/grid/tree.h"
static double masked_average (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 1468 "/Users/weugene/basilisk/src/grid/tree.h"

  double sum = 0., n = 0.;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    if (!((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid < 0) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] != ((double)1e30))
      sum += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)], n++; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  return n ? sum/n : ((double)1e30);
}
# 1476 "/Users/weugene/basilisk/src/grid/tree.h"

static double masked_average_x (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 1478 "/Users/weugene/basilisk/src/grid/tree.h"

  double sum = 0., n = 0.;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    if (child.x < 0 && (!((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid < 0) || !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0])))).pid < 0)) &&
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] != ((double)1e30))
      sum += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)], n++; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  return n ? sum/n : ((double)1e30);
}
# 1476 "/Users/weugene/basilisk/src/grid/tree.h"

static double masked_average_y (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 1478 "/Users/weugene/basilisk/src/grid/tree.h"

  double sum = 0., n = 0.;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    if (child.y < 0 && (!((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid < 0) || !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0])))).pid < 0)) &&
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.i)] != ((double)1e30))
      sum += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.i)], n++; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  return n ? sum/n : ((double)1e30);
}
# 1476 "/Users/weugene/basilisk/src/grid/tree.h"

static double masked_average_z (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 1478 "/Users/weugene/basilisk/src/grid/tree.h"

  double sum = 0., n = 0.;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    if (child.z < 0 && (!((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid < 0) || !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1])))).pid < 0)) &&
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(s.i)] != ((double)1e30))
      sum += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(s.i)], n++; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  return n ? sum/n : ((double)1e30);
}

static void masked_boundary_restriction (const Boundary * b,
      scalar * list, int l)
{
  scalar * scalars = ((void*)0);
  vector * faces = ((void*)0);
  if (list) for (scalar s = *list, *_i24 = list; ((scalar *)&s)->i >= 0; s = *++_i24)
    if (!((s).i >= 65536) && _attribute[s.i].refine != no_restriction) {
      if (_attribute[s.i].v.x.i == s.i && _attribute[s.i].face)
 faces = vectors_add (faces, _attribute[s.i].v);
      else
 scalars = list_add (scalars, s);
    }

   { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _cache = ((Tree *)grid)->restriction[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = l; int _k; for (_k = 0; _k < _cache.n; _k++) { point.i = _cache.p[_k].i; point.j = _cache.p[_k].j; point.k = _cache.p[_k].k; ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 1500 "/Users/weugene/basilisk/src/grid/tree.h"
 {
    if (scalars) for (scalar s = *scalars, *_i25 = scalars; ((scalar *)&s)->i >= 0; s = *++_i25)
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = masked_average (parent, s);
    if (faces) for (vector v = *faces, *_i26 = faces; ((scalar *)&v)->i >= 0; v = *++_i26)
      {
# 1504 "/Users/weugene/basilisk/src/grid/tree.h"
 {
 double average = masked_average_x (parent, v.x);
 if (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0])))).pid < 0))
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)] = average;
 if (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0])))).pid < 0))
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)] = average;
      }
# 1504 "/Users/weugene/basilisk/src/grid/tree.h"
 {
 double average = masked_average_y (parent, v.y);
 if (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0])))).pid < 0))
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)] = average;
 if (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0])))).pid < 0))
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(v.y.i)] = average;
      }
# 1504 "/Users/weugene/basilisk/src/grid/tree.h"
 {
 double average = masked_average_z (parent, v.z);
 if (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1])))).pid < 0))
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)] = average;
 if (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1])))).pid < 0))
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(v.z.i)] = average;
      }}
  } } } } }; }}; }

  free(scalars);
  free(faces);
}
# 1540 "/Users/weugene/basilisk/src/grid/tree.h"
static void free_cache (CacheLevel * c)
{
  for (int l = 0; l <= (grid->depth); l++)
    free(c[l].p);
  free(c);
}

void free_grid (void)
{
  if (!grid)
    return;
  free_boundaries();
  Tree * q = ((Tree *)grid);
  free(q->leaves.p);
  free(q->faces.p);
  free(q->vertices.p);
  free(q->refined.p);


  Layer * L = q->L[0];
# 1576 "/Users/weugene/basilisk/src/grid/tree.h"
 for (int i = Period.x*2; i < L->len - Period.x*2; i++) {
    for (int j = Period.y*2; j < L->len - Period.y*2; j++) {
      for (int k = Period.z*2; k < L->len - Period.z*2; k++)
 free(L->m[i][j][k]);
      free(L->m[i][j]);
    }
    free(L->m[i]);
  }

  for (int l = 1; l <= (grid->depth); l++) {
    Layer * L = q->L[l];
    for (int i = Period.x*2; i < L->len - Period.x*2; i++)
      if (L->m[i]) {
 for (int j = Period.y*2; j < L->len - Period.y*2; j++)
   if (L->m[i][j])
     free(L->m[i][j]);
 free(L->m[i]);
      }
  }

  for (int l = 0; l <= (grid->depth); l++)
    destroy_layer (q->L[l]);
  q->L = &(q->L[-1]);
  free(q->L);
  free_cache (q->active);
  free_cache (q->prolongation);
  free_cache (q->boundary);
  free_cache (q->restriction);
  free(q);
  grid = ((void*)0);
}

static void refine_level (int depth);


void init_grid (int n)
{ ;

  (__builtin_expect(!(sizeof(Cell) % 8 == 0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree.h", 1614, "sizeof(Cell) % 8 == 0") : (void)0);

  free_grid();
  int depth = 0;
  while (n > 1) {
    if (n % 2) {
      fprintf (__stderrp, "tree: N must be a power-of-two\n");
      exit (1);
    }
    n /= 2;
    depth++;
  }
  Tree * q = ((Tree *) calloc(1,sizeof(Tree)));
  grid = (Grid *) q;
  grid->depth = 0;


  q->L = ((Layer * *) malloc((2)*sizeof(Layer *)));

  q->L[0] = ((void*)0); q->L = &(q->L[1]);

  Layer * L = new_layer (0);
  q->L[0] = L;
# 1670 "/Users/weugene/basilisk/src/grid/tree.h"
 for (int i = Period.x*2; i < L->len - Period.x*2; i++)
    for (int j = Period.y*2; j < L->len - Period.y*2; j++) {
      layer_add_row (L, i, j);
      for (int k = Period.z*2; k < L->len - Period.z*2; k++)
 L->m[i][j][k] = (char *) calloc(1,sizeof(Cell) + datasize);
    }
  apply_periodic (q);
  (*((Cell *)(L->m[2][2][2]))).flags |= leaf;
  if (0 == 0)
    (*((Cell *)(L->m[2][2][2]))).flags |= active;
  for (int k = - 2*(1 - Period.x); k <= 2*(1 - Period.x); k++)
    for (int l = -2*(1 - Period.y); l <= 2*(1 - Period.y); l++)
      for (int n = -2*(1 - Period.z); n <= 2*(1 - Period.z); n++)
 (*((Cell *)(L->m[2 +k][2 +l][2 +n]))).pid = (k > 0 ? -1 - right :
       k < 0 ? -1 - left :
       l > 0 ? -1 - top :
       l < 0 ? -1 - bottom :
       n > 0 ? -1 - front :
       n < 0 ? -1 - back :
       0);
  (*((Cell *)(L->m[2][2][2]))).pid = 0;

  q->active = ((CacheLevel *) calloc(1,sizeof(CacheLevel)));
  q->prolongation = ((CacheLevel *) calloc(1,sizeof(CacheLevel)));
  q->boundary = ((CacheLevel *) calloc(1,sizeof(CacheLevel)));
  q->restriction = ((CacheLevel *) calloc(1,sizeof(CacheLevel)));
  q->dirty = 1;
  N = 1 << depth;





  Boundary * b = ((Boundary *) calloc(1,sizeof(Boundary)));
  b->level = box_boundary_level;
  b->restriction = masked_boundary_restriction;
  add_boundary (b);
  refine_level (depth);
  reset (all, 0.);
  { if (((Tree *)grid)->dirty) update_cache_f(); };
                                                                        ; }
# 1746 "/Users/weugene/basilisk/src/grid/tree.h"
struct _locate { double x, y, z; };

Point locate (struct _locate p)
{
  for (int l = (grid->depth); l >= 0; l--) {
    Point point = {0}; int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 1751 "/Users/weugene/basilisk/src/grid/tree.h"

    point.level = l;
    int n = 1 << point.level;
    point.i = (p.x - X0)/L0*n + 2;

    point.j = (p.y - Y0)/L0*n + 2;


    point.k = (p.z - Z0)/L0*n + 2;

    if (point.i >= 0 && point.i < n + 2*2

 && point.j >= 0 && point.j < n + 2*2


 && point.k >= 0 && point.k < n + 2*2

 ) {
      if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf))
 return point;
    }
    else
      break;
  }
  Point point = {0}; int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 1775 "/Users/weugene/basilisk/src/grid/tree.h"

  point.level = -1;
  return point;
}



_Bool tree_is_full()
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
  return (grid->tn == 1L << grid->maxdepth*3);
}
# 1 "./grid/tree-common.h"
# 1 "/Users/weugene/basilisk/src/grid/tree-common.h"
# 1 "./grid/multigrid-common.h"
# 1 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
# 1 "./grid/cartesian-common.h"
# 1 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
# 1 "./grid/events.h"
# 1 "/Users/weugene/basilisk/src/grid/events.h"







static void event_error (Event * ev, const char * s)
{
  fprintf (__stderrp, "%s:%d: error: %s\n", ev->file, ev->line, s);
  exit (1);
}

static void init_event (Event * ev)
{
  if (ev->arrayi || ev->arrayt) {
    ev->i = ev->t = -1;
    if (ev->arrayi)
      ev->i = ev->arrayi[0];
    else
      ev->t = ev->arrayt[0];
    ev->a = 1;
    ev->expr[1] = ((void*)0);
  }
  else {
    if (ev->nexpr > 0) {
      Expr init = ((void*)0), cond = ((void*)0), inc = ((void*)0);
      for (int j = 0; j < ev->nexpr; j++) {
 int i = -123456; double t = i;
 (* ev->expr[j]) (&i, &t, ev);
 if (i == -123456 && t == -123456) {

   if (cond)
     event_error (ev, "events can only use a single condition");
   cond = ev->expr[j];
 }
 else {

   int i1 = i; double t1 = t;
   (* ev->expr[j]) (&i1, &t1, ev);
   if (i1 == i && t1 == t) {


     if (init)
       event_error (ev, "events can only use a single initialisation");
     init = ev->expr[j];
   }
   else {

     if (inc)
       event_error (ev, "events can only use a single increment");
     inc = ev->expr[j];
   }
 }
      }
      ev->expr[0] = init;
      ev->expr[1] = cond;
      ev->expr[2] = inc;
      ev->nexpr = 0;
    }
    ev->i = ev->t = -1;
    if (ev->expr[0]) {
      (* ev->expr[0]) (&ev->i, &ev->t, ev);
      if (ev->i == 1234567890 || ev->t == 1234567890) {
 ev->i = 1234567890; ev->t = -1;
      }
    }
    else if (ev->expr[2]) {
      (* ev->expr[2]) (&ev->i, &ev->t, ev);
      if (ev->i != -1)
 ev->i = 0;
      if (ev->t != -1)
 ev->t = 0;
    }
  }
}

enum { event_done, event_alive, event_stop };

static int event_finished (Event * ev)
{
  ev->t = ev->i = -1;
  return event_done;
}

void event_register (Event event) {
  (__builtin_expect(!(Events), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/events.h", 87, "Events") : (void)0);
  (__builtin_expect(!(!event.last), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/events.h", 88, "!event.last") : (void)0);
  int n = 0, parent = -1;
  for (Event * ev = Events; !ev->last; ev++) {
    if (!strcmp (event.name, ev->name)) {
      (__builtin_expect(!(parent < 0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/events.h", 92, "parent < 0") : (void)0);
      parent = n;
    }
    n++;
  }
  if (parent < 0) {
    Events = (Event *) realloc(Events,(n + 2)*sizeof(Event));
    Events[n] = event;
    Events[n].next = ((void*)0);
    Events[n + 1].last = 1;
    init_event (&Events[n]);
  }
  else {
    Event * ev = ((Event *) calloc(1,sizeof(Event)));
    *ev = Events[parent];
    Events[parent] = event;
    Events[parent].next = ev;
    init_event (&Events[parent]);
  }
}

static int event_cond (Event * ev, int i, double t)
{
  if (!ev->expr[1])
    return 1;
  return (* ev->expr[1]) (&i, &t, ev);
}
# 131 "/Users/weugene/basilisk/src/grid/events.h"
static int event_do (Event * ev, _Bool action)
{
  if ((iter > ev->i && t > ev->t) || !event_cond (ev, iter, t))
    return event_finished (ev);
  if (iter == ev->i || fabs (t - ev->t) <= 1e-9) {
    if (action) {
      _Bool finished = 0;
      for (Event * e = ev; e; e = e->next) {



 if ((* e->action) (iter, t, e))
   finished = 1;
      }
      if (finished) {
 event_finished (ev);
 return event_stop;
      }
    }
    if (ev->arrayi) {
      ev->i = ev->arrayi[ev->a++];
      if (ev->i < 0)
 return event_finished (ev);
    }
    if (ev->arrayt) {
      ev->t = ev->arrayt[ev->a++];
      if (ev->t < 0)
 return event_finished (ev);
    }
    else if (ev->expr[2]) {
      int i0 = ev->i;
      (* ev->expr[2]) (&ev->i, &ev->t, ev);
      if (i0 == -1 && ev->i != i0)
 ev->i += iter + 1;
      if (!event_cond (ev, iter + 1, ev->t))
 return event_finished (ev);
    }
    else if (ev->expr[0] && !ev->expr[1])
      return event_finished (ev);
  }
  return event_alive;
}

static void end_event_do (_Bool action)
{




  for (Event * ev = Events; !ev->last; ev++)
    if (ev->i == 1234567890 && action)
      for (Event * e = ev; e; e = e->next) {



 e->action (iter, t, e);
      }
}

int events (_Bool action)
{





  if (iter == 0)
    for (Event * ev = Events; !ev->last; ev++)
      init_event (ev);

  int cond = 0, cond1 = 0;
  inext = 1234567890; tnext = ((double)1e30);
  for (Event * ev = Events; !ev->last && !cond; ev++)
    if (ev->i != 1234567890 &&
 (ev->expr[1] || (ev->expr[0] && !ev->expr[1] && !ev->expr[2]) || ev->arrayi || ev->arrayt))
      cond = 1;
  for (Event * ev = Events; !ev->last; ev++) {
    int status = event_do (ev, action);
    if (status == event_stop) {
      end_event_do (action);
      return 0;
    }
    if (status == event_alive && ev->i != 1234567890 &&
 (ev->expr[1] || (ev->expr[0] && !ev->expr[1] && !ev->expr[2]) || ev->arrayi || ev->arrayt))
      cond1 = 1;
    if (ev->t > t && ev->t < tnext)
      tnext = ev->t;
    if (ev->i > iter && ev->i < inext)
      inext = ev->i;
  }
  if ((!cond || cond1) && (tnext != ((double)1e30) || inext != 1234567890)) {
    inext = iter + 1;
    return 1;
  }
  end_event_do (action);
  return 0;
}

void event (const char * name)
{
  for (Event * ev = Events; !ev->last; ev++)
    if (!strcmp (ev->name, name))
      for (Event * e = ev; e; e = e->next) {



 (* e->action) (0, 0, e);
      }
}

double dtnext (double dt)
{
  if (tnext != ((double)1e30) && tnext > t) {
    unsigned int n = (tnext - t)/dt;
    (__builtin_expect(!(n/100 < 2147483647), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/events.h", 245, "n/100 < INT_MAX") : (void)0);
    if (n == 0)
      dt = tnext - t;
    else {
      double dt1 = (tnext - t)/n;
      if (dt1 > dt + 1e-9)
 dt = (tnext - t)/(n + 1);
      else if (dt1 < dt)
 dt = dt1;
      tnext = t + dt;
    }
  }
  else
    tnext = t + dt;
  return dt;
}
# 2 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

void (* debug) (Point);
# 32 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
# 1 "./grid/fpe.h"
# 1 "/Users/weugene/basilisk/src/grid/fpe.h"



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/unistd.h" 1 3 4
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/unistd.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/unistd.h" 1 3 4
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/unistd.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_posix_vdisable.h" 1 3 4
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/unistd.h" 2 3 4
# 122 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/unistd.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_seek_set.h" 1 3 4
# 123 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/unistd.h" 2 3 4
# 202 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/unistd.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_gid_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_gid_t.h" 3 4
typedef __darwin_gid_t gid_t;
# 203 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/unistd.h" 2 3 4




int faccessat(int, const char *, int, int) __attribute__((availability(macosx,introduced=10.10)));
int fchownat(int, const char *, uid_t, gid_t, int) __attribute__((availability(macosx,introduced=10.10)));
int linkat(int, const char *, int, const char *, int) __attribute__((availability(macosx,introduced=10.10)));
ssize_t readlinkat(int, const char *, char *, size_t) __attribute__((availability(macosx,introduced=10.10)));
int symlinkat(const char *, int, const char *) __attribute__((availability(macosx,introduced=10.10)));
int unlinkat(int, const char *, int) __attribute__((availability(macosx,introduced=10.10)));
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/unistd.h" 2 3 4
# 83 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/unistd.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_useconds_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_useconds_t.h" 3 4
typedef __darwin_useconds_t useconds_t;
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/unistd.h" 2 3 4
# 429 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/unistd.h" 3 4
void _exit(int) __attribute__((noreturn));
int access(const char *, int);
unsigned int
  alarm(unsigned int);
int chdir(const char *);
int chown(const char *, uid_t, gid_t);

int close(int) __asm("_" "close" );

int dup(int);
int dup2(int, int);
int execl(const char * __path, const char * __arg0, ...) __attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)));
int execle(const char * __path, const char * __arg0, ...) __attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)));
int execlp(const char * __file, const char * __arg0, ...) __attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)));
int execv(const char * __path, char * const * __argv) __attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)));
int execve(const char * __file, char * const * __argv, char * const * __envp) __attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)));
int execvp(const char * __file, char * const * __argv) __attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)));
pid_t fork(void) __attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)));
long fpathconf(int, int);
char *getcwd(char *, size_t);
gid_t getegid(void);
uid_t geteuid(void);
gid_t getgid(void);



int getgroups(int, gid_t []);

char *getlogin(void);
pid_t getpgrp(void);
pid_t getpid(void);
pid_t getppid(void);
uid_t getuid(void);
int isatty(int);
int link(const char *, const char *);
off_t lseek(int, off_t, int);
long pathconf(const char *, int);

int pause(void) __asm("_" "pause" );

int pipe(int [2]);

ssize_t read(int, void *, size_t) __asm("_" "read" );

int rmdir(const char *);
int setgid(gid_t);
int setpgid(pid_t, pid_t);
pid_t setsid(void);
int setuid(uid_t);

unsigned int
  sleep(unsigned int) __asm("_" "sleep" );

long sysconf(int);
pid_t tcgetpgrp(int);
int tcsetpgrp(int, pid_t);
char *ttyname(int);


int ttyname_r(int, char *, size_t) __asm("_" "ttyname_r" );




int unlink(const char *);

ssize_t write(int __fd, const void * __buf, size_t __nbyte) __asm("_" "write" );
# 506 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/unistd.h" 3 4
size_t confstr(int, char *, size_t) __asm("_" "confstr" );

int getopt(int, char * const [], const char *) __asm("_" "getopt" );

extern char *optarg;
extern int optind, opterr, optopt;
# 542 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/unistd.h" 3 4
char *crypt(const char *, const char *);






void encrypt(char *, int) __asm("_" "encrypt" );



int fchdir(int);
long gethostid(void);
pid_t getpgid(pid_t);
pid_t getsid(pid_t);
# 570 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/unistd.h" 3 4
int lchown(const char *, uid_t, gid_t) __asm("_" "lchown" );

int lockf(int, int, off_t) __asm("_" "lockf" );

int nice(int) __asm("_" "nice" );

ssize_t pread(int __fd, void * __buf, size_t __nbyte, off_t __offset) __asm("_" "pread" );

ssize_t pwrite(int __fd, const void * __buf, size_t __nbyte, off_t __offset) __asm("_" "pwrite" );
# 591 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/unistd.h" 3 4
pid_t setpgrp(void) __asm("_" "setpgrp" );




int setregid(gid_t, gid_t) __asm("_" "setregid" );

int setreuid(uid_t, uid_t) __asm("_" "setreuid" );

void swab(const void * restrict, void * restrict, ssize_t);
void sync(void);
int truncate(const char *, off_t);
useconds_t ualarm(useconds_t, useconds_t);
int usleep(useconds_t) __asm("_" "usleep" );
pid_t vfork(void) __attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)));


int fsync(int) __asm("_" "fsync" );

int ftruncate(int, off_t);
int getlogin_r(char *, size_t);
# 624 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/unistd.h" 3 4
int fchown(int, uid_t, gid_t);
int gethostname(char *, size_t);
ssize_t readlink(const char * restrict, char * restrict, size_t);
int setegid(gid_t);
int seteuid(uid_t);
int symlink(const char *, const char *);
# 5 "/Users/weugene/basilisk/src/grid/fpe.h" 2

static int gdb()
{
  if (last_point.level >= 0) {
    debug (last_point);
    fputc ('\n', __stderrp);
    fflush (__stderrp);
  }
  char command[80];
  __builtin___sprintf_chk (command, 0, __builtin_object_size (command, 2 > 1 ? 1 : 0), "exec xterm -e 'gdb -p %d' & xterm -e 'gnuplot plot -'", getpid());

  return system (command);
}

static void caught_abort (int sig)
{
  fprintf (__stderrp, "Caught signal %d (Aborted)\n", sig);
  gdb();
}

static void caught_fpe (int sig)
{
  fprintf (__stderrp, "Caught signal %d (Floating Point Exception)\n", sig);
  gdb();
  exit (1);
}

static void caught_segfault (int sig)
{
  fprintf (__stderrp, "Caught signal %d (Segmentation Fault)\n", sig);
  gdb();
  exit (2);
}

void catch_fpe (void)
{
  struct sigaction act;
  act.__sigaction_u.__sa_handler = caught_fpe;
  (*(&act.sa_mask) = 0, 0);
  act.sa_flags = 0;
  last_point.level = -1;
  sigaction (8, &act, ((void*)0));
  act.__sigaction_u.__sa_handler = caught_segfault;
  sigaction (11, &act, ((void*)0));
  act.__sigaction_u.__sa_handler = caught_abort;
  act.sa_flags = 0x0004;
  sigaction (6, &act, ((void*)0));
}
# 35 "/Users/weugene/basilisk/src/grid/cartesian-common.h"



static void init_block_scalar (scalar sb, const char * name, const char * ext,
          int n, int block)
{
  char bname[strlen(name) + strlen(ext) + 10];
  if (n == 0) {
    __builtin___sprintf_chk (bname, 0, __builtin_object_size (bname, 2 > 1 ? 1 : 0), "%s%s", name, ext);
    init_scalar (sb, bname);
    _attribute[sb.i].block = block;
  }
  else {
    __builtin___sprintf_chk (bname, 0, __builtin_object_size (bname, 2 > 1 ? 1 : 0), "%s%d%s", name, n, ext);
    init_scalar (sb, bname);
    _attribute[sb.i].block = - n;
  }
  all = list_append (all, sb);
}

scalar new_block_scalar (const char * name, const char * ext, int block)
{
  int nvar = datasize/sizeof(double);

  scalar s = {0};
  while (s.i < nvar) {
    int n = 0;
    scalar sb = s;
    while (sb.i < nvar && n < block && _attribute[sb.i].freed)
      n++, sb.i++;
    if (n >= block) {
      for (sb.i = s.i, n = 0; n < block; n++, sb.i++)
 init_block_scalar (sb, name, ext, n, block);
                                    ;
      return s;
    }
    s.i = sb.i + 1;
  }


  s = (scalar){nvar};
  (__builtin_expect(!(nvar + block <= 65536), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/cartesian-common.h", 76, "nvar + block <= _NVARMAX") : (void)0);
  _attribute = (_Attributes *) realloc(_attribute,(nvar + block)*sizeof(_Attributes));
  __builtin___memset_chk (&_attribute[nvar], 0, block*sizeof (_Attributes), __builtin_object_size (&_attribute[nvar], 0));
  for (int n = 0; n < block; n++, nvar++) {
    scalar sb = (scalar){nvar};
    init_block_scalar (sb, name, ext, n, block);
  }

  realloc_scalar (block*sizeof(double));
                                ;
  return s;
}

scalar new_scalar (const char * name)
{
  return new_block_scalar (name, "", 1);
}

scalar new_vertex_scalar (const char * name)
{
  return init_vertex_scalar (new_scalar (name), name);
}

static vector alloc_block_vector (const char * name, int block)
{
  vector v;
  struct { char * x, * y, * z; } ext = {".x", ".y", ".z"};
  {
# 103 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    v.x = new_block_scalar (name, ext.x, block);
# 103 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    v.y = new_block_scalar (name, ext.y, block);
# 103 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    v.z = new_block_scalar (name, ext.z, block);}
  return v;
}

vector new_vector (const char * name)
{
  vector v = alloc_block_vector (name, 1);
  init_vector (v, ((void*)0));
  return v;
}

vector new_face_vector (const char * name)
{
  vector v = alloc_block_vector (name, 1);
  init_face_vector (v, ((void*)0));
  return v;
}

vector new_block_vector (const char * name, int block)
{
  vector v = alloc_block_vector (name, block);
  for (int i = 0; i < block; i++) {
    vector vb;
    {
# 127 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      vb.x.i = v.x.i + i;
# 127 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      vb.y.i = v.y.i + i;
# 127 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      vb.z.i = v.z.i + i;}
    init_vector (vb, ((void*)0));
    {
# 130 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      _attribute[vb.x.i].block = - i;
# 130 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      _attribute[vb.y.i].block = - i;
# 130 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      _attribute[vb.z.i].block = - i;}
  }
  {
# 133 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    _attribute[v.x.i].block = block;
# 133 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    _attribute[v.y.i].block = block;
# 133 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    _attribute[v.z.i].block = block;}
  return v;
}

vector new_block_face_vector (const char * name, int block)
{
  vector v = alloc_block_vector (name, block);
  for (int i = 0; i < block; i++) {
    vector vb;
    {
# 143 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      vb.x.i = v.x.i + i;
# 143 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      vb.y.i = v.y.i + i;
# 143 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      vb.z.i = v.z.i + i;}
    init_face_vector (vb, ((void*)0));
    {
# 146 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      _attribute[vb.x.i].block = - i;
# 146 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      _attribute[vb.y.i].block = - i;
# 146 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      _attribute[vb.z.i].block = - i;}
  }
  {
# 149 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    _attribute[v.x.i].block = block;
# 149 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    _attribute[v.y.i].block = block;
# 149 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    _attribute[v.z.i].block = block;}
  return v;
}

tensor new_tensor (const char * name)
{
  char cname[strlen(name) + 3];
  struct { char * x, * y, * z; } ext = {"%s.x", "%s.y", "%s.z"};
  tensor t;
  {
# 159 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    __builtin___sprintf_chk (cname, 0, __builtin_object_size (cname, 2 > 1 ? 1 : 0), ext.x, name);
    t.x = new_vector (cname);
  }
# 159 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    __builtin___sprintf_chk (cname, 0, __builtin_object_size (cname, 2 > 1 ? 1 : 0), ext.y, name);
    t.y = new_vector (cname);
  }
# 159 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    __builtin___sprintf_chk (cname, 0, __builtin_object_size (cname, 2 > 1 ? 1 : 0), ext.z, name);
    t.z = new_vector (cname);
  }}
  init_tensor (t, ((void*)0));
  return t;
}

tensor new_symmetric_tensor (const char * name)
{
  char cname[strlen(name) + 5];
  struct { char * x, * y, * z; } ext = {"%s.x.x", "%s.y.y", "%s.z.z"};
  tensor t;
  {
# 172 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    __builtin___sprintf_chk (cname, 0, __builtin_object_size (cname, 2 > 1 ? 1 : 0), ext.x, name);
    t.x.x = new_scalar(cname);
  }
# 172 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    __builtin___sprintf_chk (cname, 0, __builtin_object_size (cname, 2 > 1 ? 1 : 0), ext.y, name);
    t.y.y = new_scalar(cname);
  }
# 172 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    __builtin___sprintf_chk (cname, 0, __builtin_object_size (cname, 2 > 1 ? 1 : 0), ext.z, name);
    t.z.z = new_scalar(cname);
  }}

    __builtin___sprintf_chk (cname, 0, __builtin_object_size (cname, 2 > 1 ? 1 : 0), "%s.x.y", name);
    t.x.y = new_scalar(cname);
    t.y.x = t.x.y;


    __builtin___sprintf_chk (cname, 0, __builtin_object_size (cname, 2 > 1 ? 1 : 0), "%s.x.z", name);
    t.x.z = new_scalar(cname);
    t.z.x = t.x.z;
    __builtin___sprintf_chk (cname, 0, __builtin_object_size (cname, 2 > 1 ? 1 : 0), "%s.y.z", name);
    t.y.z = new_scalar(cname);
    t.z.y = t.y.z;




  init_tensor (t, ((void*)0));
  return t;
}

static int nconst = 0;

void init_const_scalar (scalar s, const char * name, double val)
{
  if (s.i - 65536 >= nconst) {
    nconst = s.i - 65536 + 1;
    _constant = (double *) realloc(_constant,(nconst)*sizeof(double));
  }
  _constant[s.i - 65536] = val;
}

scalar new_const_scalar (const char * name, int i, double val)
{
  scalar s = (scalar){i + 65536};
  init_const_scalar (s, name, val);
  return s;
}

void init_const_vector (vector v, const char * name, double * val)
{
  {
# 216 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    init_const_scalar (v.x, name, *val++);
# 216 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    init_const_scalar (v.y, name, *val++);
# 216 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    init_const_scalar (v.z, name, *val++);}
}

vector new_const_vector (const char * name, int i, double * val)
{
  vector v;
  {
# 223 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    v.x.i = 65536 + i++;
# 223 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    v.y.i = 65536 + i++;
# 223 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    v.z.i = 65536 + i++;}
  init_const_vector (v, name, val);
  return v;
}

void scalar_clone (scalar a, scalar b)
{
  char * name = _attribute[a.i].name;
  double (** boundary) (Point, Point, scalar, void *) = _attribute[a.i].boundary;
  double (** boundary_homogeneous) (Point, Point, scalar, void *) =
    _attribute[a.i].boundary_homogeneous;
  (__builtin_expect(!(_attribute[b.i].block > 0 && _attribute[a.i].block == _attribute[b.i].block), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/cartesian-common.h", 235, "_attribute[b.i].block > 0 && _attribute[a.i].block == _attribute[b.i].block") : (void)0);
  _attribute[a.i] = _attribute[b.i];
  _attribute[a.i].name = name;
  _attribute[a.i].boundary = boundary;
  _attribute[a.i].boundary_homogeneous = boundary_homogeneous;
  for (int i = 0; i < nboundary; i++) {
    _attribute[a.i].boundary[i] = _attribute[b.i].boundary[i];
    _attribute[a.i].boundary_homogeneous[i] = _attribute[b.i].boundary_homogeneous[i];
  }
}

scalar * list_clone (scalar * l)
{
  scalar * list = ((void*)0);
  int nvar = datasize/sizeof(double), map[nvar];
  for (int i = 0; i < nvar; i++)
    map[i] = -1;
  if (l) for (scalar s = *l, *_i27 = l; ((scalar *)&s)->i >= 0; s = *++_i27) {
    scalar c = _attribute[s.i].block > 1 ? new_block_scalar("c", "", _attribute[s.i].block) :
      new_scalar("c");
    scalar_clone (c, s);
    map[s.i] = c.i;
    list = list_append (list, c);
  }
  if (list) for (scalar s = *list, *_i28 = list; ((scalar *)&s)->i >= 0; s = *++_i28)
    {
# 260 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      if (_attribute[s.i].v.x.i >= 0 && map[_attribute[s.i].v.x.i] >= 0)
 _attribute[s.i].v.x.i = map[_attribute[s.i].v.x.i];
# 260 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      if (_attribute[s.i].v.y.i >= 0 && map[_attribute[s.i].v.y.i] >= 0)
 _attribute[s.i].v.y.i = map[_attribute[s.i].v.y.i];
# 260 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      if (_attribute[s.i].v.z.i >= 0 && map[_attribute[s.i].v.z.i] >= 0)
 _attribute[s.i].v.z.i = map[_attribute[s.i].v.z.i];}
  return list;
}

void delete (scalar * list)
{
  if (all == ((void*)0))
    return;

  if (list) for (scalar f = *list, *_i29 = list; ((scalar *)&f)->i >= 0; f = *++_i29) {
    for (int i = 0; i < _attribute[f.i].block; i++) {
      scalar fb = {f.i + i};
      if (_attribute[f.i].delete)
 _attribute[f.i].delete (fb);
      free(_attribute[fb.i].name); _attribute[fb.i].name = ((void*)0);
      free(_attribute[fb.i].boundary); _attribute[fb.i].boundary = ((void*)0);
      free(_attribute[fb.i].boundary_homogeneous); _attribute[fb.i].boundary_homogeneous = ((void*)0);
      _attribute[fb.i].freed = 1;
    }
  }

  if (list == all) {
    all[0].i = -1;
    return;
  }

              ;
  if (list) for (scalar f = *list, *_i30 = list; ((scalar *)&f)->i >= 0; f = *++_i30) {
    if (_attribute[f.i].block > 0) {
      scalar * s = all;
      for (; s->i >= 0 && s->i != f.i; s++);
      if (s->i == f.i) {
 for (; s[_attribute[f.i].block].i >= 0; s++)
   s[0] = s[_attribute[f.i].block];
 s->i = -1;
      }
    }
  }
}

void free_solver()
{
  if (free_solver_funcs) {
    free_solver_func * a = (free_solver_func *) free_solver_funcs->p;
    for (int i = 0; i < free_solver_funcs->len/sizeof(free_solver_func); i++)
      a[i] ();
    array_free (free_solver_funcs);
  }

  delete (all);
  free(all); all = ((void*)0);
  for (Event * ev = Events; !ev->last; ev++) {
    Event * e = ev->next;
    while (e) {
      Event * next = e->next;
      free(e);
      e = next;
    }
  }

  free(Events); Events = ((void*)0);
  free(_attribute); _attribute = ((void*)0);
  free(_constant); _constant = ((void*)0);
  free_grid();
  qpclose_all();
# 336 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
}



void (* boundary_level) (scalar *, int l);
void (* boundary_flux) (vector *);


void boundary (scalar * list)
{ ;
  if (list == ((void*)0))
    { ; ; return; }
  vector * listf = ((void*)0);
  if (list) for (scalar s = *list, *_i31 = list; ((scalar *)&s)->i >= 0; s = *++_i31)
    if (!((s).i >= 65536) && _attribute[s.i].block > 0 && _attribute[s.i].face)
      listf = vectors_add (listf, _attribute[s.i].v);
  if (listf) {
    boundary_flux (listf);
    free(listf);
  }
  boundary_level (list, -1);
                                                                                  ; }

void cartesian_boundary_level (scalar * list, int l)
{
  { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list, l); };
}

void cartesian_boundary_flux (vector * list)
{

}

static double symmetry (Point point, Point neighbor, scalar s, void * data)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 370 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

  return ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)];
}

static double antisymmetry (Point point, Point neighbor, scalar s, void * data)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 375 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

  return -((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)];
}

double (* default_scalar_bc[]) (Point, Point, scalar, void *) = {
  symmetry, symmetry, symmetry, symmetry, symmetry, symmetry
};

scalar cartesian_init_scalar (scalar s, const char * name)
{

  char * pname;
  if (name) {
    free(_attribute[s.i].name);
    pname = strdup(name);
  }
  else
    pname = _attribute[s.i].name;
  free(_attribute[s.i].boundary);
  free(_attribute[s.i].boundary_homogeneous);

  _attribute[s.i] = (const _Attributes){0};
  _attribute[s.i].block = 1;
  _attribute[s.i].name = pname;

  _attribute[s.i].boundary = (double (**)(Point, Point, scalar, void *))
    malloc(nboundary*sizeof (void (*)()));
  _attribute[s.i].boundary_homogeneous = (double (**)(Point, Point, scalar, void *))
    malloc(nboundary*sizeof (void (*)()));
  for (int b = 0; b < nboundary; b++)
    _attribute[s.i].boundary[b] = _attribute[s.i].boundary_homogeneous[b] =
      b < 2*3 ? default_scalar_bc[b] : symmetry;
  _attribute[s.i].gradient = ((void*)0);
  {
# 408 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    _attribute[s.i].d.x = 0;
    _attribute[s.i].v.x.i = -1;
  }
# 408 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    _attribute[s.i].d.y = 0;
    _attribute[s.i].v.y.i = -1;
  }
# 408 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    _attribute[s.i].d.z = 0;
    _attribute[s.i].v.z.i = -1;
  }}
  _attribute[s.i].face = 0;
  return s;
}

scalar cartesian_init_vertex_scalar (scalar s, const char * name)
{
  {
# 418 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    _attribute[s.i].d.x = -1;
# 418 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    _attribute[s.i].d.y = -1;
# 418 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    _attribute[s.i].d.z = -1;}
  for (int d = 0; d < nboundary; d++)
    _attribute[s.i].boundary[d] = _attribute[s.i].boundary_homogeneous[d] = ((void*)0);
  return s;
}

double (* default_vector_bc[]) (Point, Point, scalar, void *) = {
  antisymmetry, antisymmetry,
  antisymmetry, antisymmetry,
  antisymmetry, antisymmetry
};

vector cartesian_init_vector (vector v, const char * name)
{
  struct { char * x, * y, * z; } ext = {".x", ".y", ".z"};
  {
# 434 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    if (name) {
      char cname[strlen(name) + 3];
      __builtin___sprintf_chk (cname, 0, __builtin_object_size (cname, 2 > 1 ? 1 : 0), "%s%s", name, ext.x);
      init_scalar (v.x, cname);
    }
    else
      init_scalar (v.x, ((void*)0));
    _attribute[v.x.i].v = v;
  }
# 434 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    if (name) {
      char cname[strlen(name) + 3];
      __builtin___sprintf_chk (cname, 0, __builtin_object_size (cname, 2 > 1 ? 1 : 0), "%s%s", name, ext.y);
      init_scalar (v.y, cname);
    }
    else
      init_scalar (v.y, ((void*)0));
    _attribute[v.y.i].v = v;
  }
# 434 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    if (name) {
      char cname[strlen(name) + 3];
      __builtin___sprintf_chk (cname, 0, __builtin_object_size (cname, 2 > 1 ? 1 : 0), "%s%s", name, ext.z);
      init_scalar (v.z, cname);
    }
    else
      init_scalar (v.z, ((void*)0));
    _attribute[v.z.i].v = v;
  }}

  for (int d = 0; d < nboundary; d++)
    _attribute[v.x.i].boundary[d] = _attribute[v.x.i].boundary_homogeneous[d] =
      d < 2*3 ? default_vector_bc[d] : antisymmetry;
  return v;
}

vector cartesian_init_face_vector (vector v, const char * name)
{
  v = cartesian_init_vector (v, name);
  {
# 454 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    _attribute[v.x.i].d.x = -1;
    _attribute[v.x.i].face = 1;
  }
# 454 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    _attribute[v.y.i].d.y = -1;
    _attribute[v.y.i].face = 1;
  }
# 454 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    _attribute[v.z.i].d.z = -1;
    _attribute[v.z.i].face = 1;
  }}
  for (int d = 0; d < nboundary; d++)
    _attribute[v.x.i].boundary[d] = _attribute[v.x.i].boundary_homogeneous[d] = ((void*)0);
  return v;
}

tensor cartesian_init_tensor (tensor t, const char * name)
{
  struct { char * x, * y, * z; } ext = {".x", ".y", ".z"};
  {
# 466 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    if (name) {
      char cname[strlen(name) + 3];
      __builtin___sprintf_chk (cname, 0, __builtin_object_size (cname, 2 > 1 ? 1 : 0), "%s%s", name, ext.x);
      init_vector (t.x, cname);
    }
    else
      init_vector (t.x, ((void*)0));
  }
# 466 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    if (name) {
      char cname[strlen(name) + 3];
      __builtin___sprintf_chk (cname, 0, __builtin_object_size (cname, 2 > 1 ? 1 : 0), "%s%s", name, ext.y);
      init_vector (t.y, cname);
    }
    else
      init_vector (t.y, ((void*)0));
  }
# 466 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    if (name) {
      char cname[strlen(name) + 3];
      __builtin___sprintf_chk (cname, 0, __builtin_object_size (cname, 2 > 1 ? 1 : 0), "%s%s", name, ext.z);
      init_vector (t.z, cname);
    }
    else
      init_vector (t.z, ((void*)0));
  }}
# 490 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/cartesian-common.h", 490, "false") : (void)0);

  return t;
}

struct OutputCells {
  FILE * fp;
  coord c;
  double size;
};

void output_cells (struct OutputCells p)
{
  if (!p.fp) p.fp = __stdoutp;
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 504 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    _Bool inside = 1;
    coord o = {x,y,z};
    {
# 507 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      if (inside && p.size > 0. &&
   (o.x > p.c.x + p.size || o.x < p.c.x - p.size))
 inside = 0;
# 507 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      if (inside && p.size > 0. &&
   (o.y > p.c.y + p.size || o.y < p.c.y - p.size))
 inside = 0;
# 507 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      if (inside && p.size > 0. &&
   (o.z > p.c.z + p.size || o.z < p.c.z - p.size))
 inside = 0;}
    if (inside) {
      Delta /= 2.;
# 523 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 for (int i = -1; i <= 1; i += 2) {
 fprintf (p.fp, "%g %g %g\n%g %g %g\n%g %g %g\n%g %g %g\n%g %g %g\n\n",
   x - Delta, y - Delta, z + i*Delta,
   x - Delta, y + Delta, z + i*Delta,
   x + Delta, y + Delta, z + i*Delta,
   x + Delta, y - Delta, z + i*Delta,
   x - Delta, y - Delta, z + i*Delta);
 for (int j = -1; j <= 1; j += 2)
   fprintf (p.fp, "%g %g %g\n%g %g %g\n\n",
     x + i*Delta, y + j*Delta, z - Delta,
     x + i*Delta, y + j*Delta, z + Delta);
      }

    }
  } } } } }; }
  fflush (p.fp);
}
# 548 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
static char * replace_ (const char * vname)
{
  char * name = strdup(vname), * c = name;
  while (*c != '\0') {
    if (*c == '.')
      *c = '_';
    c++;
  }
  return name;
}

static void debug_plot (FILE * fp, const char * name, const char * cells,
   const char * stencil)
{
  char * vname = replace_ (name);
  fprintf (fp,
    "  load 'debug.plot'\n"
    "  v=%s\n"







    "  splot '%s' w l lc 0, "
    "'%s' u 1+4*v:2+4*v:3+4*v:4+4*v w labels tc lt 1"
           " title columnhead(4+4*v)",

    vname, cells, stencil);
  free(vname);
}

void cartesian_debug (Point point)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 582 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

  char name[80] = "cells";
  if (0 > 0)
    __builtin___sprintf_chk (name, 0, __builtin_object_size (name, 2 > 1 ? 1 : 0), "cells-%d", 0);
  FILE * fp = fopen (name, "w");
  output_cells ((struct OutputCells){fp, (coord){x,y,z}, 4.*Delta});
  fclose (fp);

  char stencil[80] = "stencil";
  if (0 > 0)
    __builtin___sprintf_chk (stencil, 0, __builtin_object_size (stencil, 2 > 1 ? 1 : 0), "stencil-%d", 0);
  fp = fopen (stencil, "w");
  if (all) for (scalar v = *all, *_i32 = all; ((scalar *)&v)->i >= 0; v = *++_i32)





    fprintf (fp, "x y z %s ", _attribute[v.i].name);

  fputc ('\n', fp);
# 629 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 for (int k = -2; k <= 2; k++)
      for (int l = -2; l <= 2; l++)
 for (int m = -2; m <= 2; m++) {
   if (all) for (scalar v = *all, *_i33 = all; ((scalar *)&v)->i >= 0; v = *++_i33) {
     fprintf (fp, "%g %g %g ",
       x + k*Delta + _attribute[v.i].d.x*Delta/2.,
       y + l*Delta + _attribute[v.i].d.y*Delta/2.,
       z + m*Delta + _attribute[v.i].d.z*Delta/2.);
     if ((point.i+k >= 0 && point.i+k < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+k] && point.j+l >= 0 && point.j+l < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+k][point.j+l] && point.k+m >= 0 && point.k+m < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+k][point.j+l] [point.k+m]))
       fprintf (fp, "%g ", ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+k][point.j+l] [point.k+m]) + sizeof(Cell)))[(v.i)]);
     else
       fputs ("n/a ", fp);
   }
   fputc ('\n', fp);
 }

  fclose (fp);

  fp = fopen ("debug.plot", "w");
  fprintf (fp,
    "set term x11\n"
    "set size ratio -1\n"
    "set key outside\n");
  if (all) for (scalar s = *all, *_i34 = all; ((scalar *)&s)->i >= 0; s = *++_i34) {
    char * name = replace_ (_attribute[s.i].name);
    fprintf (fp, "%s = %d\n", name, s.i);
    free(name);
  }
  fclose (fp);

  fprintf (__stderrp, "Last point stencils can be displayed using (in gnuplot)\n");
  debug_plot (__stderrp, _attribute[0].name, name, stencil);
  fflush (__stderrp);

  fp = fopen ("plot", "w");
  debug_plot (fp, _attribute[0].name, name, stencil);
  fclose (fp);
}

void cartesian_methods()
{
  init_scalar = cartesian_init_scalar;
  init_vertex_scalar = cartesian_init_vertex_scalar;
  init_vector = cartesian_init_vector;
  init_tensor = cartesian_init_tensor;
  init_face_vector = cartesian_init_face_vector;
  boundary_level = cartesian_boundary_level;
  boundary_flux = cartesian_boundary_flux;
  debug = cartesian_debug;
}

struct _interpolate {
  scalar v;
  double x, y, z;
};

static double interpolate_linear (Point point, struct _interpolate p)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 686 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

  scalar v = p.v;
# 703 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 x = (p.x - x)/Delta - _attribute[v.i].d.x/2.;
  y = (p.y - y)/Delta - _attribute[v.i].d.y/2.;
  z = (p.z - z)/Delta - _attribute[v.i].d.z/2.;
  int i = ((x) > 0 ? 1 : -1), j = ((y) > 0 ? 1 : -1), k = ((z) > 0 ? 1 : -1);
  x = fabs(x); y = fabs(y); z = fabs(z);

  return (((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.i)]*(1. - x) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.i)]*x)*(1. - y) +
    (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j] [point.k+0]) + sizeof(Cell)))[(v.i)]*(1. - x) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]) + sizeof(Cell)))[(v.i)]*x)*y)*(1. - z) +
   ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+k]) + sizeof(Cell)))[(v.i)]*(1. - x) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+k]) + sizeof(Cell)))[(v.i)]*x)*(1. - y) +
    (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j] [point.k+k]) + sizeof(Cell)))[(v.i)]*(1. - x) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+k]) + sizeof(Cell)))[(v.i)]*x)*y)*z);

}


double interpolate (struct _interpolate p)
{ ;
  Point point = locate ((struct _locate){p.x, p.y, p.z}); int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 719 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

  if (point.level < 0)
    { double _ret = ((double)1e30); ; return _ret; }
  { double _ret = interpolate_linear (point, p); ; return _ret; }
                                                                                     ; }


void interpolate_array (scalar * list, coord * a, int n, double * v, _Bool linear)
{ ;
  int j = 0;
  for (int i = 0; i < n; i++) {
    Point point = locate ((struct _locate){a[i].x, a[i].y, a[i].z}); int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 730 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    if (point.level >= 0) {
      if (list) for (scalar s = *list, *_i35 = list; ((scalar *)&s)->i >= 0; s = *++_i35)
 v[j++] = !linear ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] :
   interpolate_linear (point,
         (struct _interpolate){s, a[i].x, a[i].y, a[i].z});
    }
    else
      if (list) for (scalar s = *list, *_i36 = list; ((scalar *)&s)->i >= 0; s = *++_i36)
 v[j++] = ((double)1e30);
  }
# 749 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                                                                           ; }



typedef int bid;

bid new_bid()
{
  int b = nboundary++;
  if (all) for (scalar s = *all, *_i37 = all; ((scalar *)&s)->i >= 0; s = *++_i37) {
    _attribute[s.i].boundary = (double (**)(Point, Point, scalar, void *))
      realloc(_attribute[s.i].boundary,nboundary*sizeof (void (*)()));
    _attribute[s.i].boundary_homogeneous = (double (**)(Point, Point, scalar, void *))
      realloc(_attribute[s.i].boundary_homogeneous,nboundary*sizeof (void (*)()));
  }
  if (all) for (scalar s = *all, *_i38 = all; ((scalar *)&s)->i >= 0; s = *++_i38) {
    if (_attribute[s.i].v.x.i < 0)
      _attribute[s.i].boundary[b] = _attribute[s.i].boundary_homogeneous[b] = symmetry;
    else if (_attribute[s.i].v.x.i == s.i) {
      vector v = _attribute[s.i].v;
      {
# 769 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

 _attribute[v.y.i].boundary[b] = _attribute[v.y.i].boundary_homogeneous[b] = symmetry;
# 769 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

 _attribute[v.z.i].boundary[b] = _attribute[v.z.i].boundary_homogeneous[b] = symmetry;
# 769 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

 _attribute[v.x.i].boundary[b] = _attribute[v.x.i].boundary_homogeneous[b] = symmetry;}
      _attribute[v.x.i].boundary[b] = _attribute[v.x.i].boundary_homogeneous[b] =
 _attribute[v.x.i].face ? ((void*)0) : antisymmetry;
    }
  }
  return b;
}



static double periodic_bc (Point point, Point neighbor, scalar s, void * data)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 781 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

  return ((double)1e30);
}

static void periodic_boundary (int d)
{

  if (all) for (scalar s = *all, *_i39 = all; ((scalar *)&s)->i >= 0; s = *++_i39)
    _attribute[s.i].boundary[d] = _attribute[s.i].boundary_homogeneous[d] = periodic_bc;

  if (all) for (scalar s = *all, *_i40 = all; ((scalar *)&s)->i >= 0; s = *++_i40)
    if (_attribute[s.i].face) {
      vector v = _attribute[s.i].v;
      _attribute[v.x.i].boundary[d] = _attribute[v.x.i].boundary_homogeneous[d] = ((void*)0);
    }

  default_scalar_bc[d] = periodic_bc;
  default_vector_bc[d] = periodic_bc;
}

void periodic (int dir)
{





    (__builtin_expect(!(dir <= back), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/cartesian-common.h", 808, "dir <= back") : (void)0);


  int c = dir/2;
  periodic_boundary (2*c);
  periodic_boundary (2*c + 1);
  (&Period.x)[c] = 1;
}
# 4 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
# 24 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
void (* restriction) (scalar *);

static inline void restriction_average (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 27 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  double sum = 0.;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    sum += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = sum/(1 << 3);
}

static inline void restriction_volume_average (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 35 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

if (!((cm).i >= 65536)) {
# 35 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  double sum = 0.;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    sum += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = sum/(1 << 3)/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)] + 1e-30);
 }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 35 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  double sum = 0.;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    sum += _const_cm*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = sum/(1 << 3)/(_const_cm + 1e-30);
 }}

static inline void face_average (Point point, vector v)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 43 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  {
# 44 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
 {







      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0][2*point.k-2 +0]) + sizeof(Cell)))[(v.x.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +1][2*point.k-2 +0]) + sizeof(Cell)))[(v.x.i)] +
        ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0][2*point.k-2 +1]) + sizeof(Cell)))[(v.x.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +1][2*point.k-2 +1]) + sizeof(Cell)))[(v.x.i)])/4.;
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] [2*point.j-2 +0][2*point.k-2 +0]) + sizeof(Cell)))[(v.x.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] [2*point.j-2 +1][2*point.k-2 +0]) + sizeof(Cell)))[(v.x.i)] +
  ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] [2*point.j-2 +0][2*point.k-2 +1]) + sizeof(Cell)))[(v.x.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] [2*point.j-2 +1][2*point.k-2 +1]) + sizeof(Cell)))[(v.x.i)])/4.;

  }
# 44 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
 {







      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0][2*point.k-2 +0]) + sizeof(Cell)))[(v.y.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0][2*point.k-2 +1]) + sizeof(Cell)))[(v.y.i)] +
        ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +0][2*point.k-2 +0]) + sizeof(Cell)))[(v.y.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +0][2*point.k-2 +1]) + sizeof(Cell)))[(v.y.i)])/4.;
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(v.y.i)] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +2][2*point.k-2 +0]) + sizeof(Cell)))[(v.y.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +2][2*point.k-2 +1]) + sizeof(Cell)))[(v.y.i)] +
  ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +2][2*point.k-2 +0]) + sizeof(Cell)))[(v.y.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +2][2*point.k-2 +1]) + sizeof(Cell)))[(v.y.i)])/4.;

  }
# 44 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
 {







      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0][2*point.k-2 +0]) + sizeof(Cell)))[(v.z.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +0][2*point.k-2 +0]) + sizeof(Cell)))[(v.z.i)] +
        ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +1][2*point.k-2 +0]) + sizeof(Cell)))[(v.z.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +1][2*point.k-2 +0]) + sizeof(Cell)))[(v.z.i)])/4.;
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(v.z.i)] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0][2*point.k-2 +2]) + sizeof(Cell)))[(v.z.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +0][2*point.k-2 +2]) + sizeof(Cell)))[(v.z.i)] +
  ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +1][2*point.k-2 +2]) + sizeof(Cell)))[(v.z.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +1][2*point.k-2 +2]) + sizeof(Cell)))[(v.z.i)])/4.;

  }}
}

static inline void restriction_face (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 61 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  face_average (point, _attribute[s.i].v);
}

static inline void restriction_vertex (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 66 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  for (int i = 0; i <= 1; i++) {
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i] [2*point.j-2 +0][2*point.k-2 +0]) + sizeof(Cell)))[(s.i)];

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.i)] = ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i] [2*point.j-2 +2][2*point.k-2 +0]) + sizeof(Cell)))[(s.i)];


    for (int j = 0; j <= 1; j++)
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+1]) + sizeof(Cell)))[(s.i)] = ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i] [2*point.j-2 +2*j][2*point.k-2 +2]) + sizeof(Cell)))[(s.i)];

  }
}

static inline void no_restriction (Point point, scalar s) { int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 78 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
}

static inline void no_data (Point point, scalar s) { int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 81 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = ((double)1e30); } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
}

void wavelet (scalar s, scalar w)
{
  restriction (((scalar []){s,{-1}}));
  for (int l = (grid->depth) - 1; l >= 0; l--) {
     { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {{
# 90 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
 {
       { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
      _attribute[s.i].prolongation (point, s);
       { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; {
        double sp = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)];
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.i)];

        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.i)] -= sp;
      } } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
    } } } } } }; }}; }
    boundary_level (((scalar []){w,{-1}}), l + 1);
  }

   { { if (0 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[0]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = 0; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 104 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]; } } } }; }}; }
  boundary_level (((scalar []){w,{-1}}), 0);
}

void inverse_wavelet (scalar s, scalar w)
{
   { { if (0 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[0]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = 0; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 111 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.i)]; } } } }; }}; }
  boundary_level (((scalar []){s,{-1}}), 0);
  for (int l = 0; l <= (grid->depth) - 1; l++) {
     { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {{
# 115 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
 {
      _attribute[s.i].prolongation (point, s);
       { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.i)]; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
    } } } } } }; }}; }
    boundary_level (((scalar []){s,{-1}}), l + 1);
  }
}

static inline double bilinear (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 125 "/Users/weugene/basilisk/src/grid/multigrid-common.h"








    return (27.*((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+0][(point.k+2)/2+0]) + sizeof(Cell)))[(s.i)] +
     9.*(((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+child.x] [(point.j+2)/2+0][(point.k+2)/2+0]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+child.y][(point.k+2)/2+0]) + sizeof(Cell)))[(s.i)] +
  ((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+0][(point.k+2)/2+child.z]) + sizeof(Cell)))[(s.i)]) +
     3.*(((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+child.x] [(point.j+2)/2+child.y][(point.k+2)/2+0]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+child.x] [(point.j+2)/2+0][(point.k+2)/2+child.z]) + sizeof(Cell)))[(s.i)] +
  ((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+child.y][(point.k+2)/2+child.z]) + sizeof(Cell)))[(s.i)]) +
     ((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+child.x] [(point.j+2)/2+child.y][(point.k+2)/2+child.z]) + sizeof(Cell)))[(s.i)])/64.;

}

static inline void refine_bilinear (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 143 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = bilinear (point, s); } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
}

static inline double quadratic (double a, double b, double c)
{
  return (30.*a + 5.*b - 3.*c)/32.;
}

static inline double biquadratic (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 154 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
# 169 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
 (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/multigrid-common.h", 169, "false") : (void)0);
  return 0.;

}

static inline double biquadratic_vertex (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 175 "/Users/weugene/basilisk/src/grid/multigrid-common.h"







  (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/multigrid-common.h", 182, "false") : (void)0);
  return 0.;

}

static inline void refine_biquadratic (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 188 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = biquadratic (point, s); } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
}

static inline void refine_linear (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 194 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

if (!((cm).i >= 65536)) {
# 194 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  coord g;
  if (_attribute[s.i].gradient)
    {
# 197 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      g.x = _attribute[s.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]);
# 197 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      g.y = _attribute[s.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(s.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.i)]);
# 197 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      g.z = _attribute[s.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(s.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(s.i)]);}
  else
    {
# 200 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      g.x = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)])/2.;
# 200 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      g.y = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(s.i)])/2.;
# 200 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      g.z = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(s.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(s.i)])/2.;}

  double sc = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)], cmc = 4.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)], sum = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)]*(1 << 3);
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; {
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = sc;
    {
# 206 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] += child.x*g.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-child.x][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)]/cmc;
# 206 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] += child.y*g.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-child.y] [point.k+0]) + sizeof(Cell)))[(cm.i)]/cmc;
# 206 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] += child.z*g.z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-child.z]) + sizeof(Cell)))[(cm.i)]/cmc;}
    sum -= ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)];
  } } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  (__builtin_expect(!(fabs(sum) < 1e-10), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/multigrid-common.h", 210, "fabs(sum) < 1e-10") : (void)0);
 }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 194 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  coord g;
  if (_attribute[s.i].gradient)
    {
# 197 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      g.x = _attribute[s.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]);
# 197 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      g.y = _attribute[s.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(s.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.i)]);
# 197 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      g.z = _attribute[s.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(s.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(s.i)]);}
  else
    {
# 200 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      g.x = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)])/2.;
# 200 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      g.y = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(s.i)])/2.;
# 200 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      g.z = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(s.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(s.i)])/2.;}

  double sc = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)], cmc = 4.*_const_cm, sum = _const_cm*(1 << 3);
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; {
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = sc;
    {
# 206 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] += child.x*g.x*_const_cm/cmc;
# 206 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] += child.y*g.y*_const_cm/cmc;
# 206 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] += child.z*g.z*_const_cm/cmc;}
    sum -= _const_cm;
  } } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  (__builtin_expect(!(fabs(sum) < 1e-10), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/multigrid-common.h", 210, "fabs(sum) < 1e-10") : (void)0);
 }}

static inline void refine_reset (Point point, scalar v)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 214 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.i)] = 0.; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
}

static inline void refine_injection (Point point, scalar v)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 220 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  double val = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.i)];
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.i)] = val; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
}

static scalar multigrid_init_scalar (scalar s, const char * name)
{
  s = cartesian_init_scalar (s, name);
  _attribute[s.i].prolongation = refine_bilinear;
  _attribute[s.i].restriction = restriction_average;
  return s;
}

static scalar multigrid_init_vertex_scalar (scalar s, const char * name)
{
  s = cartesian_init_vertex_scalar (s, name);
  _attribute[s.i].restriction = restriction_vertex;
  return s;
}

static vector multigrid_init_face_vector (vector v, const char * name)
{
  v = cartesian_init_face_vector (v, name);
  {
# 244 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

    _attribute[v.y.i].restriction = no_restriction;
# 244 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

    _attribute[v.z.i].restriction = no_restriction;
# 244 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

    _attribute[v.x.i].restriction = no_restriction;}
  _attribute[v.x.i].restriction = restriction_face;
  return v;
}

void multigrid_debug (Point point)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 251 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  cartesian_debug (point);

  FILE * plot = fopen ("plot", "a");
  if (point.level > 0) {
    char name[80] = "coarse";
    if (0 > 0)
      __builtin___sprintf_chk (name, 0, __builtin_object_size (name, 2 > 1 ? 1 : 0), "coarse-%d", 0);
    FILE * fp = fopen (name, "w");
# 284 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
 double xc = x - child.x*Delta/2., yc = y - child.y*Delta/2.;
      double zc = z - child.z*Delta/2.;
      for (int k = 0; k <= 1; k++)
 for (int l = 0; l <= 1; l++)
   for (int m = 0; m <= 1; m++) {
     if (all) for (scalar v = *all, *_i41 = all; ((scalar *)&v)->i >= 0; v = *++_i41)
       fprintf (fp, "%g %g %g %g ",
         xc + k*child.x*Delta*2. + _attribute[v.i].d.x*Delta,
         yc + l*child.y*Delta*2. + _attribute[v.i].d.y*Delta,
         zc + m*child.z*Delta*2. + _attribute[v.i].d.z*Delta,
         ((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+k*child.x] [(point.j+2)/2+l*child.y][(point.k+2)/2+m*child.z]) + sizeof(Cell)))[(v.i)]);
     fputc ('\n', fp);
   }
      fprintf (__stderrp, ", '%s' u 1+4*v:2+4*v:3+4*v:4+4*v w labels tc lt 3 t ''",
        name);
      fprintf (plot, ", '%s' u 1+4*v:2+4*v:3+4*v:4+4*v w labels tc lt 3 t ''",
        name);

    fclose (fp);
  }

  if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).neighbors > 0)) {
    char name[80] = "fine";
    if (0 > 0)
      __builtin___sprintf_chk (name, 0, __builtin_object_size (name, 2 > 1 ? 1 : 0), "fine-%d", 0);
    FILE * fp = fopen (name, "w");
# 341 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
 double xf = x - Delta/4., yf = y - Delta/4., zf = z - Delta/4.;
      for (int k = -2; k <= 3; k++)
 for (int l = -2; l <= 3; l++)
   for (int m = -2; m <= 3; m++) {
     if (all) for (scalar v = *all, *_i42 = all; ((scalar *)&v)->i >= 0; v = *++_i42) {
       fprintf (fp, "%g %g %g ",
         xf + k*Delta/2. + _attribute[v.i].d.x*Delta/4.,
         yf + l*Delta/2. + _attribute[v.i].d.y*Delta/4.,
         zf + m*Delta/2. + _attribute[v.i].d.z*Delta/4.);
       if ((level < (grid->depth) && point.i > 0 && point.i <= (1 << level) + 2 && point.j > 0 && point.j <= (1 << level) + 2 && point.k > 0 && point.k <= (1 << level) + 2 && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +k] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +k][2*point.j-2 +l] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +k][2*point.j-2 +l] [2*point.k-2 +m]))
  fprintf (fp, "%g ", ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +k] [2*point.j-2 +l][2*point.k-2 +m]) + sizeof(Cell)))[(v.i)]);
       else
  fputs ("n/a ", fp);
     }
     fputc ('\n', fp);
   }
      fprintf (__stderrp, ", '%s' u 1+4*v:2+4*v:3+4*v:4+4*v w labels tc lt 2 t ''",
        name);
      fprintf (plot, ", '%s' u 1+4*v:2+4*v:3+4*v:4+4*v w labels tc lt 2 t ''",
        name);

    fclose (fp);
  }
  fflush (__stderrp);
  fclose (plot);
}

static void multigrid_restriction (scalar * list)
{
  scalar * listdef = ((void*)0), * listc = ((void*)0), * list2 = ((void*)0);
  if (list) for (scalar s = *list, *_i43 = list; ((scalar *)&s)->i >= 0; s = *++_i43)
    if (!((s).i >= 65536) && _attribute[s.i].block > 0) {
      if (_attribute[s.i].restriction == restriction_average) {
 listdef = list_add (listdef, s);
 list2 = list_add (list2, s);
      }
      else if (_attribute[s.i].restriction != no_restriction) {
 listc = list_add (listc, s);
 if (_attribute[s.i].face)
   {
# 380 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

     list2 = list_add (list2, _attribute[s.i].v.x);
# 380 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

     list2 = list_add (list2, _attribute[s.i].v.y);
# 380 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

     list2 = list_add (list2, _attribute[s.i].v.z);}
 else
   list2 = list_add (list2, s);
      }
    }

  if (listdef || listc) {
    for (int l = (grid->depth) - 1; l >= 0; l--) {
       { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {{
# 389 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
 {
 if (listdef) for (scalar s = *listdef, *_i44 = listdef; ((scalar *)&s)->i >= 0; s = *++_i44)

     restriction_average (point, s);
 if (listc) for (scalar s = *listc, *_i45 = listc; ((scalar *)&s)->i >= 0; s = *++_i45) {

     _attribute[s.i].restriction (point, s);
 }
      } } } } } }; }}; }
      { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list2, l); };
    }
    free(listdef);
    free(listc);
    free(list2);
  }
}

void multigrid_methods()
{
  cartesian_methods();
  debug = multigrid_debug;
  init_scalar = multigrid_init_scalar;
  init_vertex_scalar = multigrid_init_vertex_scalar;
  init_face_vector = multigrid_init_face_vector;
  restriction = multigrid_restriction;
}







void subtree_size (scalar size, _Bool leaves)
{




   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 428 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(size.i)] = 1; } } } }; }





  { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b, ((scalar []){size,{-1}}), (grid->depth)); };
  for (int l = (grid->depth) - 1; l >= 0; l--) {
     { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {{
# 437 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
 {
      double sum = !leaves;
       { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
 sum += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(size.i)]; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(size.i)] = sum;
    } } } } } }; }}; }
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b, ((scalar []){size,{-1}}), l); };
  }
}
# 5 "/Users/weugene/basilisk/src/grid/tree-common.h"
# 21 "/Users/weugene/basilisk/src/grid/tree-common.h"
int refine_cell (Point point, scalar * list, int flag, Cache * refined)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 22 "/Users/weugene/basilisk/src/grid/tree-common.h"

  int nr = 0;


  if (level > 0)
    for (int k = 0; k != 2*child.x; k += child.x)

      for (int l = 0; l != 2*child.y; l += child.y)


 for (int m = 0; m != 2*child.z; m += child.z)

   if ((*((Cell *)((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+k] [(point.j+2)/2+l][(point.k+2)/2+m])))).pid >= 0 && (((*((Cell *)((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+k] [(point.j+2)/2+l][(point.k+2)/2+m]))))).flags & leaf)) {
     Point p = point;


     p.level = point.level - 1;
     p.i = (point.i + 2)/2 + k;
     do { if (p.i < 2) p.i += 1 << p.level; else if (p.i >= 2 + (1 << p.level)) p.i -= 1 << p.level; } while(0);

       p.j = (point.j + 2)/2 + l;
       do { if (p.j < 2) p.j += 1 << p.level; else if (p.j >= 2 + (1 << p.level)) p.j -= 1 << p.level; } while(0);


       p.k = (point.k + 2)/2 + m;
       do { if (p.k < 2) p.k += 1 << p.level; else if (p.k >= 2 + (1 << p.level)) p.k -= 1 << p.level; } while(0);

     nr += refine_cell (p, list, flag, refined);
     (*((Cell *)((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+k] [(point.j+2)/2+l][(point.k+2)/2+m])))).flags |= flag;
   }



  increment_neighbors (point);

  int cflag = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & active) ? (active|leaf) : leaf;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags |= cflag; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }


  if (list) for (scalar s = *list, *_i46 = list; ((scalar *)&s)->i >= 0; s = *++_i46)
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0) || _attribute[s.i].face)
      _attribute[s.i].refine (point, s);


  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~leaf;
# 91 "/Users/weugene/basilisk/src/grid/tree-common.h"
  return nr;
}





_Bool coarsen_cell (Point point, scalar * list)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 99 "/Users/weugene/basilisk/src/grid/tree-common.h"




  int pid = (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors || ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid < 0 && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid != pid))
      return 0; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }



  if (list) for (scalar s = *list, *_i47 = list; ((scalar *)&s)->i >= 0; s = *++_i47) {
    _attribute[s.i].restriction (point, s);
    if (_attribute[s.i].coarsen)
      _attribute[s.i].coarsen (point, s);
  }


  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags |= leaf;


  decrement_neighbors (point);
# 133 "/Users/weugene/basilisk/src/grid/tree-common.h"
  return 1;
}

void coarsen_cell_recursive (Point point, scalar * list)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 137 "/Users/weugene/basilisk/src/grid/tree-common.h"



   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors)
       { { int _nn = 1 + 0 ? 1 + 0 : 2; int _i = point.i, _j = point.j, _k = point.k; for (int _l = - _nn; _l <= _nn; _l++) { point.i = _i + _l; for (int _m = - _nn; _m <= _nn; _m++) { point.j = _j + _m; for (int _n = - _nn; _n <= _nn; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
 if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid >= 0))
   coarsen_cell_recursive (point, list); } } } point.i = _i; point.j = _j; point.k = _k;}; } } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }

  (__builtin_expect(!(coarsen_cell (point, list)), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree-common.h", 146, "coarsen_cell (point, list)") : (void)0);
}

void mpi_boundary_refine (scalar *);
void mpi_boundary_coarsen (int, int);
void mpi_boundary_update (scalar *);

typedef struct {
  int nc, nf;
} astats;

struct Adapt {
  scalar * slist;
  double * max;
  int maxlevel;
  int minlevel;
  scalar * list;
};


astats adapt_wavelet (struct Adapt p)
{ ;
  if (p.list == ((void*)0))
    p.list = all;
  if (((cm).i >= 65536))
    restriction (p.slist);
  else {
    scalar * listr = list_concat (((scalar []){cm,{-1}}), p.slist);
    restriction (listr);
    free(listr);
  }
  int i = 0;
  if (p.slist) for (scalar s = *p.slist, *_i48 = p.slist; ((scalar *)&s)->i >= 0; s = *++_i48) {
        double max = p.max[i++];
  }
  astats st = {0, 0};
  scalar * listc = ((void*)0);
  if (p.list) for (scalar s = *p.list, *_i49 = p.list; ((scalar *)&s)->i >= 0; s = *++_i49)
    if (!((s).i >= 65536) && _attribute[s.i].restriction != no_restriction)
      listc = list_add (listc, s);


  if (p.minlevel < 1)
    p.minlevel = 1;
  ((Tree *)grid)->refined.n = 0;
  static const int refined = 1 << user, too_fine = 1 << (user + 1);
   { { Point root = {2,2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 192 "/Users/weugene/basilisk/src/grid/tree-common.h"
 {
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & active)) {
      static const int too_coarse = 1 << (user + 2);
      if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {
 if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & too_coarse) {
   (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_coarse;
   refine_cell (point, listc, refined, &((Tree *)grid)->refined);
   st.nf++;
 }
 continue;
      }
      else {
 if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & refined) {

   (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_coarse;
   continue;
 }

 _Bool local = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0);
 if (!local)
    { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
     if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0))
       local = 1, _l = _m = _n = 2; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
 if (local) {
   int i = 0;
   static const int just_fine = 1 << (user + 3);
   if (p.slist) for (scalar s = *p.slist, *_i50 = p.slist; ((scalar *)&s)->i >= 0; s = *++_i50) {
     double max = p.max[i++], sc[1 << 3];
     int c = 0;
      { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
       sc[c++] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
     _attribute[s.i].prolongation (point, s);
     c = 0;
      { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; {
       double e = fabs(sc[c] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]);
       if (e > max && level < p.maxlevel) {
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_fine;
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags |= too_coarse;
       }
       else if ((e <= max/1.5 || level > p.maxlevel) &&
         !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & (too_coarse|just_fine))) {
  if (level >= p.minlevel)
    (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags |= too_fine;
       }
       else if (!((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & too_coarse)) {
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_fine;
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags |= just_fine;
       }
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = sc[c++];
     } } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
   }
    { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; {
     (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~just_fine;
     if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {
       (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_coarse;
       if (level >= p.maxlevel)
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags |= too_fine;
     }
     else if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & active))
       (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_coarse;
   } } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
 }
      }
    }
    else
      continue;
  } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
  mpi_boundary_refine (listc);



  for (int l = (grid->depth); l >= 0; l--) {
     { { Point root = {2,2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 264 "/Users/weugene/basilisk/src/grid/tree-common.h"

      if (!((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid < 0)) {
 if (level == l) {
   if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {
     if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & refined)

       (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~(refined|too_fine);
     else if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & too_fine) {
       if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0) && coarsen_cell (point, listc))
  st.nc++;
       (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_fine;
     }
   }
   if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & too_fine)
     (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_fine;
   else if (level > 0 && ((*((Cell *)((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+0][(point.k+2)/2+0])))).flags & too_fine))
     (*((Cell *)((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+0][(point.k+2)/2+0])))).flags &= ~too_fine;
   continue;
 }
 else if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf))
   continue;
      } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
    mpi_boundary_coarsen (l, too_fine);
  }
  free(listc);

                                          ;
                                          ;
  if (st.nc || st.nf)
    mpi_boundary_update (p.list);

  { astats _ret = st; ; return _ret; }
                                                                                  ; }
# 317 "/Users/weugene/basilisk/src/grid/tree-common.h"
static void refine_level (int depth)
{
  int refined;
  do {
    refined = 0;
    ((Tree *)grid)->refined.n = 0;
     { { Point root = {2,2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) { if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & active) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0)) {{
# 323 "/Users/weugene/basilisk/src/grid/tree-common.h"

      if (level < depth) {
 refine_cell (point, ((void*)0), 0, &((Tree *)grid)->refined);
 refined++;
 continue;
      } } } continue; } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
                                              ;
    if (refined) {
      mpi_boundary_refine (((void*)0));
      mpi_boundary_update (((void*)0));
    }
  } while (refined);
}
# 362 "/Users/weugene/basilisk/src/grid/tree-common.h"
static void halo_flux (vector * list)
{
  vector * listv = ((void*)0);
  if (list) for (vector v = *list, *_i51 = list; ((scalar *)&v)->i >= 0; v = *++_i51)
    if (!((v.x).i >= 65536))
      listv = vectors_add (listv, v);

  if (listv) {
    for (int l = (grid->depth) - 1; l >= 0; l--)
       { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _cache = ((Tree *)grid)->prolongation[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = l; int _k; for (_k = 0; _k < _cache.n; _k++) { point.i = _cache.p[_k].i; point.j = _cache.p[_k].j; point.k = _cache.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 371 "/Users/weugene/basilisk/src/grid/tree-common.h"

 {
# 372 "/Users/weugene/basilisk/src/grid/tree-common.h"
 {
# 388 "/Users/weugene/basilisk/src/grid/tree-common.h"
 if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0])))).pid >= 0))
     if (listv) for (vector f = *listv, *_i52 = listv; ((scalar *)&f)->i >= 0; f = *++_i52)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.x.i)] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0][2*point.k-2 +0]) + sizeof(Cell)))[(f.x.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +1][2*point.k-2 +0]) + sizeof(Cell)))[(f.x.i)] +
         ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0][2*point.k-2 +1]) + sizeof(Cell)))[(f.x.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +1][2*point.k-2 +1]) + sizeof(Cell)))[(f.x.i)])/4.;
   if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0])))).pid >= 0))
     if (listv) for (vector f = *listv, *_i53 = listv; ((scalar *)&f)->i >= 0; f = *++_i53)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.x.i)] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] [2*point.j-2 +0][2*point.k-2 +0]) + sizeof(Cell)))[(f.x.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] [2*point.j-2 +1][2*point.k-2 +0]) + sizeof(Cell)))[(f.x.i)] +
   ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] [2*point.j-2 +0][2*point.k-2 +1]) + sizeof(Cell)))[(f.x.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] [2*point.j-2 +1][2*point.k-2 +1]) + sizeof(Cell)))[(f.x.i)])/4.;

      }
# 372 "/Users/weugene/basilisk/src/grid/tree-common.h"
 {
# 388 "/Users/weugene/basilisk/src/grid/tree-common.h"
 if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0])))).pid >= 0))
     if (listv) for (vector f = *listv, *_i52 = listv; ((scalar *)&f)->i >= 0; f = *++_i52)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.y.i)] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0][2*point.k-2 +0]) + sizeof(Cell)))[(f.y.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0][2*point.k-2 +1]) + sizeof(Cell)))[(f.y.i)] +
         ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +0][2*point.k-2 +0]) + sizeof(Cell)))[(f.y.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +0][2*point.k-2 +1]) + sizeof(Cell)))[(f.y.i)])/4.;
   if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0])))).pid >= 0))
     if (listv) for (vector f = *listv, *_i53 = listv; ((scalar *)&f)->i >= 0; f = *++_i53)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(f.y.i)] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +2][2*point.k-2 +0]) + sizeof(Cell)))[(f.y.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +2][2*point.k-2 +1]) + sizeof(Cell)))[(f.y.i)] +
   ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +2][2*point.k-2 +0]) + sizeof(Cell)))[(f.y.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +2][2*point.k-2 +1]) + sizeof(Cell)))[(f.y.i)])/4.;

      }
# 372 "/Users/weugene/basilisk/src/grid/tree-common.h"
 {
# 388 "/Users/weugene/basilisk/src/grid/tree-common.h"
 if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1])))).pid >= 0))
     if (listv) for (vector f = *listv, *_i52 = listv; ((scalar *)&f)->i >= 0; f = *++_i52)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.z.i)] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0][2*point.k-2 +0]) + sizeof(Cell)))[(f.z.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +0][2*point.k-2 +0]) + sizeof(Cell)))[(f.z.i)] +
         ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +1][2*point.k-2 +0]) + sizeof(Cell)))[(f.z.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +1][2*point.k-2 +0]) + sizeof(Cell)))[(f.z.i)])/4.;
   if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1])))).pid >= 0))
     if (listv) for (vector f = *listv, *_i53 = listv; ((scalar *)&f)->i >= 0; f = *++_i53)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(f.z.i)] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0][2*point.k-2 +2]) + sizeof(Cell)))[(f.z.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +0][2*point.k-2 +2]) + sizeof(Cell)))[(f.z.i)] +
   ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +1][2*point.k-2 +2]) + sizeof(Cell)))[(f.z.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +1][2*point.k-2 +2]) + sizeof(Cell)))[(f.z.i)])/4.;

      }} } } } }; }}; }
    free(listv);
  }
}



static scalar tree_init_scalar (scalar s, const char * name)
{
  s = multigrid_init_scalar (s, name);
  _attribute[s.i].refine = _attribute[s.i].prolongation;
  return s;
}

static void prolongation_vertex (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 412 "/Users/weugene/basilisk/src/grid/tree-common.h"




  ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +1][2*point.k-2 +1]) + sizeof(Cell)))[(s.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.i)] +
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+1]) + sizeof(Cell)))[(s.i)])/8.;


  for (int i = 0; i <= 1; i++) {
    for (int j = 0; j <= 1; j++)

      for (int k = 0; k <= 1; k++)
 if ((level < (grid->depth) && point.i > 0 && point.i <= (1 << level) + 2 && point.j > 0 && point.j <= (1 << level) + 2 && point.k > 0 && point.k <= (1 << level) + 2 && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i][2*point.j-2 +2*j] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i][2*point.j-2 +2*j] [2*point.k-2 +2*k]))
   ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i] [2*point.j-2 +2*j][2*point.k-2 +2*k]) + sizeof(Cell)))[(s.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+k]) + sizeof(Cell)))[(s.i)];





    {
# 431 "/Users/weugene/basilisk/src/grid/tree-common.h"

      if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0])))).neighbors) {



 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i] [2*point.j-2 +1][2*point.k-2 +1]) + sizeof(Cell)))[(s.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+1]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+1]) + sizeof(Cell)))[(s.i)])/4.;
 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i] [2*point.j-2 +1][2*point.k-2 +0]) + sizeof(Cell)))[(s.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.i)])/2.;
 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i] [2*point.j-2 +0][2*point.k-2 +1]) + sizeof(Cell)))[(s.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+1]) + sizeof(Cell)))[(s.i)])/2.;
 if ((level < (grid->depth) && point.i > 0 && point.i <= (1 << level) + 2 && point.j > 0 && point.j <= (1 << level) + 2 && point.k > 0 && point.k <= (1 << level) + 2 && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i][2*point.j-2 +1] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i][2*point.j-2 +1] [2*point.k-2 +2]))
   ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i] [2*point.j-2 +1][2*point.k-2 +2]) + sizeof(Cell)))[(s.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+1]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+1]) + sizeof(Cell)))[(s.i)])/2.;
 if ((level < (grid->depth) && point.i > 0 && point.i <= (1 << level) + 2 && point.j > 0 && point.j <= (1 << level) + 2 && point.k > 0 && point.k <= (1 << level) + 2 && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i][2*point.j-2 +2] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i][2*point.j-2 +2] [2*point.k-2 +1]))
   ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i] [2*point.j-2 +2][2*point.k-2 +1]) + sizeof(Cell)))[(s.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+1]) + sizeof(Cell)))[(s.i)])/2.;

      }
# 431 "/Users/weugene/basilisk/src/grid/tree-common.h"

      if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0])))).neighbors) {



 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +2*i][2*point.k-2 +1]) + sizeof(Cell)))[(s.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+1]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i] [point.k+0]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i] [point.k+1]) + sizeof(Cell)))[(s.i)])/4.;
 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +2*i][2*point.k-2 +1]) + sizeof(Cell)))[(s.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+1]) + sizeof(Cell)))[(s.i)])/2.;
 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +2*i][2*point.k-2 +0]) + sizeof(Cell)))[(s.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i] [point.k+0]) + sizeof(Cell)))[(s.i)])/2.;
 if ((level < (grid->depth) && point.i > 0 && point.i <= (1 << level) + 2 && point.j > 0 && point.j <= (1 << level) + 2 && point.k > 0 && point.k <= (1 << level) + 2 && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2][2*point.j-2 +2*i] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2][2*point.j-2 +2*i] [2*point.k-2 +1]))
   ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] [2*point.j-2 +2*i][2*point.k-2 +1]) + sizeof(Cell)))[(s.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i] [point.k+0]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i] [point.k+1]) + sizeof(Cell)))[(s.i)])/2.;
 if ((level < (grid->depth) && point.i > 0 && point.i <= (1 << level) + 2 && point.j > 0 && point.j <= (1 << level) + 2 && point.k > 0 && point.k <= (1 << level) + 2 && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1][2*point.j-2 +2*i] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1][2*point.j-2 +2*i] [2*point.k-2 +2]))
   ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +2*i][2*point.k-2 +2]) + sizeof(Cell)))[(s.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+1]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i] [point.k+1]) + sizeof(Cell)))[(s.i)])/2.;

      }
# 431 "/Users/weugene/basilisk/src/grid/tree-common.h"

      if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i])))).neighbors) {



 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +1][2*point.k-2 +2*i]) + sizeof(Cell)))[(s.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+i]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+i]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+i]) + sizeof(Cell)))[(s.i)])/4.;
 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +0][2*point.k-2 +2*i]) + sizeof(Cell)))[(s.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+i]) + sizeof(Cell)))[(s.i)])/2.;
 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +1][2*point.k-2 +2*i]) + sizeof(Cell)))[(s.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+i]) + sizeof(Cell)))[(s.i)])/2.;
 if ((level < (grid->depth) && point.i > 0 && point.i <= (1 << level) + 2 && point.j > 0 && point.j <= (1 << level) + 2 && point.k > 0 && point.k <= (1 << level) + 2 && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1][2*point.j-2 +2] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1][2*point.j-2 +2] [2*point.k-2 +2*i]))
   ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +2][2*point.k-2 +2*i]) + sizeof(Cell)))[(s.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+i]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+i]) + sizeof(Cell)))[(s.i)])/2.;
 if ((level < (grid->depth) && point.i > 0 && point.i <= (1 << level) + 2 && point.j > 0 && point.j <= (1 << level) + 2 && point.k > 0 && point.k <= (1 << level) + 2 && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2][2*point.j-2 +1] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2][2*point.j-2 +1] [2*point.k-2 +2*i]))
   ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] [2*point.j-2 +1][2*point.k-2 +2*i]) + sizeof(Cell)))[(s.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+i]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+i]) + sizeof(Cell)))[(s.i)])/2.;

      }}
  }
}

static scalar tree_init_vertex_scalar (scalar s, const char * name)
{
  s = multigrid_init_vertex_scalar (s, name);
  _attribute[s.i].refine = _attribute[s.i].prolongation = prolongation_vertex;
  return s;
}
# 455 "/Users/weugene/basilisk/src/grid/tree-common.h"

static void refine_face_x (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 457 "/Users/weugene/basilisk/src/grid/tree-common.h"

  vector v = _attribute[s.i].v;
# 478 "/Users/weugene/basilisk/src/grid/tree-common.h"
 if (!(!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0])))).pid >= 0) &&
      ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0) || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]))))).pid == 0))) {
    double g1 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+ +1] [point.k+0]) + sizeof(Cell)))[(v.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(v.x.i)])/8.;
    double g2 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+ +1]) + sizeof(Cell)))[(v.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(v.x.i)])/8.;
    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +j][2*point.k-2 +k]) + sizeof(Cell)))[(v.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)] + (2*j - 1)*g1 + (2*k - 1)*g2;
  }
  if (!(!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0])))).pid >= 0) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0])))).neighbors &&
      ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0) || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]))))).pid == 0))) {
    double g1 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+ +1] [point.k+0]) + sizeof(Cell)))[(v.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(v.x.i)])/8.;
    double g2 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+ +1]) + sizeof(Cell)))[(v.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(v.x.i)])/8.;
    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] [2*point.j-2 +j][2*point.k-2 +k]) + sizeof(Cell)))[(v.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)] + (2*j - 1)*g1 + (2*k - 1)*g2;
  }
  if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0)) {
    double g1 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+ +1] [point.k+0]) + sizeof(Cell)))[(v.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(v.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+ +1] [point.k+0]) + sizeof(Cell)))[(v.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(v.x.i)])/16.;
    double g2 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+ +1]) + sizeof(Cell)))[(v.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(v.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+ +1]) + sizeof(Cell)))[(v.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(v.x.i)])/16.;
    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +j][2*point.k-2 +k]) + sizeof(Cell)))[(v.x.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)])/2. + (2*j - 1)*g1 + (2*k - 1)*g2;
  }

}
# 455 "/Users/weugene/basilisk/src/grid/tree-common.h"

static void refine_face_y (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 457 "/Users/weugene/basilisk/src/grid/tree-common.h"

  vector v = _attribute[s.i].v;
# 478 "/Users/weugene/basilisk/src/grid/tree-common.h"
 if (!(!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0])))).pid >= 0) &&
      ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0) || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]))))).pid == 0))) {
    double g1 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+ +1]) + sizeof(Cell)))[(v.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(v.y.i)])/8.;
    double g2 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+ +1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)])/8.;
    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +k] [2*point.j-2 +0][2*point.k-2 +j]) + sizeof(Cell)))[(v.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)] + (2*j - 1)*g1 + (2*k - 1)*g2;
  }
  if (!(!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0])))).pid >= 0) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0])))).neighbors &&
      ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0) || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]))))).pid == 0))) {
    double g1 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+ +1]) + sizeof(Cell)))[(v.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(v.y.i)])/8.;
    double g2 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+ +1][point.j+1] [point.k+0]) + sizeof(Cell)))[(v.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(v.y.i)])/8.;
    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +k] [2*point.j-2 +2][2*point.k-2 +j]) + sizeof(Cell)))[(v.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(v.y.i)] + (2*j - 1)*g1 + (2*k - 1)*g2;
  }
  if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0)) {
    double g1 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+ +1]) + sizeof(Cell)))[(v.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(v.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+ +1]) + sizeof(Cell)))[(v.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(v.y.i)])/16.;
    double g2 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+ +1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+ +1][point.j+1] [point.k+0]) + sizeof(Cell)))[(v.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(v.y.i)])/16.;
    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +k] [2*point.j-2 +1][2*point.k-2 +j]) + sizeof(Cell)))[(v.y.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(v.y.i)])/2. + (2*j - 1)*g1 + (2*k - 1)*g2;
  }

}
# 455 "/Users/weugene/basilisk/src/grid/tree-common.h"

static void refine_face_z (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 457 "/Users/weugene/basilisk/src/grid/tree-common.h"

  vector v = _attribute[s.i].v;
# 478 "/Users/weugene/basilisk/src/grid/tree-common.h"
 if (!(!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1])))).pid >= 0) &&
      ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0) || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]))))).pid == 0))) {
    double g1 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+ +1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)])/8.;
    double g2 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+ +1] [point.k+0]) + sizeof(Cell)))[(v.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(v.z.i)])/8.;
    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +j] [2*point.j-2 +k][2*point.k-2 +0]) + sizeof(Cell)))[(v.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)] + (2*j - 1)*g1 + (2*k - 1)*g2;
  }
  if (!(!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1])))).pid >= 0) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1])))).neighbors &&
      ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0) || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]))))).pid == 0))) {
    double g1 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+ +1][point.j+0] [point.k+1]) + sizeof(Cell)))[(v.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(v.z.i)])/8.;
    double g2 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+ +1] [point.k+1]) + sizeof(Cell)))[(v.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(v.z.i)])/8.;
    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +j] [2*point.j-2 +k][2*point.k-2 +2]) + sizeof(Cell)))[(v.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(v.z.i)] + (2*j - 1)*g1 + (2*k - 1)*g2;
  }
  if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0)) {
    double g1 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+ +1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+ +1][point.j+0] [point.k+1]) + sizeof(Cell)))[(v.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(v.z.i)])/16.;
    double g2 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+ +1] [point.k+0]) + sizeof(Cell)))[(v.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(v.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+ +1] [point.k+1]) + sizeof(Cell)))[(v.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(v.z.i)])/16.;
    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +j] [2*point.j-2 +k][2*point.k-2 +1]) + sizeof(Cell)))[(v.z.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(v.z.i)])/2. + (2*j - 1)*g1 + (2*k - 1)*g2;
  }

}

void refine_face (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 505 "/Users/weugene/basilisk/src/grid/tree-common.h"

  vector v = _attribute[s.i].v;
  {
# 507 "/Users/weugene/basilisk/src/grid/tree-common.h"

    _attribute[v.x.i].prolongation (point, v.x);
# 507 "/Users/weugene/basilisk/src/grid/tree-common.h"

    _attribute[v.y.i].prolongation (point, v.y);
# 507 "/Users/weugene/basilisk/src/grid/tree-common.h"

    _attribute[v.z.i].prolongation (point, v.z);}
}

void refine_face_solenoidal (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 512 "/Users/weugene/basilisk/src/grid/tree-common.h"

  refine_face (point, s);

  if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0)) {

    vector v = _attribute[s.i].v;
    double d[1 << 3], p[1 << 3];
    int i = 0;
     { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; {
      d[i] = 0.;
      {
# 522 "/Users/weugene/basilisk/src/grid/tree-common.h"

 d[i] += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)];
# 522 "/Users/weugene/basilisk/src/grid/tree-common.h"

 d[i] += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(v.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)];
# 522 "/Users/weugene/basilisk/src/grid/tree-common.h"

 d[i] += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(v.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)];}
      i++;
    } } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
# 536 "/Users/weugene/basilisk/src/grid/tree-common.h"
 static double m[7][7] = {
      {7./12,5./24,3./8,5./24,3./8,1./4,1./3},
      {5./24,7./12,3./8,5./24,1./4,3./8,1./3},
      {3./8,3./8,3./4,1./4,3./8,3./8,1./2},
      {5./24,5./24,1./4,7./12,3./8,3./8,1./3},
      {3./8,1./4,3./8,3./8,3./4,3./8,1./2},
      {1./4,3./8,3./8,3./8,3./8,3./4,1./2},
      {1./3,1./3,1./2,1./3,1./2,1./2,5./6}
    };
    p[0] = 0.;
    for (int i = 0; i < 7; i++) {
      p[i + 1] = 0.;
      for (int j = 0; j < 7; j++)
 p[i + 1] += m[i][j]*d[j+1];
    }
    for (int k = 0; k <= 1; k++) {
      ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +0][2*point.k-2 +k]) + sizeof(Cell)))[(v.x.i)] += p[4+k] - p[0+k];
      ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +1][2*point.k-2 +k]) + sizeof(Cell)))[(v.x.i)] += p[6+k] - p[2+k];
      ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +1][2*point.k-2 +k]) + sizeof(Cell)))[(v.y.i)] += p[2+k] - p[0+k];
      ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +1][2*point.k-2 +k]) + sizeof(Cell)))[(v.y.i)] += p[6+k] - p[4+k];
    }
    ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0][2*point.k-2 +1]) + sizeof(Cell)))[(v.z.i)] += p[1] - p[0];
    ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +1][2*point.k-2 +1]) + sizeof(Cell)))[(v.z.i)] += p[3] - p[2];
    ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +0][2*point.k-2 +1]) + sizeof(Cell)))[(v.z.i)] += p[5] - p[4];
    ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +1][2*point.k-2 +1]) + sizeof(Cell)))[(v.z.i)] += p[7] - p[6];

  }

}

vector tree_init_face_vector (vector v, const char * name)
{
  v = cartesian_init_face_vector (v, name);
  {
# 569 "/Users/weugene/basilisk/src/grid/tree-common.h"

    _attribute[v.x.i].restriction = _attribute[v.x.i].refine = no_restriction;
# 569 "/Users/weugene/basilisk/src/grid/tree-common.h"

    _attribute[v.y.i].restriction = _attribute[v.y.i].refine = no_restriction;
# 569 "/Users/weugene/basilisk/src/grid/tree-common.h"

    _attribute[v.z.i].restriction = _attribute[v.z.i].refine = no_restriction;}
  _attribute[v.x.i].restriction = restriction_face;
  _attribute[v.x.i].refine = refine_face;
  {
# 573 "/Users/weugene/basilisk/src/grid/tree-common.h"

    _attribute[v.x.i].prolongation = refine_face_x;
# 573 "/Users/weugene/basilisk/src/grid/tree-common.h"

    _attribute[v.y.i].prolongation = refine_face_y;
# 573 "/Users/weugene/basilisk/src/grid/tree-common.h"

    _attribute[v.z.i].prolongation = refine_face_z;}
  return v;
}

static void tree_boundary_level (scalar * list, int l)
{
  int depth = l < 0 ? (grid->depth) : l;

  if (tree_is_full()) {
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list, depth); };
    return;
  }

  scalar * listdef = ((void*)0), * listc = ((void*)0), * list2 = ((void*)0), * vlist = ((void*)0);
  if (list) for (scalar s = *list, *_i54 = list; ((scalar *)&s)->i >= 0; s = *++_i54)
    if (!((s).i >= 65536)) {
      if (_attribute[s.i].restriction == restriction_average) {
 listdef = list_add (listdef, s);
 list2 = list_add (list2, s);
      }
      else if (_attribute[s.i].restriction != no_restriction) {
 listc = list_add (listc, s);
 if (_attribute[s.i].face)
   {
# 597 "/Users/weugene/basilisk/src/grid/tree-common.h"

     list2 = list_add (list2, _attribute[s.i].v.x);
# 597 "/Users/weugene/basilisk/src/grid/tree-common.h"

     list2 = list_add (list2, _attribute[s.i].v.y);
# 597 "/Users/weugene/basilisk/src/grid/tree-common.h"

     list2 = list_add (list2, _attribute[s.i].v.z);}
 else {
   list2 = list_add (list2, s);
   if (_attribute[s.i].restriction == restriction_vertex)
     vlist = list_add (vlist, s);
 }
      }
    }

  if (vlist)
# 632 "/Users/weugene/basilisk/src/grid/tree-common.h"
 { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->vertices.n; _k++) { point.i = ((Tree *)grid)->vertices.p[_k].i; point.j = ((Tree *)grid)->vertices.p[_k].j; point.k = ((Tree *)grid)->vertices.p[_k].k; point.level = ((Tree *)grid)->vertices.p[_k].level; _flags = ((Tree *)grid)->vertices.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { x -= Delta/2.; y -= Delta/2.; z -= Delta/2.;{
# 632 "/Users/weugene/basilisk/src/grid/tree-common.h"
 {
      if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid >= 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0])))).pid >= 0) ||
   (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0])))).pid >= 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0])))).pid >= 0) ||
   (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1])))).pid >= 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1])))).pid >= 0) ||
   (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1])))).pid >= 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+-1]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+-1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+-1])))).pid >= 0)) {

 if (vlist) for (scalar s = *vlist, *_i55 = vlist; ((scalar *)&s)->i >= 0; s = *++_i55)
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = (((*((Cell *)((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0][2*point.k-2 +0]))))).flags & vertex) ? ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0][2*point.k-2 +0]) + sizeof(Cell)))[(s.i)] : ((double)1e30);
      }
      else
 {
# 642 "/Users/weugene/basilisk/src/grid/tree-common.h"
 {
   if (child.y == 1 && child.z == 1 &&
       ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid >= 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0])))).pid >= 0))) {

     if (vlist) for (scalar s = *vlist, *_i56 = vlist; ((scalar *)&s)->i >= 0; s = *++_i56)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]))))).flags & vertex) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]))))).flags & vertex)
  && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]))))).flags & vertex) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]))))).flags & vertex) ?
  (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(s.i)])/4. : ((double)1e30);
   }
   else if (child.x == -1 && child.z == -1 && child.y == 1 &&
     ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid >= 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0])))).pid >= 0) ||
      (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1])))).pid >= 0) ||
      (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1])))).pid >= 0))) {

     if (vlist) for (scalar s = *vlist, *_i57 = vlist; ((scalar *)&s)->i >= 0; s = *++_i57)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]))))).flags & vertex) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]))))).flags & vertex) ?
  (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.i)])/2. : ((double)1e30);
   }
 }
# 642 "/Users/weugene/basilisk/src/grid/tree-common.h"
 {
   if (child.z == 1 && child.x == 1 &&
       ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid >= 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0])))).pid >= 0))) {

     if (vlist) for (scalar s = *vlist, *_i56 = vlist; ((scalar *)&s)->i >= 0; s = *++_i56)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]))))).flags & vertex) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]))))).flags & vertex)
  && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]))))).flags & vertex) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]))))).flags & vertex) ?
  (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(s.i)])/4. : ((double)1e30);
   }
   else if (child.y == -1 && child.x == -1 && child.z == 1 &&
     ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid >= 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0])))).pid >= 0) ||
      (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0])))).pid >= 0) ||
      (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0])))).pid >= 0))) {

     if (vlist) for (scalar s = *vlist, *_i57 = vlist; ((scalar *)&s)->i >= 0; s = *++_i57)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]))))).flags & vertex) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]))))).flags & vertex) ?
  (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(s.i)])/2. : ((double)1e30);
   }
 }
# 642 "/Users/weugene/basilisk/src/grid/tree-common.h"
 {
   if (child.x == 1 && child.y == 1 &&
       ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid >= 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1])))).pid >= 0))) {

     if (vlist) for (scalar s = *vlist, *_i56 = vlist; ((scalar *)&s)->i >= 0; s = *++_i56)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]))))).flags & vertex) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]))))).flags & vertex)
  && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]))))).flags & vertex) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]))))).flags & vertex) ?
  (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.i)])/4. : ((double)1e30);
   }
   else if (child.z == -1 && child.y == -1 && child.x == 1 &&
     ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid >= 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1])))).pid >= 0) ||
      (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0])))).pid >= 0) ||
      (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1])))).pid >= 0))) {

     if (vlist) for (scalar s = *vlist, *_i57 = vlist; ((scalar *)&s)->i >= 0; s = *++_i57)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]))))).flags & vertex) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]))))).flags & vertex) ?
  (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)])/2. : ((double)1e30);
   }
 }}
    } } } } } }; }

  free(vlist);

  if (listdef || listc) {
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b, list2, depth); };
    for (int l = depth - 1; l >= 0; l--) {
       { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {{
# 668 "/Users/weugene/basilisk/src/grid/tree-common.h"
 {
 if (listdef) for (scalar s = *listdef, *_i58 = listdef; ((scalar *)&s)->i >= 0; s = *++_i58)
   restriction_average (point, s);
 if (listc) for (scalar s = *listc, *_i59 = listc; ((scalar *)&s)->i >= 0; s = *++_i59)
   _attribute[s.i].restriction (point, s);
      } } } } } }; }}; }
      { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b, list2, l); };
    }
    free(listdef);
    free(listc);
    free(list2);
  }

  scalar * listr = ((void*)0);
  vector * listf = ((void*)0);
  if (list) for (scalar s = *list, *_i60 = list; ((scalar *)&s)->i >= 0; s = *++_i60)
    if (!((s).i >= 65536) && _attribute[s.i].refine != no_restriction) {
      if (_attribute[s.i].face)
 listf = vectors_add (listf, _attribute[s.i].v);
      else
 listr = list_add (listr, s);
    }

  if (listr || listf) {
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list, 0); };
    for (int i = 0; i < depth; i++) {
       { { if (i <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _cache = ((Tree *)grid)->prolongation[i]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = i; int _k; for (_k = 0; _k < _cache.n; _k++) { point.i = _cache.p[_k].i; point.j = _cache.p[_k].j; point.k = _cache.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 694 "/Users/weugene/basilisk/src/grid/tree-common.h"
 {
 if (listr) for (scalar s = *listr, *_i61 = listr; ((scalar *)&s)->i >= 0; s = *++_i61)
          _attribute[s.i].prolongation (point, s);
 if (listf) for (vector v = *listf, *_i62 = listf; ((scalar *)&v)->i >= 0; v = *++_i62)
   {
# 698 "/Users/weugene/basilisk/src/grid/tree-common.h"

     _attribute[v.x.i].prolongation (point, v.x);
# 698 "/Users/weugene/basilisk/src/grid/tree-common.h"

     _attribute[v.y.i].prolongation (point, v.y);
# 698 "/Users/weugene/basilisk/src/grid/tree-common.h"

     _attribute[v.z.i].prolongation (point, v.z);}
      } } } } }; }}; }
      { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list, i + 1); };
    }
    free(listr);
    free(listf);
  }
}

double treex (Point point) { int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 708 "/Users/weugene/basilisk/src/grid/tree-common.h"

  if (level == 0)
    return 0;




  (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree-common.h", 715, "false") : (void)0);
  double i = 0;

  return treex(parent) + i/(1 << 2*(level - 1));
}

double treey (Point point) { int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 721 "/Users/weugene/basilisk/src/grid/tree-common.h"

  if (level == 0)
    return 0;
  return treey(parent) + 4./(1 << 2*(level - 1));
}

void output_tree (FILE * fp)
{
   { { Point root = {2,2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 729 "/Users/weugene/basilisk/src/grid/tree-common.h"

    if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors)
       { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
 if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0))
   fprintf (fp, "%g %g\n%g %g\n\n",
     treex(parent), treey(parent), treex(point), treey(point)); } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }; } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
}

void tree_check()
{


  long nleaves = 0, nactive = 0;
   { { Point root = {0}; for (root.i = 2*Period.x; root.i <= 2*(2 - Period.x); root.i++) for (root.j = 2*Period.y; root.j <= 2*(2 - Period.y); root.j++) for (root.k = 2*Period.z; root.k <= 2*(2 - Period.z); root.k++) { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 742 "/Users/weugene/basilisk/src/grid/tree-common.h"
 {
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {
      (__builtin_expect(!((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid >= 0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree-common.h", 744, "cell.pid >= 0") : (void)0);
      nleaves++;
    }
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0))
      (__builtin_expect(!((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & active) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid >= 0)), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree-common.h", 748, "is_active(cell) || (!is_leaf(cell) && !cell.neighbors && cell.pid >= 0)") : (void)0);
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & active))
      nactive++;

    int neighbors = 0;
     { { int _nn = 1 + 0 ? 1 + 0 : 2; int _i = point.i, _j = point.j, _k = point.k; for (int _l = - _nn; _l <= _nn; _l++) { point.i = _i + _l; for (int _m = - _nn; _m <= _nn; _m++) { point.j = _j + _m; for (int _n = - _nn; _n <= _nn; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
      if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) && (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid >= 0))
 neighbors++; } } } point.i = _i; point.j = _j; point.k = _k;}; }
    (__builtin_expect(!((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors == neighbors), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree-common.h", 756, "cell.neighbors == neighbors") : (void)0);


    if (!(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).neighbors)
      (__builtin_expect(!(!(level < (grid->depth) && point.i > 0 && point.i <= (1 << level) + 2 && point.j > 0 && point.j <= (1 << level) + 2 && point.k > 0 && point.k <= (1 << level) + 2 && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0][2*point.j-2 +0] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0][2*point.j-2 +0] [2*point.k-2 +0])), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree-common.h", 760, "!allocated_child(0,0,0)") : (void)0);
  } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }


  long reachable = 0;
   { { Point root = {2,2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 765 "/Users/weugene/basilisk/src/grid/tree-common.h"
 {
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & active))
      reachable++;
    else
      continue;
  } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
  (__builtin_expect(!(nactive == reachable), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree-common.h", 771, "nactive == reachable") : (void)0);


  reachable = 0;
   { { Point root = {2,2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 775 "/Users/weugene/basilisk/src/grid/tree-common.h"

    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {
      reachable++;
      continue;
    } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
  (__builtin_expect(!(nleaves == reachable), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree-common.h", 780, "nleaves == reachable") : (void)0);
}

static void tree_restriction (scalar * list) {
  if (tree_is_full())
    multigrid_restriction (list);

}

void tree_methods()
{
  multigrid_methods();
  init_scalar = tree_init_scalar;
  init_vertex_scalar = tree_init_vertex_scalar;
  init_face_vector = tree_init_face_vector;
  boundary_level = tree_boundary_level;
  boundary_flux = halo_flux;
  restriction = tree_restriction;
}
# 1789 "/Users/weugene/basilisk/src/grid/tree.h"


void tree_periodic (int dir)
{
  int depth = grid ? (grid->depth) : -1;
  if (grid)
    free_grid();
  periodic (dir);
  if (depth >= 0)
    init_grid (1 << depth);
}
# 3686 "/Users/weugene/basilisk/src/grid/tree.h"
void mpi_boundary_refine (scalar * list){}
void mpi_boundary_coarsen (int a, int b){}
void mpi_boundary_update (scalar * list) {
  boundary (list);
}
# 4 "/Users/weugene/basilisk/src/grid/octree.h"

void octree_methods() {
  tree_methods();
}
# 19 "tube_bp_rel.c"
# 1 "./centered-weugene.h"
# 1 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
# 35 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
# 1 "./run.h"
# 1 "/Users/weugene/basilisk/src/run.h"








double dt = 1.;
# 1 "./utils.h"
# 1 "/Users/weugene/basilisk/src/utils.h"







double DT = 1e10, CFL = 0.5;




struct {

  long nc;

  long tnc;

  double t;

  double speed;

  timer gt;
} perf;





void update_perf() {
  perf.nc += grid->n;
  perf.tnc += grid->tn;
  perf.t = timer_elapsed (perf.gt);
  perf.speed = perf.tnc/perf.t;
}






typedef struct {
  double cpu;
  double real;
  double speed;
  double min;
  double avg;
  double max;
  size_t tnc;
  long mem;
} timing;






timing timer_timing (timer t, int i, size_t tnc, double * mpi)
{
  timing s;



  clock_t end = clock();
  s.cpu = ((double) (end - t.c))/1000000;
  s.real = timer_elapsed (t);
  if (tnc == 0) {
    double n = 0;
     {


                  {
double _n = n;
# 69 "/Users/weugene/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 69 "/Users/weugene/basilisk/src/utils.h"
 _n++; } } } }; n += _n;
                                  ;



}
# 69 "/Users/weugene/basilisk/src/utils.h"
 }
    s.tnc = n;
    tnc = n*i;
  }
  else
    s.tnc = tnc;





  s.mem = 0;
# 95 "/Users/weugene/basilisk/src/utils.h"
  s.min = s.max = s.avg = 0.;

  s.speed = s.real > 0. ? tnc/s.real : -1.;
  return s;
}




void timer_print (timer t, int i, size_t tnc)
{
  timing s = timer_timing (t, i, tnc, ((void*)0));
  fprintf (__stdoutp,
    "\n# " "Octree"
    ", %d steps, %g CPU, %.4g real, %.3g points.step/s, %d var\n",
    i, s.cpu, s.real, s.speed, (int) (datasize/sizeof(double)));
# 120 "/Users/weugene/basilisk/src/utils.h"
}







typedef struct {
  double avg, rms, max, volume;
} norm;

norm normf (scalar f)
{
  double avg = 0., rms = 0., max = 0., volume = 0.;
   {


                  {
double _max = max; double _avg = avg; double _rms = rms; double _volume = volume;
# 135 "/Users/weugene/basilisk/src/utils.h"

if (!((cm).i >= 65536)) {
# 135 "/Users/weugene/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 136 "/Users/weugene/basilisk/src/utils.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] != ((double)1e30) && (((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)]) > 0.) {
      double v = fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]);
      if (v > _max) _max = v;
      _volume += (((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)]);
      _avg += (((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)])*v;
      _rms += (((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)])*((v)*(v));
    } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 135 "/Users/weugene/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 136 "/Users/weugene/basilisk/src/utils.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] != ((double)1e30) && (((Delta)*(Delta)*(Delta))*_const_cm) > 0.) {
      double v = fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]);
      if (v > _max) _max = v;
      _volume += (((Delta)*(Delta)*(Delta))*_const_cm);
      _avg += (((Delta)*(Delta)*(Delta))*_const_cm)*v;
      _rms += (((Delta)*(Delta)*(Delta))*_const_cm)*((v)*(v));
    } } } } }; } if (_max > max) max = _max;
                                    ;
                  avg += _avg;
                                    ;
                  rms += _rms;
                                    ;
                  volume += _volume;
                                       ;



}
# 143 "/Users/weugene/basilisk/src/utils.h"
 }
  norm n;
  n.avg = volume ? avg/volume : 0.;
  n.rms = volume ? sqrt(rms/volume) : 0.;
  n.max = max;
  n.volume = volume;
  return n;
}





typedef struct {
  double min, max, sum, stddev, volume;
} stats;

stats statsf (scalar f)
{
  double min = 1e100, max = -1e100, sum = 0., sum2 = 0., volume = 0.;
   {


                  {
double _sum = sum; double _sum2 = sum2; double _volume = volume; double _max = max; double _min = min;
# 163 "/Users/weugene/basilisk/src/utils.h"

if (!((cm).i >= 65536)) {
# 163 "/Users/weugene/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 164 "/Users/weugene/basilisk/src/utils.h"

    if ((((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)]) > 0. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] != ((double)1e30)) {
      _volume += (((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)]);
      _sum += (((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)];
      _sum2 += (((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)])*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]));
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] > _max) _max = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)];
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] < _min) _min = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)];
    } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 163 "/Users/weugene/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 164 "/Users/weugene/basilisk/src/utils.h"

    if ((((Delta)*(Delta)*(Delta))*_const_cm) > 0. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] != ((double)1e30)) {
      _volume += (((Delta)*(Delta)*(Delta))*_const_cm);
      _sum += (((Delta)*(Delta)*(Delta))*_const_cm)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)];
      _sum2 += (((Delta)*(Delta)*(Delta))*_const_cm)*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]));
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] > _max) _max = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)];
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] < _min) _min = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)];
    } } } } }; } sum += _sum;
                                    ;
                  sum2 += _sum2;
                                     ;
                  volume += _volume;
                                       ;
                  if (_max > max) max = _max;
                                    ;
                  if (_min < min) min = _min;
                                    ;



}
# 171 "/Users/weugene/basilisk/src/utils.h"
 }
  stats s;
  s.min = min, s.max = max, s.sum = sum, s.volume = volume;
  if (volume > 0.)
    sum2 -= sum*sum/volume;
  s.stddev = sum2 > 0. ? sqrt(sum2/volume) : 0.;
  return s;
}
# 187 "/Users/weugene/basilisk/src/utils.h"
static double generic_limiter (double r, double beta)
{
  double v1 = ((r) < (beta) ? (r) : (beta)), v2 = ((beta*r) < (1.) ? (beta*r) : (1.));
  v1 = ((0.) > (v1) ? (0.) : (v1));
  return ((v1) > (v2) ? (v1) : (v2));
}

double minmod (double s0, double s1, double s2) {
  return s1 == s0 ? 0. : generic_limiter ((s2 - s1)/(s1 - s0), 1.)*(s1 - s0);
}

double superbee (double s0, double s1, double s2) {
  return s1 == s0 ? 0. : generic_limiter ((s2 - s1)/(s1 - s0), 2.)*(s1 - s0);
}

double sweby (double s0, double s1, double s2) {
  return s1 == s0 ? 0. : generic_limiter ((s2 - s1)/(s1 - s0), 1.5)*(s1 - s0);
}
# 213 "/Users/weugene/basilisk/src/utils.h"
double theta = 1.3;

double minmod2 (double s0, double s1, double s2)
{
  if (s0 < s1 && s1 < s2) {
    double d1 = theta*(s1 - s0), d2 = (s2 - s0)/2., d3 = theta*(s2 - s1);
    if (d2 < d1) d1 = d2;
    return ((d1) < (d3) ? (d1) : (d3));
  }
  if (s0 > s1 && s1 > s2) {
    double d1 = theta*(s1 - s0), d2 = (s2 - s0)/2., d3 = theta*(s2 - s1);
    if (d2 > d1) d1 = d2;
    return ((d1) > (d3) ? (d1) : (d3));
  }
  return 0.;
}
# 237 "/Users/weugene/basilisk/src/utils.h"
void gradients (scalar * f, vector * g)
{
  (__builtin_expect(!(list_len(f) == vectors_len(g)), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/utils.h", 239, "list_len(f) == vectors_len(g)") : (void)0);
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 240 "/Users/weugene/basilisk/src/utils.h"
 {
    scalar s; vector v;
    scalar * _i0 = f; vector * _i1 = g; if (f) for (s = *f, v = *g; ((scalar *)&s)->i >= 0; s = *++_i0, v = *++_i1) {
      if (_attribute[s.i].gradient)
 {
# 244 "/Users/weugene/basilisk/src/utils.h"
 {





     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)] = _attribute[s.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)])/Delta;
 }
# 244 "/Users/weugene/basilisk/src/utils.h"
 {





     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)] = _attribute[s.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(s.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.i)])/Delta;
 }
# 244 "/Users/weugene/basilisk/src/utils.h"
 {





     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)] = _attribute[s.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(s.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(s.i)])/Delta;
 }}
      else
 {
# 253 "/Users/weugene/basilisk/src/utils.h"
 {





     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)])/(2.*Delta);
 }
# 253 "/Users/weugene/basilisk/src/utils.h"
 {





     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(s.i)])/(2.*Delta);
 }
# 253 "/Users/weugene/basilisk/src/utils.h"
 {





     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(s.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(s.i)])/(2.*Delta);
 }}
    }
  } } } } }; }
  boundary ((scalar *) g);
}
# 275 "/Users/weugene/basilisk/src/utils.h"
void vorticity (const vector u, scalar omega)
{
  struct { double x, y; } a = {1., -1.};
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 278 "/Users/weugene/basilisk/src/utils.h"
 {
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(omega.i)] = 0.;
    {
# 280 "/Users/weugene/basilisk/src/utils.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(omega.i)] += a.x*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/(2.*Delta));
# 280 "/Users/weugene/basilisk/src/utils.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(omega.i)] += a.y*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/(2.*Delta));}
  } } } } }; }
  boundary (((scalar []){omega,{-1}}));
}





double change (scalar s, scalar sn)
{
  double max = 0.;
   {


                  {
double _max = max;
# 293 "/Users/weugene/basilisk/src/utils.h"

if (!((cm).i >= 65536)) {
# 293 "/Users/weugene/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 293 "/Users/weugene/basilisk/src/utils.h"
 {
    if ((((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)]) > 0.) {
      double ds = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(sn.i)]);
      if (ds > _max)
 _max = ds;
    }
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(sn.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)];
  } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 293 "/Users/weugene/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 293 "/Users/weugene/basilisk/src/utils.h"
 {
    if ((((Delta)*(Delta)*(Delta))*_const_cm) > 0.) {
      double ds = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(sn.i)]);
      if (ds > _max)
 _max = ds;
    }
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(sn.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)];
  } } } } }; } if (_max > max) max = _max;
                                    ;



}
# 300 "/Users/weugene/basilisk/src/utils.h"
 }
  return max;
}





scalar lookup_field (const char * name)
{
  if (name)
    if (all) for (scalar s = *all, *_i72 = all; ((scalar *)&s)->i >= 0; s = *++_i72)
      if (!strcmp (_attribute[s.i].name, name))
 return s;
  return (scalar){-1};
}

vector lookup_vector (const char * name)
{
  if (name) {
    char component[strlen(name) + 3];
    __builtin___strcpy_chk (component, name, __builtin_object_size (component, 2 > 1 ? 1 : 0));
    __builtin___strcat_chk (component, ".x", __builtin_object_size (component, 2 > 1 ? 1 : 0));
    if (all) for (scalar s = *all, *_i73 = all; ((scalar *)&s)->i >= 0; s = *++_i73)
      if (!strcmp (_attribute[s.i].name, component))
 return _attribute[s.i].v;
  }
  return (vector){{-1}};
}
# 362 "/Users/weugene/basilisk/src/utils.h"
# 1 "./output.h"
# 1 "/Users/weugene/basilisk/src/output.h"
# 37 "/Users/weugene/basilisk/src/output.h"
struct OutputField {
  scalar * list;
  FILE * fp;
  int n;
  _Bool linear;
  double box[2][2];
};


void output_field (struct OutputField p)
{ ;
  if (!p.list) p.list = all;
  if (p.n == 0) p.n = N;
  if (!p.fp) p.fp = __stdoutp;
  p.n++;
  if (p.box[0][0] == 0. && p.box[0][1] == 0. &&
      p.box[1][0] == 0. && p.box[1][1] == 0.) {
    p.box[0][0] = X0; p.box[0][1] = Y0;
    p.box[1][0] = X0 + L0; p.box[1][1] = Y0 + L0;
  }

  int len = list_len(p.list);
  double Delta = 0.999999*(p.box[1][0] - p.box[0][0])/(p.n - 1);
  int ny = (p.box[1][1] - p.box[0][1])/Delta + 1;
  double ** field = (double **) matrix_new (p.n, ny, len*sizeof(double));
  for (int i = 0; i < p.n; i++) {
    double x = Delta*i + p.box[0][0];
    for (int j = 0; j < ny; j++) {
      double y = Delta*j + p.box[0][1];
      if (p.linear) {
 int k = 0;
 if (p.list) for (scalar s = *p.list, *_i74 = p.list; ((scalar *)&s)->i >= 0; s = *++_i74)
   field[i][len*j + k++] = interpolate ((struct _interpolate){s, x, y});
      }
      else {
 Point point = locate ((struct _locate){x, y}); int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 72 "/Users/weugene/basilisk/src/output.h"

 int k = 0;
 if (p.list) for (scalar s = *p.list, *_i75 = p.list; ((scalar *)&s)->i >= 0; s = *++_i75)
   field[i][len*j + k++] = point.level >= 0 ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] : ((double)1e30);
      }
    }
  }

  if (0 == 0) {




    fprintf (p.fp, "# 1:x 2:y");
    int i = 3;
    if (p.list) for (scalar s = *p.list, *_i76 = p.list; ((scalar *)&s)->i >= 0; s = *++_i76)
      fprintf (p.fp, " %d:%s", i++, _attribute[s.i].name);
    fputc('\n', p.fp);
    for (int i = 0; i < p.n; i++) {
      double x = Delta*i + p.box[0][0];
      for (int j = 0; j < ny; j++) {
 double y = Delta*j + p.box[0][1];

 fprintf (p.fp, "%g %g", x, y);
 int k = 0;
 if (p.list) for (scalar s = *p.list, *_i77 = p.list; ((scalar *)&s)->i >= 0; s = *++_i77)
   fprintf (p.fp, " %g", field[i][len*j + k++]);
 fputc ('\n', p.fp);
      }
      fputc ('\n', p.fp);
    }
    fflush (p.fp);
  }






  matrix_free (field);
                                                                       ; }
# 140 "/Users/weugene/basilisk/src/output.h"
struct OutputMatrix {
  scalar f;
  FILE * fp;
  int n;
  _Bool linear;
};


void output_matrix (struct OutputMatrix p)
{ ;
  if (p.n == 0) p.n = N;
  if (!p.fp) p.fp = __stdoutp;
  float fn = p.n;
  float Delta = (float) L0/fn;
  fwrite (&fn, sizeof(float), 1, p.fp);
  for (int j = 0; j < p.n; j++) {
    float yp = (float) (Delta*j + X0 + Delta/2.);
    fwrite (&yp, sizeof(float), 1, p.fp);
  }
  for (int i = 0; i < p.n; i++) {
    float xp = (float) (Delta*i + X0 + Delta/2.);
    fwrite (&xp, sizeof(float), 1, p.fp);
    for (int j = 0; j < p.n; j++) {
      float yp = (float)(Delta*j + Y0 + Delta/2.), v;
      if (p.linear)
 v = interpolate ((struct _interpolate){p.f, xp, yp});
      else {
 Point point = locate ((struct _locate){xp, yp}); int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 167 "/Users/weugene/basilisk/src/output.h"

 (__builtin_expect(!(point.level >= 0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/output.h", 168, "point.level >= 0") : (void)0);
 v = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.f.i)];
      }
      fwrite (&v, sizeof(float), 1, p.fp);
    }
  }
  fflush (p.fp);
                                                                        ; }
# 184 "/Users/weugene/basilisk/src/output.h"
typedef void (* colormap) (double cmap[127][3]);

void jet (double cmap[127][3])
{
  for (int i = 0; i < 127; i++) {
    cmap[i][0] =
      i <= 46 ? 0. :
      i >= 111 ? -0.03125*(i - 111) + 1. :
      i >= 78 ? 1. :
      0.03125*(i - 46);
    cmap[i][1] =
      i <= 14 || i >= 111 ? 0. :
      i >= 79 ? -0.03125*(i - 111) :
      i <= 46 ? 0.03125*(i - 14) :
      1.;
    cmap[i][2] =
      i >= 79 ? 0. :
      i >= 47 ? -0.03125*(i - 79) :
      i <= 14 ? 0.03125*(i - 14) + 1.:
      1.;
  }
}

void cool_warm (double cmap[127][3])
{






  static double basemap[33][3] = {
    {0.2298057, 0.298717966, 0.753683153},
    {0.26623388, 0.353094838, 0.801466763},
    {0.30386891, 0.406535296, 0.84495867},
    {0.342804478, 0.458757618, 0.883725899},
    {0.38301334, 0.50941904, 0.917387822},
    {0.424369608, 0.558148092, 0.945619588},
    {0.46666708, 0.604562568, 0.968154911},
    {0.509635204, 0.648280772, 0.98478814},
    {0.552953156, 0.688929332, 0.995375608},
    {0.596262162, 0.726149107, 0.999836203},
    {0.639176211, 0.759599947, 0.998151185},
    {0.681291281, 0.788964712, 0.990363227},
    {0.722193294, 0.813952739, 0.976574709},
    {0.761464949, 0.834302879, 0.956945269},
    {0.798691636, 0.849786142, 0.931688648},
    {0.833466556, 0.860207984, 0.901068838},
    {0.865395197, 0.86541021, 0.865395561},
    {0.897787179, 0.848937047, 0.820880546},
    {0.924127593, 0.827384882, 0.774508472},
    {0.944468518, 0.800927443, 0.726736146},
    {0.958852946, 0.769767752, 0.678007945},
    {0.96732803, 0.734132809, 0.628751763},
    {0.969954137, 0.694266682, 0.579375448},
    {0.966811177, 0.650421156, 0.530263762},
    {0.958003065, 0.602842431, 0.481775914},
    {0.943660866, 0.551750968, 0.434243684},
    {0.923944917, 0.49730856, 0.387970225},
    {0.89904617, 0.439559467, 0.343229596},
    {0.869186849, 0.378313092, 0.300267182},
    {0.834620542, 0.312874446, 0.259301199},
    {0.795631745, 0.24128379, 0.220525627},
    {0.752534934, 0.157246067, 0.184115123},
    {0.705673158, 0.01555616, 0.150232812}
  };

  for (int i = 0; i < 127; i++) {
    double x = i*(32 - 1e-10)/(127 - 1);
    int j = x; x -= j;
    for (int k = 0; k < 3; k++)
      cmap[i][k] = (1. - x)*basemap[j][k] + x*basemap[j+1][k];
  }
}

void gray (double cmap[127][3])
{
  for (int i = 0; i < 127; i++)
    for (int k = 0; k < 3; k++)
      cmap[i][k] = i/(127 - 1.);
}

void randomap (double cmap[127][3])
{
  srand(0);
  for (int i = 0; i < 127; i++)
    for (int k = 0; k < 3; k++)
      cmap[i][k] = ((1. - 2.*rand()/(double)0x7fffffff) + 1.)/2.;
}





typedef struct {
  unsigned char r, g, b;
} color;

color colormap_color (double cmap[127][3],
        double val, double min, double max)
{
  color c;
  if (val == ((double)1e30)) {
    c.r = c.g = c.b = 0;
    return c;
  }
  int i;
  double coef;
  if (max != min)
    val = (val - min)/(max - min);
  else
    val = 0.;
  if (val <= 0.) i = 0, coef = 0.;
  else if (val >= 1.) i = 127 - 2, coef = 1.;
  else {
    i = val*(127 - 1);
    coef = val*(127 - 1) - i;
  }
  (__builtin_expect(!(i < 127 - 1), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/output.h", 302, "i < 127 - 1") : (void)0);
  unsigned char * c1 = (unsigned char *) &c;
  for (int j = 0; j < 3; j++)
    c1[j] = 255*(cmap[i][j]*(1. - coef) + cmap[i + 1][j]*coef);
  return c;
}
# 321 "/Users/weugene/basilisk/src/output.h"
static const char * extension (const char * file, const char * ext) {
  int len = strlen(file);
  return len > 4 && !strcmp (file + len - 4, ext) ? file + len - 4 : ((void*)0);
}

static const char * is_animation (const char * file) {
  const char * ext;
  if ((ext = extension (file, ".mp4")) ||
      (ext = extension (file, ".ogv")) ||
      (ext = extension (file, ".gif")))
    return ext;
  return ((void*)0);
}

static struct {
  FILE ** fp;
  char ** names;
  int n;
} open_image_data = {((void*)0), ((void*)0), 0};

static void open_image_cleanup()
{
  for (int i = 0; i < open_image_data.n; i++) {
    qpclose (open_image_data.fp[i]);
    free(open_image_data.names[i]);
  }
  free(open_image_data.fp);
  free(open_image_data.names);
  open_image_data.fp = ((void*)0);
  open_image_data.names = ((void*)0);
  open_image_data.n = 0;
}

static FILE * open_image_lookup (const char * file)
{
  for (int i = 0; i < open_image_data.n; i++)
    if (!strcmp (file, open_image_data.names[i]))
      return open_image_data.fp[i];
  return ((void*)0);
}

static _Bool which (const char * command)
{
  char * s = getenv ("PATH");
  if (!s)
    return 0;
  char path[strlen(s) + 1];
  __builtin___strcpy_chk (path, s, __builtin_object_size (path, 2 > 1 ? 1 : 0));
  s = strtok (path, ":");
  while (s) {
    char f[strlen(s) + strlen(command) + 2];
    __builtin___strcpy_chk (f, s, __builtin_object_size (f, 2 > 1 ? 1 : 0));
    __builtin___strcat_chk (f, "/", __builtin_object_size (f, 2 > 1 ? 1 : 0));
    __builtin___strcat_chk (f, command, __builtin_object_size (f, 2 > 1 ? 1 : 0));
    FILE * fp = fopen (f, "r");
    if (fp) {
      fclose (fp);
      return 1;
    }
    s = strtok (((void*)0), ":");
  }
  return 0;
}

static FILE * ppm_fallback (const char * file, const char * mode)
{
  char filename[strlen(file) + 5];
  __builtin___strcpy_chk (filename, file, __builtin_object_size (filename, 2 > 1 ? 1 : 0));
  __builtin___strcat_chk (filename, ".ppm", __builtin_object_size (filename, 2 > 1 ? 1 : 0));
  FILE * fp = fopen (filename, mode);
  if (!fp) {
    perror (file);



    exit (1);
  }
  return fp;
}

FILE * open_image (const char * file, const char * options)
{
  (__builtin_expect(!(0 == 0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/output.h", 403, "pid() == 0") : (void)0);
  const char * ext;
  if ((ext = is_animation (file))) {
    FILE * fp = open_image_lookup (file);
    if (fp)
      return fp;

    int len = strlen ("ppm2???    ") + strlen (file) +
      (options ? strlen (options) : 0);
    char command[len];
    __builtin___strcpy_chk (command, "ppm2", __builtin_object_size (command, 2 > 1 ? 1 : 0)); __builtin___strcat_chk (command, ext + 1, __builtin_object_size (command, 2 > 1 ? 1 : 0));

    static int has_ffmpeg = -1;
    if (has_ffmpeg < 0) {
      if (which (command) && (which ("ffmpeg") || which ("avconv")))
 has_ffmpeg = 1;
      else {
 fprintf (__stderrp,
   "open_image(): cannot find '%s' or 'ffmpeg'/'avconv'\n"
   "  falling back to raw PPM outputs\n", command);
 has_ffmpeg = 0;
      }
    }
    if (!has_ffmpeg)
      return ppm_fallback (file, "a");

    static _Bool added = 0;
    if (!added) {
      free_solver_func_add (open_image_cleanup);
      added = 1;
    }
    open_image_data.n++;
    open_image_data.names = (char * *) realloc(open_image_data.names,(open_image_data.n)*sizeof(char *));
    open_image_data.names[open_image_data.n - 1] = strdup(file);

    if (options) {
      __builtin___strcat_chk (command, " ", __builtin_object_size (command, 2 > 1 ? 1 : 0));
      __builtin___strcat_chk (command, options, __builtin_object_size (command, 2 > 1 ? 1 : 0));
    }
    __builtin___strcat_chk (command, !strcmp (ext, ".mp4") ? " " : " > ", __builtin_object_size (command, 2 > 1 ? 1 : 0));
    __builtin___strcat_chk (command, file, __builtin_object_size (command, 2 > 1 ? 1 : 0));
    open_image_data.fp = (FILE * *) realloc(open_image_data.fp,(open_image_data.n)*sizeof(FILE *));
    return open_image_data.fp[open_image_data.n - 1] = qpopen (command, "w");
  }
  else {
    static int has_convert = -1;
    if (has_convert < 0) {
      if (which ("convert"))
 has_convert = 1;
      else {
 fprintf (__stderrp,
   "open_image(): cannot find 'convert'\n"
   "  falling back to raw PPM outputs\n");
 has_convert = 0;
      }
    }
    if (!has_convert)
      return ppm_fallback (file, "w");

    int len = strlen ("convert ppm:-   ") + strlen (file) +
      (options ? strlen (options) : 0);
    char command[len];
    __builtin___strcpy_chk (command, "convert ppm:- ", __builtin_object_size (command, 2 > 1 ? 1 : 0));
    if (options) {
      __builtin___strcat_chk (command, options, __builtin_object_size (command, 2 > 1 ? 1 : 0));
      __builtin___strcat_chk (command, " ", __builtin_object_size (command, 2 > 1 ? 1 : 0));
    }
    __builtin___strcat_chk (command, file, __builtin_object_size (command, 2 > 1 ? 1 : 0));
    return qpopen (command, "w");
  }
}

void close_image (const char * file, FILE * fp)
{
  (__builtin_expect(!(0 == 0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/output.h", 477, "pid() == 0") : (void)0);
  if (is_animation (file)) {
    if (!open_image_lookup (file))
      fclose (fp);
  }
  else if (which ("convert"))
    qpclose (fp);
  else
    fclose (fp);
}
# 552 "/Users/weugene/basilisk/src/output.h"
struct OutputPPM {
  scalar f;
  FILE * fp;
  int n;
  char * file;
  double min, max, spread, z;
  _Bool linear;
  double box[2][2];
  scalar mask;
  colormap map;
  char * opt;
};


void output_ppm (struct OutputPPM p)
{ ;

  if (p.n == 0) p.n = N;
  if (p.min == 0 && p.max == 0) {
    stats s = statsf (p.f);
    if (p.spread < 0.)
      p.min = s.min, p.max = s.max;
    else {
      double avg = s.sum/s.volume, spread = (p.spread ? p.spread : 5.)*s.stddev;
      p.min = avg - spread; p.max = avg + spread;
    }
  }
  if (p.box[0][0] == 0. && p.box[0][1] == 0. &&
      p.box[1][0] == 0. && p.box[1][1] == 0.) {
    p.box[0][0] = X0; p.box[0][1] = Y0;
    p.box[1][0] = X0 + L0; p.box[1][1] = Y0 + L0;
  }
  if (!p.map)
    p.map = jet;

  double fn = p.n;
  double Delta = (p.box[1][0] - p.box[0][0])/fn;
  int ny = (p.box[1][1] - p.box[0][1])/Delta;
  if (ny % 2) ny++;

  color ** ppm = (color **) matrix_new (ny, p.n, sizeof(color));
  double cmap[127][3];
  p.map (cmap);
                 {

      for (int j = 0; j < ny; j++) {
 double yp = Delta*j + p.box[0][1] + Delta/2.;
 for (int i = 0; i < p.n; i++) {
   double xp = Delta*i + p.box[0][0] + Delta/2., v;
   if (p.mask.i) {
     if (p.linear) {
       double m = interpolate ((struct _interpolate){p.mask, xp, yp, p.z});
       if (m < 0.)
  v = ((double)1e30);
       else
  v = interpolate ((struct _interpolate){p.f, xp, yp, p.z});
     }
     else {
       Point point = locate ((struct _locate){xp, yp, p.z}); int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 610 "/Users/weugene/basilisk/src/output.h"

       if (point.level < 0 || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.mask.i)] < 0.)
  v = ((double)1e30);
       else
  v = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.f.i)];
     }
   }
   else if (p.linear)
     v = interpolate ((struct _interpolate){p.f, xp, yp, p.z});
   else {
     Point point = locate ((struct _locate){xp, yp, p.z}); int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 620 "/Users/weugene/basilisk/src/output.h"

     v = point.level >= 0 ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.f.i)] : ((double)1e30);
   }
   ppm[ny - 1 - j][i] = colormap_color (cmap, v, p.min, p.max);
 }
      }
  }

  if (0 == 0) {




    if (!p.fp) p.fp = __stdoutp;
    if (p.file)
      p.fp = open_image (p.file, p.opt);

    fprintf (p.fp, "P6\n%u %u 255\n", p.n, ny);
    fwrite (((void **) ppm)[0], sizeof(color), ny*p.n, p.fp);

    if (p.file)
      close_image (p.file, p.fp);
    else
      fflush (p.fp);
  }






  matrix_free (ppm);
                                                                     ; }
# 684 "/Users/weugene/basilisk/src/output.h"
struct OutputGRD {
  scalar f;
  FILE * fp;
  double Delta;
  _Bool linear;
  double box[2][2];
  scalar mask;
};


void output_grd (struct OutputGRD p)
{ ;

  if (!p.fp) p.fp = __stdoutp;
  if (p.box[0][0] == 0. && p.box[0][1] == 0. &&
      p.box[1][0] == 0. && p.box[1][1] == 0.) {
    p.box[0][0] = X0; p.box[0][1] = Y0;
    p.box[1][0] = X0 + L0; p.box[1][1] = Y0 + L0;
    if (p.Delta == 0) p.Delta = L0/N;
  }

  double Delta = p.Delta;
  int nx = (p.box[1][0] - p.box[0][0])/Delta;
  int ny = (p.box[1][1] - p.box[0][1])/Delta;


  fprintf (p.fp, "ncols          %d\n", nx);
  fprintf (p.fp, "nrows          %d\n", ny);
  fprintf (p.fp, "xllcorner      %g\n", p.box[0][0]);
  fprintf (p.fp, "yllcorner      %g\n", p.box[0][1]);
  fprintf (p.fp, "cellsize       %g\n", Delta);
  fprintf (p.fp, "nodata_value   -9999\n");


  for (int j = ny-1; j >= 0; j--) {
    double yp = Delta*j + p.box[0][1] + Delta/2.;
    for (int i = 0; i < nx; i++) {
      double xp = Delta*i + p.box[0][0] + Delta/2., v;
      if (p.mask.i) {
 if (p.linear) {
   double m = interpolate ((struct _interpolate){p.mask, xp, yp});
   if (m < 0.)
     v = ((double)1e30);
   else
     v = interpolate ((struct _interpolate){p.f, xp, yp});
 }
 else {
   Point point = locate ((struct _locate){xp, yp}); int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 731 "/Users/weugene/basilisk/src/output.h"

   if (point.level < 0 || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.mask.i)] < 0.)
     v = ((double)1e30);
   else
     v = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.f.i)];
 }
      }
      else if (p.linear)
 v = interpolate ((struct _interpolate){p.f, xp, yp});
      else {
 Point point = locate ((struct _locate){xp, yp}); int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 741 "/Users/weugene/basilisk/src/output.h"

 v = point.level >= 0 ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.f.i)] : ((double)1e30);
      }
      if (v == ((double)1e30))
 fprintf (p.fp, "-9999 ");
      else
 fprintf (p.fp, "%f ", v);
    }
    fprintf (p.fp, "\n");
  }

  fflush (p.fp);
                                                                     ; }
# 780 "/Users/weugene/basilisk/src/output.h"
struct OutputGfs {
  FILE * fp;
  scalar * list;
  double t;
  char * file;
  _Bool translate;
};

static char * replace (const char * input, int target, int with,
         _Bool translate)
{
  if (translate) {
    if (!strcmp (input, "u.x"))
      return strdup("U");
    if (!strcmp (input, "u.y"))
      return strdup("V");
    if (!strcmp (input, "u.z"))
      return strdup("W");
  }
  char * name = strdup(input), * i = name;
  while (*i != '\0') {
    if (*i == target)
      *i = with;
    i++;
  }
  return name;
}


void output_gfs (struct OutputGfs p)
{ ;
  char * fname = p.file;
# 827 "/Users/weugene/basilisk/src/output.h"
  _Bool opened = 0;
  if (p.fp == ((void*)0)) {
    if (fname == ((void*)0))
      p.fp = __stdoutp;
    else if (!(p.fp = fopen (fname, "w"))) {
      perror (fname);
      exit (1);
    }
    else
      opened = 1;
  }

  scalar * list = p.list ? p.list : list_copy (all);

  restriction (list);
  fprintf (p.fp,
    "1 0 GfsSimulation GfsBox GfsGEdge { binary = 1"
    " x = %g y = %g ",
    0.5 + X0/L0, 0.5 + Y0/L0);

  fprintf (p.fp, "z = %g ", 0.5 + Z0/L0);


  if (list != ((void*)0) && list[0].i != -1) {
    scalar s = list[0];
    char * name = replace (_attribute[s.i].name, '.', '_', p.translate);
    fprintf (p.fp, "variables = %s", name);
    free(name);
    for (int i = 1; i < list_len(list); i++) {
      scalar s = list[i];
      if (_attribute[s.i].name) {
 char * name = replace (_attribute[s.i].name, '.', '_', p.translate);
 fprintf (p.fp, ",%s", name);
 free(name);
      }
    }
    fprintf (p.fp, " ");
  }
  fprintf (p.fp, "} {\n");
  fprintf (p.fp, "  Time { t = %g }\n", t);
  if (L0 != 1.)
    fprintf (p.fp, "  PhysicalParams { L = %g }\n", L0);
  fprintf (p.fp, "  VariableTracerVOF f\n");
  fprintf (p.fp, "}\nGfsBox { x = 0 y = 0 z = 0 } {\n");
# 888 "/Users/weugene/basilisk/src/output.h"
   { { Point root = {2,2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 888 "/Users/weugene/basilisk/src/output.h"
 {



    {






      unsigned flags =
 level == 0 ? 0 :
# 909 "/Users/weugene/basilisk/src/output.h"
 child.x == -1 && child.y == -1 && child.z == -1 ? 0 :
 child.x == -1 && child.y == -1 && child.z == 1 ? 1 :
 child.x == -1 && child.y == 1 && child.z == -1 ? 2 :
 child.x == -1 && child.y == 1 && child.z == 1 ? 3 :
 child.x == 1 && child.y == -1 && child.z == -1 ? 4 :
 child.x == 1 && child.y == -1 && child.z == 1 ? 5 :
 child.x == 1 && child.y == 1 && child.z == -1 ? 6 :
 7;

      if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf))
 flags |= (1 << 4);
      fwrite (&flags, sizeof (unsigned), 1, p.fp);
      double a = -1;
      fwrite (&a, sizeof (double), 1, p.fp);
      if (list) for (scalar s = *list, *_i79 = list; ((scalar *)&s)->i >= 0; s = *++_i79)
 if (_attribute[s.i].name) {
   if (_attribute[s.i].v.x.i >= 0) {




     if (_attribute[s.i].v.x.i == s.i) {
       s = _attribute[s.i].v.y;
       a = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] != ((double)1e30) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] : (double) 1.7976931348623157e+308;
     }
     else if (_attribute[s.i].v.y.i == s.i) {
       s = _attribute[s.i].v.x;
       a = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] != ((double)1e30) ? - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] : (double) 1.7976931348623157e+308;
     }


     else
       a = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] != ((double)1e30) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] : (double) 1.7976931348623157e+308;

   }
   else
     a = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] != ((double)1e30) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] : (double) 1.7976931348623157e+308;
   fwrite (&a, sizeof (double), 1, p.fp);
 }
    }
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf))
      continue;
  } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
# 961 "/Users/weugene/basilisk/src/output.h"
    fputs ("}\n", p.fp);
  fflush (p.fp);

  if (!p.list)
    free(list);
  if (opened)
    fclose (p.fp);
# 986 "/Users/weugene/basilisk/src/output.h"
                                                                     ; }
# 1010 "/Users/weugene/basilisk/src/output.h"
struct Dump {
  char * file;
  scalar * list;
  FILE * fp;
  _Bool unbuffered;
};

struct DumpHeader {
  double t;
  long len;
  int i, depth, npe, version;
  coord n;
};

static const int dump_version =

  170901;

static scalar * dump_list (scalar * lista)
{
  scalar * list = ((cm).i >= 65536) ? ((void*)0) : list_concat (((scalar []){cm,{-1}}), ((void*)0));
  if (lista) for (scalar s = *lista, *_i80 = lista; ((scalar *)&s)->i >= 0; s = *++_i80)
    if (!_attribute[s.i].face && !_attribute[s.i].nodump && s.i != cm.i)
      list = list_add (list, s);
  return list;
}

static void dump_header (FILE * fp, struct DumpHeader * header, scalar * list)
{
  if (fwrite (header, sizeof(struct DumpHeader), 1, fp) < 1) {
    perror ("dump(): error while writing header");
    exit (1);
  }
  if (list) for (scalar s = *list, *_i81 = list; ((scalar *)&s)->i >= 0; s = *++_i81) {
    unsigned len = strlen(_attribute[s.i].name);
    if (fwrite (&len, sizeof(unsigned), 1, fp) < 1) {
      perror ("dump(): error while writing len");
      exit (1);
    }
    if (fwrite (_attribute[s.i].name, sizeof(char), len, fp) < len) {
      perror ("dump(): error while writing s.name");
      exit (1);
    }
  }
  double o[4] = {X0,Y0,Z0,L0};
  if (fwrite (o, sizeof(double), 4, fp) < 4) {
    perror ("dump(): error while writing coordinates");
    exit (1);
  }
}



void dump (struct Dump p)
{ ;
  FILE * fp = p.fp;
  char def[] = "dump", * file = p.file ? p.file : p.fp ? ((void*)0) : def;

  char * name = ((void*)0);
  if (file) {
    name = (char *) malloc(strlen(file) + 2);
    __builtin___strcpy_chk (name, file, __builtin_object_size (name, 2 > 1 ? 1 : 0));
    if (!p.unbuffered)
      __builtin___strcat_chk (name, "~", __builtin_object_size (name, 2 > 1 ? 1 : 0));
    if ((fp = fopen (name, "w")) == ((void*)0)) {
      perror (name);
      exit (1);
    }
  }
  (__builtin_expect(!(fp), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/output.h", 1079, "fp") : (void)0);

  scalar * dlist = dump_list (p.list ? p.list : all);
  scalar size= new_scalar("size");
  scalar * list = list_concat (((scalar []){size,{-1}}), dlist); free(dlist);
  struct DumpHeader header = { t, list_len(list), iter, (grid->depth), 1,
          dump_version };
  dump_header (fp, &header, list);

  subtree_size (size, 0);

   { { Point root = {2,2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 1090 "/Users/weugene/basilisk/src/output.h"
 {
    unsigned flags = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf) ? leaf : 0;
    if (fwrite (&flags, sizeof(unsigned), 1, fp) < 1) {
      perror ("dump(): error while writing flags");
      exit (1);
    }
    if (list) for (scalar s = *list, *_i82 = list; ((scalar *)&s)->i >= 0; s = *++_i82)
      if (fwrite (&((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)], sizeof(double), 1, fp) < 1) {
 perror ("dump(): error while writing scalars");
 exit (1);
      }
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf))
      continue;
  } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }

  free(list);
  if (file) {
    fclose (fp);
    if (!p.unbuffered)
      rename (name, file);
    free(name);
  }
 delete (((scalar []){size,{-1}})); ; }
# 1193 "/Users/weugene/basilisk/src/output.h"
_Bool restore (struct Dump p)
{ ;
  FILE * fp = p.fp;
  char * file = p.file;
  if (file && (fp = fopen (file, "r")) == ((void*)0))
    { _Bool _ret = 0; ; return _ret; }
  (__builtin_expect(!(fp), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/output.h", 1199, "fp") : (void)0);

  struct DumpHeader header;
  if (fread (&header, sizeof(header), 1, fp) < 1) {
    fprintf (__stderrp, "restore(): error: expecting header\n");
    exit (1);
  }


  init_grid (1);
   { { Point root = {2,2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 1206 "/Users/weugene/basilisk/src/output.h"
 {
    (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid = 0;
    (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags |= active;
  } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
  ((Tree *)grid)->dirty = 1;
# 1231 "/Users/weugene/basilisk/src/output.h"
 _Bool restore_all = (p.list == all);
  scalar * list = dump_list (p.list ? p.list : all);
  if (header.version == 161020) {
    if (header.len - 1 != list_len (list)) {
      fprintf (__stderrp,
        "restore(): error: the list lengths don't match: "
        "%ld (file) != %d (code)\n",
        header.len - 1, list_len (list));
      exit (1);
    }
  }
  else {
    if (header.version != dump_version) {
      fprintf (__stderrp,
        "restore(): error: file version mismatch: "
        "%d (file) != %d (code)\n",
        header.version, dump_version);
      exit (1);
    }

    scalar * input = ((void*)0);
    for (int i = 0; i < header.len; i++) {
      unsigned len;
      if (fread (&len, sizeof(unsigned), 1, fp) < 1) {
 fprintf (__stderrp, "restore(): error: expecting len\n");
 exit (1);
      }
      char name[len + 1];
      if (fread (name, sizeof(char), len, fp) < 1) {
 fprintf (__stderrp, "restore(): error: expecting s.name\n");
 exit (1);
      }
      name[len] = '\0';

      if (i > 0) {
 _Bool found = 0;
 if (list) for (scalar s = *list, *_i85 = list; ((scalar *)&s)->i >= 0; s = *++_i85)
   if (!strcmp (_attribute[s.i].name, name)) {
     input = list_append (input, s);
     found = 1; break;
   }
 if (!found) {
   if (restore_all) {
     scalar s = new_scalar("s");
     free(_attribute[s.i].name);
     _attribute[s.i].name = strdup(name);
     input = list_append (input, s);
   }
   else
     input = list_append (input, (scalar){2147483647});
 }
      }
    }
    free(list);
    list = input;

    double o[4];
    if (fread (o, sizeof(double), 4, fp) < 4) {
      fprintf (__stderrp, "restore(): error: expecting coordinates\n");
      exit (1);
    }
    origin ((struct _origin){o[0], o[1], o[2]});
    size (o[3]);
  }
# 1306 "/Users/weugene/basilisk/src/output.h"
 scalar * listm = ((cm).i >= 65536) ? ((void*)0) : (scalar *)((vector []){{fm.x,fm.y,fm.z},{{-1},{-1},{-1}}});



   { { Point root = {2,2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 1310 "/Users/weugene/basilisk/src/output.h"
 {
    unsigned flags;
    if (fread (&flags, sizeof(unsigned), 1, fp) != 1) {
      fprintf (__stderrp, "restore(): error: expecting 'flags'\n");
      exit (1);
    }

    fseek (fp, sizeof(double), 1);
    if (list) for (scalar s = *list, *_i86 = list; ((scalar *)&s)->i >= 0; s = *++_i86) {
      double val;
      if (fread (&val, sizeof(double), 1, fp) != 1) {
 fprintf (__stderrp, "restore(): error: expecting a scalar\n");
 exit (1);
      }
      if (s.i != 2147483647)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = val;
    }
    if (!(flags & leaf) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf))
      refine_cell (point, listm, 0, ((void*)0));
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf))
      continue;
  } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
  boundary (list);

  boundary (listm);

  scalar * other = ((void*)0);
  if (all) for (scalar s = *all, *_i87 = all; ((scalar *)&s)->i >= 0; s = *++_i87)
    if (!list_lookup (list, s) && !list_lookup (listm, s))
      other = list_append (other, s);
  reset (other, 0.);
  free(other);

  free(list);
  if (file)
    fclose (fp);


  while (iter < header.i && events (0))
    iter = inext;
  events (0);
  while (t < header.t && events (0))
    t = tnext;
  t = header.t;
  events (0);

  { _Bool _ret = 1; ; return _ret; }
                                                                   ; }
# 366 "/Users/weugene/basilisk/src/utils.h"
# 12 "/Users/weugene/basilisk/src/run.h"


void run (void)
{ ;
  iter = 0, t = 0., dt = 1.;
  init_grid (N);

  perf.nc = perf.tnc = 0;
  perf.gt = timer_start();
  while (events (1)) {





    update_perf();
    iter = inext, t = tnext;
  }




  timer_print (perf.gt, iter, perf.tnc);

  free_grid();
                                                          ; }




static int defaults_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i = 0); *ip = i; *tp = t; return ret; } static int defaults (const int i, const double t, Event * _ev) { ; {
  display ((struct _display){"box();"});
                                                               ; } return 0; }





static int cleanup_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (t = 1234567890); *ip = i; *tp = t; return ret; } static int cleanup (const int i, const double t, Event * _ev) { ; {
  display ((struct _display){"", 1});
                                                              ; } return 0; }
# 36 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
# 1 "./timestep.h"
# 1 "/Users/weugene/basilisk/src/timestep.h"

double timestep (const vector u, double dtmax)
{
  static double previous = 0.;
  double DTMAX = dtmax;
  dtmax /= CFL;
   {


                  {
double _dtmax = dtmax;
# 7 "/Users/weugene/basilisk/src/timestep.h"

if (!((cm).i >= 65536)) {
# 7 "/Users/weugene/basilisk/src/timestep.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 7 "/Users/weugene/basilisk/src/timestep.h"
{
# 7 "/Users/weugene/basilisk/src/timestep.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] != 0.) {
      double dt = Delta/fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]);




      dt *= ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)];

      if (dt < _dtmax) _dtmax = dt;
    } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 7 "/Users/weugene/basilisk/src/timestep.h"
{
# 7 "/Users/weugene/basilisk/src/timestep.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] != 0.) {
      double dt = Delta/fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]);




      dt *= ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)];

      if (dt < _dtmax) _dtmax = dt;
    } } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 7 "/Users/weugene/basilisk/src/timestep.h"
{
# 7 "/Users/weugene/basilisk/src/timestep.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] != 0.) {
      double dt = Delta/fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]);




      dt *= ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)];

      if (dt < _dtmax) _dtmax = dt;
    } } }} } } }
# 17 "/Users/weugene/basilisk/src/timestep.h"
 ; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 7 "/Users/weugene/basilisk/src/timestep.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 7 "/Users/weugene/basilisk/src/timestep.h"
{
# 7 "/Users/weugene/basilisk/src/timestep.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] != 0.) {
      double dt = Delta/fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]);




      dt *= _const_cm;

      if (dt < _dtmax) _dtmax = dt;
    } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 7 "/Users/weugene/basilisk/src/timestep.h"
{
# 7 "/Users/weugene/basilisk/src/timestep.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] != 0.) {
      double dt = Delta/fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]);




      dt *= _const_cm;

      if (dt < _dtmax) _dtmax = dt;
    } } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 7 "/Users/weugene/basilisk/src/timestep.h"
{
# 7 "/Users/weugene/basilisk/src/timestep.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] != 0.) {
      double dt = Delta/fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]);




      dt *= _const_cm;

      if (dt < _dtmax) _dtmax = dt;
    } } }} } } }
# 17 "/Users/weugene/basilisk/src/timestep.h"
 ; } if (_dtmax < dtmax) dtmax = _dtmax;
                                      ;



}
# 17 "/Users/weugene/basilisk/src/timestep.h"
 }
  dtmax *= CFL;
  if (dtmax > previous)
    dtmax = (previous + 0.1*dtmax)/1.1;
  if (dtmax > DTMAX) dtmax=DTMAX;
  fprintf(__stderrp, "timestep: dtmax=%g DTMAX=%g\n", dtmax, DTMAX);
  previous = dtmax;
  return dtmax;
}
# 37 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
# 1 "./bcg.h"
# 1 "/Users/weugene/basilisk/src/bcg.h"
# 11 "/Users/weugene/basilisk/src/bcg.h"
void tracer_fluxes (scalar f,
      vector uf,
      vector flux,
      double dt,
       scalar src)
{





  vector g= new_vector("g");
  gradients (((scalar []){f,{-1}}), ((vector []){{g.x,g.y,g.z},{{-1},{-1},{-1}}}));




   {
if (!((fm.x).i >= 65536) && !((src).i >= 65536)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{
# 28 "/Users/weugene/basilisk/src/bcg.h"
 {







    double un = dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)]/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(src.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(src.i)])*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.x.i)]*Delta/2.;





    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]) {
      double vn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+0]) + sizeof(Cell)))[(uf.y.i)])/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]);
      double fyy = vn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+-1] [point.k+0]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+1]) + sizeof(Cell)))[(fm.z.i)]) {
      double wn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+1]) + sizeof(Cell)))[(uf.z.i)])/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+1]) + sizeof(Cell)))[(fm.z.i)]);
      double fzz = wn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+1]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+-1]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.x.i)] = f2*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)];
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{
# 28 "/Users/weugene/basilisk/src/bcg.h"
 {







    double un = dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)]/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(src.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(src.i)])*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(g.y.i)]*Delta/2.;





    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(fm.z.i)] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+1]) + sizeof(Cell)))[(fm.z.i)]) {
      double vn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+1]) + sizeof(Cell)))[(uf.z.i)])/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(fm.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+1]) + sizeof(Cell)))[(fm.z.i)]);
      double fyy = vn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+1]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+-1]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(fm.x.i)] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]) {
      double wn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i] [point.k+0]) + sizeof(Cell)))[(uf.x.i)])/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(fm.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]);
      double fzz = wn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.y.i)] = f2*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)];
  } } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{
# 28 "/Users/weugene/basilisk/src/bcg.h"
 {







    double un = dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)]/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)]*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(src.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(src.i)])*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(g.z.i)]*Delta/2.;





    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(fm.x.i)] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+i]) + sizeof(Cell)))[(fm.x.i)]) {
      double vn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(uf.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+i]) + sizeof(Cell)))[(uf.x.i)])/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(fm.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+i]) + sizeof(Cell)))[(fm.x.i)]);
      double fyy = vn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(fm.y.i)] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+i]) + sizeof(Cell)))[(fm.y.i)]) {
      double wn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(uf.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+i]) + sizeof(Cell)))[(uf.y.i)])/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(fm.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+i]) + sizeof(Cell)))[(fm.y.i)]);
      double fzz = wn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+i]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+i]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.z.i)] = f2*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)];
  } } }} } } }
# 59 "/Users/weugene/basilisk/src/bcg.h"
 ; }
if (((fm.x).i >= 65536) && !((src).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 28 "/Users/weugene/basilisk/src/bcg.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{
# 28 "/Users/weugene/basilisk/src/bcg.h"
 {







    double un = dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)]/(_const_fm.x*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(src.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(src.i)])*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.x.i)]*Delta/2.;





    if (_const_fm.y && _const_fm.y) {
      double vn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+0]) + sizeof(Cell)))[(uf.y.i)])/(_const_fm.y + _const_fm.y);
      double fyy = vn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+-1] [point.k+0]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (_const_fm.z && _const_fm.z) {
      double wn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+1]) + sizeof(Cell)))[(uf.z.i)])/(_const_fm.z + _const_fm.z);
      double fzz = wn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+1]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+-1]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.x.i)] = f2*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)];
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{
# 28 "/Users/weugene/basilisk/src/bcg.h"
 {







    double un = dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)]/(_const_fm.y*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(src.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(src.i)])*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(g.y.i)]*Delta/2.;





    if (_const_fm.z && _const_fm.z) {
      double vn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+1]) + sizeof(Cell)))[(uf.z.i)])/(_const_fm.z + _const_fm.z);
      double fyy = vn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+1]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+-1]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (_const_fm.x && _const_fm.x) {
      double wn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i] [point.k+0]) + sizeof(Cell)))[(uf.x.i)])/(_const_fm.x + _const_fm.x);
      double fzz = wn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.y.i)] = f2*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)];
  } } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{
# 28 "/Users/weugene/basilisk/src/bcg.h"
 {







    double un = dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)]/(_const_fm.z*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(src.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(src.i)])*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(g.z.i)]*Delta/2.;





    if (_const_fm.x && _const_fm.x) {
      double vn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(uf.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+i]) + sizeof(Cell)))[(uf.x.i)])/(_const_fm.x + _const_fm.x);
      double fyy = vn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (_const_fm.y && _const_fm.y) {
      double wn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(uf.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+i]) + sizeof(Cell)))[(uf.y.i)])/(_const_fm.y + _const_fm.y);
      double fzz = wn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+i]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+i]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.z.i)] = f2*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)];
  } } }} } } }
# 59 "/Users/weugene/basilisk/src/bcg.h"
 ; }
if (!((fm.x).i >= 65536) && ((src).i >= 65536)) {
# 79 "/Users/weugene/basilisk/src/bcg.h"
const double _const_src = _constant[src.i -65536];
(void)(_const_src);
# 28 "/Users/weugene/basilisk/src/bcg.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{
# 28 "/Users/weugene/basilisk/src/bcg.h"
 {







    double un = dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)]/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.x.i)]*Delta/2.;





    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]) {
      double vn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+0]) + sizeof(Cell)))[(uf.y.i)])/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]);
      double fyy = vn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+-1] [point.k+0]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+1]) + sizeof(Cell)))[(fm.z.i)]) {
      double wn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+1]) + sizeof(Cell)))[(uf.z.i)])/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+1]) + sizeof(Cell)))[(fm.z.i)]);
      double fzz = wn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+1]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+-1]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.x.i)] = f2*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)];
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{
# 28 "/Users/weugene/basilisk/src/bcg.h"
 {







    double un = dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)]/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(g.y.i)]*Delta/2.;





    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(fm.z.i)] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+1]) + sizeof(Cell)))[(fm.z.i)]) {
      double vn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+1]) + sizeof(Cell)))[(uf.z.i)])/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(fm.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+1]) + sizeof(Cell)))[(fm.z.i)]);
      double fyy = vn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+1]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+-1]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(fm.x.i)] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]) {
      double wn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i] [point.k+0]) + sizeof(Cell)))[(uf.x.i)])/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(fm.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]);
      double fzz = wn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.y.i)] = f2*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)];
  } } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{
# 28 "/Users/weugene/basilisk/src/bcg.h"
 {







    double un = dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)]/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)]*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(g.z.i)]*Delta/2.;





    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(fm.x.i)] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+i]) + sizeof(Cell)))[(fm.x.i)]) {
      double vn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(uf.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+i]) + sizeof(Cell)))[(uf.x.i)])/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(fm.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+i]) + sizeof(Cell)))[(fm.x.i)]);
      double fyy = vn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(fm.y.i)] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+i]) + sizeof(Cell)))[(fm.y.i)]) {
      double wn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(uf.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+i]) + sizeof(Cell)))[(uf.y.i)])/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(fm.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+i]) + sizeof(Cell)))[(fm.y.i)]);
      double fzz = wn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+i]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+i]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.z.i)] = f2*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)];
  } } }} } } }
# 59 "/Users/weugene/basilisk/src/bcg.h"
 ; }
if (((fm.x).i >= 65536) && ((src).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 81 "/Users/weugene/basilisk/src/bcg.h"
const double _const_src = _constant[src.i -65536];
(void)(_const_src);
# 28 "/Users/weugene/basilisk/src/bcg.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{
# 28 "/Users/weugene/basilisk/src/bcg.h"
 {







    double un = dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)]/(_const_fm.x*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.x.i)]*Delta/2.;





    if (_const_fm.y && _const_fm.y) {
      double vn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+0]) + sizeof(Cell)))[(uf.y.i)])/(_const_fm.y + _const_fm.y);
      double fyy = vn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+-1] [point.k+0]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (_const_fm.z && _const_fm.z) {
      double wn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+1]) + sizeof(Cell)))[(uf.z.i)])/(_const_fm.z + _const_fm.z);
      double fzz = wn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+1]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+-1]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.x.i)] = f2*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)];
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{
# 28 "/Users/weugene/basilisk/src/bcg.h"
 {







    double un = dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)]/(_const_fm.y*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(g.y.i)]*Delta/2.;





    if (_const_fm.z && _const_fm.z) {
      double vn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+1]) + sizeof(Cell)))[(uf.z.i)])/(_const_fm.z + _const_fm.z);
      double fyy = vn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+1]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+-1]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (_const_fm.x && _const_fm.x) {
      double wn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i] [point.k+0]) + sizeof(Cell)))[(uf.x.i)])/(_const_fm.x + _const_fm.x);
      double fzz = wn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+i] [point.k+0]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.y.i)] = f2*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)];
  } } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{
# 28 "/Users/weugene/basilisk/src/bcg.h"
 {







    double un = dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)]/(_const_fm.z*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(g.z.i)]*Delta/2.;





    if (_const_fm.x && _const_fm.x) {
      double vn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(uf.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+i]) + sizeof(Cell)))[(uf.x.i)])/(_const_fm.x + _const_fm.x);
      double fyy = vn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*vn*fyy/(2.*Delta);
    }


    if (_const_fm.y && _const_fm.y) {
      double wn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(uf.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+i]) + sizeof(Cell)))[(uf.y.i)])/(_const_fm.y + _const_fm.y);
      double fzz = wn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+i]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+i]) + sizeof(Cell)))[(f.i)];
      f2 -= dt*wn*fzz/(2.*Delta);
    }


    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.z.i)] = f2*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)];
  } } }} } } }
# 59 "/Users/weugene/basilisk/src/bcg.h"
 ; } }





  boundary_flux (((vector []){{flux.x,flux.y,flux.z},{{-1},{-1},{-1}}}));
 delete (((scalar []){g.x,g.y,g.z,{-1}})); }






struct Advection {
  scalar * tracers;
  vector u;
  double dt;
  scalar * src;
};

void advection (struct Advection p)
{




  scalar * lsrc = p.src;
  if (!lsrc) {
    scalar zero= new_const_scalar("zero", 8, 0.);
    if (p.tracers) for (scalar s = *p.tracers, *_i88 = p.tracers; ((scalar *)&s)->i >= 0; s = *++_i88)
      lsrc = list_append (lsrc, zero);
  }

  (__builtin_expect(!(list_len(p.tracers) == list_len(lsrc)), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/bcg.h", 93, "list_len(p.tracers) == list_len(lsrc)") : (void)0);
  scalar f, src;
  vector uf = p.u;
  scalar * _i2 = p.tracers; scalar * _i3 = lsrc; if (p.tracers) for (f = *p.tracers, src = *lsrc; ((scalar *)&f)->i >= 0; f = *++_i2, src = *++_i3) {
    vector flux= new_face_vector("flux");
    tracer_fluxes (f, p.u, flux, p.dt, src);

     {
if (!((cm).i >= 65536)) {
# 100 "/Users/weugene/basilisk/src/bcg.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 100 "/Users/weugene/basilisk/src/bcg.h"
{
      {
# 101 "/Users/weugene/basilisk/src/bcg.h"

      {
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] += p.dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.x.i)])/(Delta*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)]);
      }
# 101 "/Users/weugene/basilisk/src/bcg.h"

      {
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] += p.dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(flux.y.i)])/(Delta*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)]);
      }
# 101 "/Users/weugene/basilisk/src/bcg.h"

      {
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] += p.dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(flux.z.i)])/(Delta*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)]);
      }}
    } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 100 "/Users/weugene/basilisk/src/bcg.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 100 "/Users/weugene/basilisk/src/bcg.h"
{
      {
# 101 "/Users/weugene/basilisk/src/bcg.h"

      {
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] += p.dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.x.i)])/(Delta*_const_cm);
      }
# 101 "/Users/weugene/basilisk/src/bcg.h"

      {
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] += p.dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(flux.y.i)])/(Delta*_const_cm);
      }
# 101 "/Users/weugene/basilisk/src/bcg.h"

      {
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] += p.dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(flux.z.i)])/(Delta*_const_cm);
      }}
    } } } } }; } }



   delete (((scalar []){flux.x,flux.y,flux.z,{-1}})); }
  boundary (p.tracers);

  if (!p.src)
    free(lsrc);
}
# 38 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
# 1 "./viscosity-weugene.h"
# 1 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
# 1 "./penalization.h"
# 1 "/Users/weugene/basilisk/work/src_local/penalization.h"
vector zerocf= {{65536 + 9},{65536 + 10},{65536 + 11}};



    extern scalar fs;
    extern vector fs_face;
    double eta_s = 1e-15, nu_s = 1, lambda_slip = 0;
    int m_bp = 0;
     scalar a_br = {(65536 + 6)}, b_br = {(65536 + 6)};
     vector U_solid = {{65536 + 9},{65536 + 10},{65536 + 11}};

         vector target_U = {{65536 + 9},{65536 + 10},{65536 + 11}}, n_sol = {{65536 + 9},{65536 + 10},{65536 + 11}};
# 54 "/Users/weugene/basilisk/work/src_local/penalization.h"
 double gradun;
# 68 "/Users/weugene/basilisk/work/src_local/penalization.h"
struct Brinkman {
    vector u;
    vector uf;
    scalar rho;
    double dt;
};
# 131 "/Users/weugene/basilisk/work/src_local/penalization.h"
void brinkman_correction_u (vector u, double dt){



     {
if (!((target_U.x).i >= 65536)) {
# 135 "/Users/weugene/basilisk/work/src_local/penalization.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 135 "/Users/weugene/basilisk/work/src_local/penalization.h"
 {
        {
# 136 "/Users/weugene/basilisk/work/src_local/penalization.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt/eta_s)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.x.i)])/(1. + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt/eta_s);
        }
# 136 "/Users/weugene/basilisk/work/src_local/penalization.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt/eta_s)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.y.i)])/(1. + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt/eta_s);
        }
# 136 "/Users/weugene/basilisk/work/src_local/penalization.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt/eta_s)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.z.i)])/(1. + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt/eta_s);
        }}
    } } } } }; }
if (((target_U.x).i >= 65536)) {
const struct { double x, y, z; } _const_target_U = {_constant[target_U.x.i -65536], _constant[target_U.y.i - 65536], _constant[target_U.z.i - 65536]};
(void)(_const_target_U);
# 135 "/Users/weugene/basilisk/work/src_local/penalization.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 135 "/Users/weugene/basilisk/work/src_local/penalization.h"
 {
        {
# 136 "/Users/weugene/basilisk/work/src_local/penalization.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt/eta_s)*_const_target_U.x)/(1. + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt/eta_s);
        }
# 136 "/Users/weugene/basilisk/work/src_local/penalization.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt/eta_s)*_const_target_U.y)/(1. + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt/eta_s);
        }
# 136 "/Users/weugene/basilisk/work/src_local/penalization.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt/eta_s)*_const_target_U.z)/(1. + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt/eta_s);
        }}
    } } } } }; } }
    boundary ((scalar *)((vector []){{u.x,u.y,u.z},{{-1},{-1},{-1}}}));
}
# 155 "/Users/weugene/basilisk/work/src_local/penalization.h"
void brinkman_correction (struct Brinkman p){
    vector u = p.u; double dt = p.dt;
    brinkman_correction_u (u, dt);

}
# 2 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
# 1 "./poisson-weugene.h"
# 1 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
# 35 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 scalar residual_of_p= {1}, divutmp= {2}, divutmpAfter= {3};

_Bool relative_residual_poisson = 0;
void mg_cycle (scalar * a, scalar * res, scalar * da,
        void (* relax) (scalar * da, scalar * res,
          int depth, void * data),
        void * data,
        int nrelax, int minlevel, int maxlevel)
{




  restriction (res);





  minlevel = ((minlevel) < (maxlevel) ? (minlevel) : (maxlevel));
  for (int l = minlevel; l <= maxlevel; l++) {




    if (l == minlevel)
       { { for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {{
# 61 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"

        if (da) for (scalar s = *da, *_i89 = da; ((scalar *)&s)->i >= 0; s = *++_i89)
          ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = 0.; } } } } }; }}; }; }





    else
       { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 70 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"

        if (da) for (scalar s = *da, *_i90 = da; ((scalar *)&s)->i >= 0; s = *++_i90)
          ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = bilinear (point, s); } } } }; }}; }





    boundary_level (da, l);
    for (int i = 0; i < nrelax; i++) {
      relax (da, res, l, data);
      boundary_level (da, l);
    }
  }




   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 88 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
    scalar s, ds;
    scalar * _i4 = a; scalar * _i5 = da; if (a) for (s = *a, ds = *da; ((scalar *)&s)->i >= 0; s = *++_i4, ds = *++_i5)
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(ds.i)];
  } } } } }; }
  boundary (a);
}
# 106 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
int NITERMAX = 100, NITERMIN = 1;
double TOLERANCE = 1e-3;
double RELATIVE_RES_TOLERANCE = 0.1;



typedef struct {
  int i;
  double resb, resa;
  double sum;
  int nrelax;
  int minlevel;
} mgstats;
# 129 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
struct MGSolve {
  scalar * a, * b;
  double (* residual) (scalar * a, scalar * b, scalar * res,
         void * data);
  void (* relax) (scalar * da, scalar * res, int depth,
    void * data);
  void * data;

  int nrelax;
  scalar * res;
  int minlevel;
  double tolerance;
};

mgstats mg_solve (struct MGSolve p)
{





  scalar * da = list_clone (p.a), * res = p.res;
  if (!res)
    if (p.a) for (scalar s = *p.a, *_i91 = p.a; ((scalar *)&s)->i >= 0; s = *++_i91) {
      scalar r = new_scalar("r");
      res = list_append (res, r);
    }






  for (int b = 0; b < nboundary; b++)
    if (da) for (scalar s = *da, *_i92 = da; ((scalar *)&s)->i >= 0; s = *++_i92)
      _attribute[s.i].boundary[b] = _attribute[s.i].boundary_homogeneous[b];




  mgstats s = {0};
  double sum = 0.;
   {


                  {
double _sum = sum;
# 171 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 171 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"

    if (p.b) for (scalar s = *p.b, *_i93 = p.b; ((scalar *)&s)->i >= 0; s = *++_i93)
      _sum += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]; } } } }; sum += _sum;
                                    ;



}
# 173 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 }
  s.sum = sum;
  s.nrelax = p.nrelax > 0 ? p.nrelax : 4;




  double resb;
  resb = s.resb = s.resa = p.residual (p.a, p.b, res, p.data);
# 191 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 int patient = 0;
  if (p.tolerance == 0.)
    p.tolerance = TOLERANCE;
  for (s.i = 0;
       s.i < NITERMAX && (s.i < NITERMIN || s.resa > p.tolerance);
       s.i++) {
    mg_cycle (p.a, res, da, p.relax, p.data,
       s.nrelax,
       p.minlevel,
       grid->maxdepth);
    s.resa = p.residual (p.a, p.b, res, p.data);
# 210 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 if (s.resa > TOLERANCE) {
      if (resb/s.resa < 1.2 && s.nrelax < 100)
     s.nrelax++;
      else if (resb/s.resa > 10 && s.nrelax > 2)
     s.nrelax--;
    }







    resb = s.resa;
# 244 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 }
  s.minlevel = p.minlevel;




  if (s.resa > p.tolerance) {
    scalar v = p.a[0];
    fprintf (__stderrp,
      "WARNING: convergence for %s not reached after %d iterations\n"
      "  res: %g sum: %g nrelax: %d\n", _attribute[v.i].name,
      s.i, s.resa, s.sum, s.nrelax), fflush (__stderrp);
  }




  if (!p.res)
    delete (res), free(res);
  delete (da), free(da);

  return s;
}
# 293 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
struct Poisson {
  scalar a, b;
   vector alpha;
   scalar lambda;
  double tolerance;
  int nrelax, minlevel;
  scalar * res;



  double maxb;
};
# 357 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
static void relax (scalar * al, scalar * bl, int l, void * data)
{
  scalar a = al[0], b = bl[0];
  struct Poisson * p = (struct Poisson *) data;
   vector alpha = p->alpha;
   scalar lambda = p->lambda;
# 377 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 scalar c= new_scalar("c");
# 386 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
if (!((lambda).i >= 65536) && !((alpha.x).i >= 65536)) {
# 386 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {{
# 386 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
    double n = - ((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(b.i)], d = - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(lambda.i)]*((Delta)*(Delta));
    {
# 388 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
      n += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.i)];
      d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)];
    }
# 388 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
      n += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(a.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(a.i)];
      d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)];
    }
# 388 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
      n += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(alpha.z.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(a.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(a.i)];
      d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(alpha.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)];
    }}
# 402 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] = n/d;
  } } } } } }; }}; }; }
if (((lambda).i >= 65536) && !((alpha.x).i >= 65536)) {
const double _const_lambda = _constant[lambda.i -65536];
(void)(_const_lambda);
# 386 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {{
# 386 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
    double n = - ((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(b.i)], d = - _const_lambda*((Delta)*(Delta));
    {
# 388 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
      n += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.i)];
      d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)];
    }
# 388 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
      n += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(a.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(a.i)];
      d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)];
    }
# 388 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
      n += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(alpha.z.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(a.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(a.i)];
      d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(alpha.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)];
    }}
# 402 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] = n/d;
  } } } } } }; }}; }; }
if (!((lambda).i >= 65536) && ((alpha.x).i >= 65536)) {






const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 386 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {{
# 386 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
    double n = - ((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(b.i)], d = - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(lambda.i)]*((Delta)*(Delta));
    {
# 388 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
      n += _const_alpha.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.i)] + _const_alpha.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.i)];
      d += _const_alpha.x + _const_alpha.x;
    }
# 388 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
      n += _const_alpha.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(a.i)] + _const_alpha.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(a.i)];
      d += _const_alpha.y + _const_alpha.y;
    }
# 388 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
      n += _const_alpha.z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(a.i)] + _const_alpha.z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(a.i)];
      d += _const_alpha.z + _const_alpha.z;
    }}
# 402 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] = n/d;
  } } } } } }; }}; }; }
if (((lambda).i >= 65536) && ((alpha.x).i >= 65536)) {
const double _const_lambda = _constant[lambda.i -65536];
(void)(_const_lambda);






const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 386 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {{
# 386 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
    double n = - ((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(b.i)], d = - _const_lambda*((Delta)*(Delta));
    {
# 388 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
      n += _const_alpha.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.i)] + _const_alpha.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.i)];
      d += _const_alpha.x + _const_alpha.x;
    }
# 388 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
      n += _const_alpha.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(a.i)] + _const_alpha.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(a.i)];
      d += _const_alpha.y + _const_alpha.y;
    }
# 388 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
      n += _const_alpha.z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(a.i)] + _const_alpha.z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(a.i)];
      d += _const_alpha.z + _const_alpha.z;
    }}
# 402 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] = n/d;
  } } } } } }; }}; }; } }
# 416 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 { { for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {{
# 416 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)])/3.; } } } } }; }}; }; }
# 428 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 delete (((scalar []){c,{-1}})); }






static double residual (scalar * al, scalar * bl, scalar * resl, void * data)
{
  scalar a = al[0], b = bl[0], res = resl[0];
  struct Poisson * p = (struct Poisson *) data;
   vector alpha = p->alpha;
   scalar lambda = p->lambda;
  double maxres = 0., maxb = p->maxb;


  vector g= new_face_vector("g");
   {
if (!((alpha.x).i >= 65536)) {
# 445 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 445 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{
# 445 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)]*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0 -1][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.i)])/Delta); } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 445 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{
# 445 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)]*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0 -1] [point.k+0]) + sizeof(Cell)))[(a.i)])/Delta); } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 445 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{
# 445 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)]*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0 -1]) + sizeof(Cell)))[(a.i)])/Delta); } }} } } }
# 446 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 ; }
if (((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 445 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 445 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{
# 445 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.x.i)] = _const_alpha.x*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0 -1][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.i)])/Delta); } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 445 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{
# 445 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.y.i)] = _const_alpha.y*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0 -1] [point.k+0]) + sizeof(Cell)))[(a.i)])/Delta); } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 445 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{
# 445 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.z.i)] = _const_alpha.z*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0 -1]) + sizeof(Cell)))[(a.i)])/Delta); } }} } } }
# 446 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 ; } }
  boundary_flux (((vector []){{g.x,g.y,g.z},{{-1},{-1},{-1}}}));
   {


                  {
double _maxres = maxres;
# 448 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"

if (!((lambda).i >= 65536)) {
# 448 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 448 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(b.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(lambda.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.i)];
    {
# 450 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.i)] -= (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.x.i)])/Delta;
# 450 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.i)] -= (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(g.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.y.i)])/Delta;
# 450 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.i)] -= (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(g.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.z.i)])/Delta;}
# 467 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(residual_of_p.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.i)];

    if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.i)]) > _maxres)
      _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.i)]);
  } } } } }; }
if (((lambda).i >= 65536)) {
const double _const_lambda = _constant[lambda.i -65536];
(void)(_const_lambda);
# 448 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 448 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(b.i)] - _const_lambda*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.i)];
    {
# 450 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.i)] -= (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.x.i)])/Delta;
# 450 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.i)] -= (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(g.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.y.i)])/Delta;
# 450 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.i)] -= (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(g.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.z.i)])/Delta;}
# 467 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(residual_of_p.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.i)];

    if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.i)]) > _maxres)
      _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.i)]);
  } } } } }; } if (_maxres > maxres) maxres = _maxres;
                                       ;



}
# 471 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 }
  boundary (resl);
  fprintf(__stderrp, "maxres*dt^2= %g maxres= %g maxb= %g maxres/maxb= %g\n", maxres*((dt)*(dt)), maxres, maxb, maxres/maxb);
  { double _ret = maxres/maxb; delete (((scalar []){g.x,g.y,g.z,{-1}})); return _ret; }
 delete (((scalar []){g.x,g.y,g.z,{-1}})); }
# 486 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
mgstats poisson (struct Poisson p)
{
 fprintf(__stderrp, "**********************\n");





  if (!p.alpha.x.i)
    p.alpha = unityf;
  if (!p.lambda.i)
    p.lambda = zeroc;




  vector alpha = p.alpha;
  scalar lambda = p.lambda;
  restriction (((scalar []){alpha.x,alpha.y,alpha.z,lambda,{-1}}));





  double defaultol = TOLERANCE;
  if (p.tolerance)
    TOLERANCE = p.tolerance;

  scalar a = p.a, b = p.b;
  if (relative_residual_poisson) {
    double maxb = 0;
     {


                  {
double _maxb = maxb;
# 517 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 517 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{
      if (fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(b.i)]) > _maxb) _maxb = fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(b.i)]);
    } } } } }; if (_maxb > maxb) maxb = _maxb;
                                     ;



}
# 519 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 }
    if (maxb < 1e-12) maxb = 1;
    p.maxb = maxb;
  }else{
    p.maxb = 1;
  }




  mgstats s = mg_solve ((struct MGSolve){((scalar []){a,{-1}}), ((scalar []){b,{-1}}), residual, relax,
   &p, p.nrelax, p.res, .minlevel = ((1) > (p.minlevel) ? (1) : (p.minlevel))});




  if (p.tolerance)
    TOLERANCE = defaultol;

  return s;
}
# 558 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
struct Project {
  vector uf;
  scalar p;
  vector alpha;
  double dt;
  int nrelax;
  scalar fs;
  vector target_U;
  vector u;
};


mgstats project (struct Project q)
{ ;
    vector uf = q.uf;
    scalar p = q.p;
     vector alpha = q.alpha.x.i ? q.alpha : unityf;
    double dt = q.dt ? q.dt : 1., d;
    int nrelax = q.nrelax ? q.nrelax : 4;






    scalar div= new_scalar("div");
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 584 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
        d = 0.;
        {
# 586 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{
            d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)];
        }
# 586 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{
            d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)];
        }
# 586 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{
            d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(uf.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)];
        }}
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(div.i)] = d/(dt*Delta);

        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(divutmp.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(div.i)]*dt;

    } } } } }; }
    boundary((scalar*)((scalar []){div,{-1}}));

    boundary((scalar*)((scalar []){divutmp,{-1}}));
# 608 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 mgstats mgp;
    if (relative_residual_poisson)
      mgp = poisson ((struct Poisson){p, div , alpha, .tolerance = TOLERANCE, .nrelax = nrelax});
    else
      mgp = poisson ((struct Poisson){p, div , alpha, .tolerance = TOLERANCE/((dt)*(dt)), .nrelax = nrelax});
# 628 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
if (!((alpha.x).i >= 65536)) {
# 628 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 628 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{
# 628 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] -= dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)]*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0 -1][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)])/Delta); } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 628 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{
# 628 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] -= dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)]*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0 -1] [point.k+0]) + sizeof(Cell)))[(p.i)])/Delta); } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 628 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{
# 628 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] -= dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)]*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0 -1]) + sizeof(Cell)))[(p.i)])/Delta); } }} } } }
# 628 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 ; }
if (((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 628 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 628 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{
# 628 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] -= dt*_const_alpha.x*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0 -1][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)])/Delta); } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 628 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{
# 628 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] -= dt*_const_alpha.y*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0 -1] [point.k+0]) + sizeof(Cell)))[(p.i)])/Delta); } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 628 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{
# 628 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] -= dt*_const_alpha.z*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0 -1]) + sizeof(Cell)))[(p.i)])/Delta); } }} } } }
# 628 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 ; } }
    boundary ((scalar *)((vector []){{uf.x,uf.y,uf.z},{{-1},{-1},{-1}}}));


    double divuf, maxdivuf = -1e30;
     {


                  {
double _maxdivuf = maxdivuf;
# 633 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 633 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 {
      divuf = 0;
      {
# 635 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 divuf += (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)]-((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)])/Delta;
# 635 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 divuf += (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(uf.y.i)]-((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)])/Delta;
# 635 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 divuf += (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(uf.z.i)]-((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)])/Delta;}
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(divutmpAfter.i)] = divuf/dt;
      divuf = fabs(divuf);
      if (_maxdivuf < divuf) _maxdivuf = divuf;
    } } } } }; if (_maxdivuf > maxdivuf) maxdivuf = _maxdivuf;
                                         ;



}
# 639 "/Users/weugene/basilisk/work/src_local/poisson-weugene.h"
 }
    boundary((scalar*)((scalar []){divutmpAfter,{-1}}));
    fprintf(__stderrp, "Projection MAX{div uf} = %g\n", maxdivuf);

    { mgstats _ret = mgp; delete (((scalar []){div,{-1}})); ; return _ret; }
 delete (((scalar []){div,{-1}})); ; }
# 4 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"



_Bool relative_residual_viscous = 0;
# 38 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
struct Viscosity {
    vector u;
    vector mu;
    scalar rho;
    double dt;
    int nrelax;
    scalar * res;
    double maxb;
};



static void relax_viscosity (scalar*a, scalar*b, int l, void*data)
{
    struct Viscosity * p = (struct Viscosity *) data;
     vector mu = p->mu;
     scalar rho = p->rho;
    double dt = p->dt;
    vector u = (*((vector *)&(a[0]))), r = (*((vector *)&(b[0])));
    coord conv;

        vector w= new_vector("w");




     {
if (!((target_U.x).i >= 65536) && !((rho).i >= 65536) && !((mu.x).i >= 65536)) {
# 64 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {{
# 64 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {

        conv.x = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)]));

        conv.y = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)]));


        conv.z = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)]));


        {
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.x.i)] = ((1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4.)


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.x
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.x.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).x
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]

                    ));
        }
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.y.i)] = ((1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4.)


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.y
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.y.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).y
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]

                    ));
        }
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.z.i)] = ((1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)])/4.)


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(u.y.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(u.y.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.z
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.z.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).z
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]

                    ));
        }}
    } } } } } }; }}; }; }
if (((target_U.x).i >= 65536) && !((rho).i >= 65536) && !((mu.x).i >= 65536)) {
const struct { double x, y, z; } _const_target_U = {_constant[target_U.x.i -65536], _constant[target_U.y.i - 65536], _constant[target_U.z.i - 65536]};
(void)(_const_target_U);
# 64 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {{
# 64 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {

        conv.x = (_const_target_U.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + _const_target_U.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + _const_target_U.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)]));

        conv.y = (_const_target_U.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + _const_target_U.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + _const_target_U.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)]));


        conv.z = (_const_target_U.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + _const_target_U.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + _const_target_U.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)]));


        {
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.x.i)] = ((1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4.)


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.x
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.x.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).x
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]

                    ));
        }
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.y.i)] = ((1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4.)


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.y
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.y.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).y
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]

                    ));
        }
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.z.i)] = ((1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)])/4.)


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(u.y.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(u.y.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.z
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.z.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).z
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]

                    ));
        }}
    } } } } } }; }}; }; }
if (!((target_U.x).i >= 65536) && ((rho).i >= 65536) && !((mu.x).i >= 65536)) {
# 125 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
const double _const_rho = _constant[rho.i -65536];
(void)(_const_rho);
# 64 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {{
# 64 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {

        conv.x = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)]));

        conv.y = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)]));


        conv.z = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)]));


        {
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.x.i)] = ((1)*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4.)


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.x
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.x.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).x
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]

                    ));
        }
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.y.i)] = ((1)*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4.)


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.y
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.y.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).y
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]

                    ));
        }
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.z.i)] = ((1)*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)])/4.)


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(u.y.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(u.y.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.z
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.z.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).z
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]

                    ));
        }}
    } } } } } }; }}; }; }
if (((target_U.x).i >= 65536) && ((rho).i >= 65536) && !((mu.x).i >= 65536)) {
const struct { double x, y, z; } _const_target_U = {_constant[target_U.x.i -65536], _constant[target_U.y.i - 65536], _constant[target_U.z.i - 65536]};
(void)(_const_target_U);
# 127 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
const double _const_rho = _constant[rho.i -65536];
(void)(_const_rho);
# 64 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {{
# 64 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {

        conv.x = (_const_target_U.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + _const_target_U.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + _const_target_U.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)]));

        conv.y = (_const_target_U.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + _const_target_U.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + _const_target_U.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)]));


        conv.z = (_const_target_U.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + _const_target_U.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + _const_target_U.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)]));


        {
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.x.i)] = ((1)*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4.)


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.x
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.x.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).x
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]

                    ));
        }
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.y.i)] = ((1)*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4.)


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.y
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.y.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).y
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]

                    ));
        }
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.z.i)] = ((1)*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)])/4.)


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(u.y.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(u.y.i)])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.z
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.z.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).z
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(mu.z.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]


                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(mu.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]

                    ));
        }}
    } } } } } }; }}; }; }
if (!((target_U.x).i >= 65536) && !((rho).i >= 65536) && ((mu.x).i >= 65536)) {
# 131 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
const struct { double x, y, z; } _const_mu = {_constant[mu.x.i -65536], _constant[mu.y.i - 65536], _constant[mu.z.i - 65536]};
(void)(_const_mu);
# 64 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {{
# 64 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {

        conv.x = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)]));

        conv.y = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)]));


        conv.z = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)]));


        {
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.x.i)] = ((1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + 2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]

                    + _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4.)
                    - _const_mu.y*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4.)


                    + _const_mu.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4.)
                    - _const_mu.z*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.x
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.x.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).x
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*_const_mu.x + 2.*_const_mu.x

                    + _const_mu.y + _const_mu.y


                    + _const_mu.z + _const_mu.z

                    ));
        }
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.y.i)] = ((1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + 2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)]

                    + _const_mu.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4.)
                    - _const_mu.z*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4.)


                    + _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4.)
                    - _const_mu.x*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.y
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.y.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).y
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*_const_mu.y + 2.*_const_mu.y

                    + _const_mu.z + _const_mu.z


                    + _const_mu.x + _const_mu.x

                    ));
        }
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.z.i)] = ((1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*_const_mu.z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)] + 2.*_const_mu.z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)]

                    + _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)])/4.)
                    - _const_mu.x*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)])/4.)


                    + _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(u.y.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(u.y.i)])/4.)
                    - _const_mu.y*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.z
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.z.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).z
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*_const_mu.z + 2.*_const_mu.z

                    + _const_mu.x + _const_mu.x


                    + _const_mu.y + _const_mu.y

                    ));
        }}
    } } } } } }; }}; }; }
if (((target_U.x).i >= 65536) && !((rho).i >= 65536) && ((mu.x).i >= 65536)) {
const struct { double x, y, z; } _const_target_U = {_constant[target_U.x.i -65536], _constant[target_U.y.i - 65536], _constant[target_U.z.i - 65536]};
(void)(_const_target_U);
# 133 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
const struct { double x, y, z; } _const_mu = {_constant[mu.x.i -65536], _constant[mu.y.i - 65536], _constant[mu.z.i - 65536]};
(void)(_const_mu);
# 64 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {{
# 64 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {

        conv.x = (_const_target_U.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + _const_target_U.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + _const_target_U.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)]));

        conv.y = (_const_target_U.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + _const_target_U.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + _const_target_U.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)]));


        conv.z = (_const_target_U.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + _const_target_U.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + _const_target_U.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)]));


        {
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.x.i)] = ((1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + 2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]

                    + _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4.)
                    - _const_mu.y*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4.)


                    + _const_mu.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4.)
                    - _const_mu.z*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.x
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.x.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).x
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*_const_mu.x + 2.*_const_mu.x

                    + _const_mu.y + _const_mu.y


                    + _const_mu.z + _const_mu.z

                    ));
        }
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.y.i)] = ((1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + 2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)]

                    + _const_mu.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4.)
                    - _const_mu.z*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4.)


                    + _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4.)
                    - _const_mu.x*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.y
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.y.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).y
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*_const_mu.y + 2.*_const_mu.y

                    + _const_mu.z + _const_mu.z


                    + _const_mu.x + _const_mu.x

                    ));
        }
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.z.i)] = ((1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*_const_mu.z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)] + 2.*_const_mu.z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)]

                    + _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)])/4.)
                    - _const_mu.x*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)])/4.)


                    + _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(u.y.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(u.y.i)])/4.)
                    - _const_mu.y*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.z
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.z.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).z
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)])*(2.*_const_mu.z + 2.*_const_mu.z

                    + _const_mu.x + _const_mu.x


                    + _const_mu.y + _const_mu.y

                    ));
        }}
    } } } } } }; }}; }; }
if (!((target_U.x).i >= 65536) && ((rho).i >= 65536) && ((mu.x).i >= 65536)) {
# 125 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
const double _const_rho = _constant[rho.i -65536];
(void)(_const_rho);






const struct { double x, y, z; } _const_mu = {_constant[mu.x.i -65536], _constant[mu.y.i - 65536], _constant[mu.z.i - 65536]};
(void)(_const_mu);
# 64 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {{
# 64 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {

        conv.x = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)]));

        conv.y = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)]));


        conv.z = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)]));


        {
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.x.i)] = ((1)*(dt/_const_rho)*(2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + 2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]

                    + _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4.)
                    - _const_mu.y*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4.)


                    + _const_mu.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4.)
                    - _const_mu.z*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.x
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.x.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).x
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/_const_rho)*(2.*_const_mu.x + 2.*_const_mu.x

                    + _const_mu.y + _const_mu.y


                    + _const_mu.z + _const_mu.z

                    ));
        }
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.y.i)] = ((1)*(dt/_const_rho)*(2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + 2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)]

                    + _const_mu.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4.)
                    - _const_mu.z*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4.)


                    + _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4.)
                    - _const_mu.x*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.y
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.y.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).y
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/_const_rho)*(2.*_const_mu.y + 2.*_const_mu.y

                    + _const_mu.z + _const_mu.z


                    + _const_mu.x + _const_mu.x

                    ));
        }
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.z.i)] = ((1)*(dt/_const_rho)*(2.*_const_mu.z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)] + 2.*_const_mu.z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)]

                    + _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)])/4.)
                    - _const_mu.x*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)])/4.)


                    + _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(u.y.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(u.y.i)])/4.)
                    - _const_mu.y*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.z
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.z.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).z
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/_const_rho)*(2.*_const_mu.z + 2.*_const_mu.z

                    + _const_mu.x + _const_mu.x


                    + _const_mu.y + _const_mu.y

                    ));
        }}
    } } } } } }; }}; }; }
if (((target_U.x).i >= 65536) && ((rho).i >= 65536) && ((mu.x).i >= 65536)) {
const struct { double x, y, z; } _const_target_U = {_constant[target_U.x.i -65536], _constant[target_U.y.i - 65536], _constant[target_U.z.i - 65536]};
(void)(_const_target_U);
# 127 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
const double _const_rho = _constant[rho.i -65536];
(void)(_const_rho);






const struct { double x, y, z; } _const_mu = {_constant[mu.x.i -65536], _constant[mu.y.i - 65536], _constant[mu.z.i - 65536]};
(void)(_const_mu);
# 64 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {{
# 64 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {

        conv.x = (_const_target_U.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + _const_target_U.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + _const_target_U.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)]));

        conv.y = (_const_target_U.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + _const_target_U.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + _const_target_U.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)]));


        conv.z = (_const_target_U.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + _const_target_U.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + _const_target_U.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)]));


        {
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.x.i)] = ((1)*(dt/_const_rho)*(2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + 2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]

                    + _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4.)
                    - _const_mu.y*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4.)


                    + _const_mu.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4.)
                    - _const_mu.z*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.x
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.x.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).x
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/_const_rho)*(2.*_const_mu.x + 2.*_const_mu.x

                    + _const_mu.y + _const_mu.y


                    + _const_mu.z + _const_mu.z

                    ));
        }
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.y.i)] = ((1)*(dt/_const_rho)*(2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + 2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)]

                    + _const_mu.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/4.)
                    - _const_mu.z*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4.)


                    + _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4.)
                    - _const_mu.x*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.y
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.y.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).y
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/_const_rho)*(2.*_const_mu.y + 2.*_const_mu.y

                    + _const_mu.z + _const_mu.z


                    + _const_mu.x + _const_mu.x

                    ));
        }
# 74 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.z.i)] = ((1)*(dt/_const_rho)*(2.*_const_mu.z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)] + 2.*_const_mu.z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)]

                    + _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)])/4.)
                    - _const_mu.x*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)])/4.)


                    + _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(u.y.i)])/4. -
                          (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(u.y.i)])/4.)
                    - _const_mu.y*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)])/4.)

                    )
                    + 0.5*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*Delta*conv.z
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.z.i)]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.,1.}).z
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*dt*(((Delta)*(Delta))/eta_s)
                    + (1)*(dt/_const_rho)*(2.*_const_mu.z + 2.*_const_mu.z

                    + _const_mu.x + _const_mu.x


                    + _const_mu.y + _const_mu.y

                    ));
        }}
    } } } } } }; }}; }; } }


         { { for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {{
# 108 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

            {
# 109 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

                ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.x.i)])/3.;
# 109 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

                ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.y.i)])/3.;
# 109 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

                ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(w.z.i)])/3.;}; } } } } }; }}; }; }
# 119 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 delete (((scalar []){w.x,w.y,w.z,{-1}})); }


static double residual_viscosity (scalar * a, scalar * b, scalar * resl, void * data) {
    struct Viscosity * p = (struct Viscosity *) data;
     vector mu = p->mu;
     scalar rho = p->rho;
    double dt = p->dt;
    vector u = (*((vector *)&(a[0]))), r = (*((vector *)&(b[0]))), res = (*((vector *)&(resl[0])));
    vector divtauu= new_vector("divtauu");
    coord conv;
    double maxres = 0, d = 0, maxb = p->maxb;
    coord LU;




    {
# 136 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {
        vector taux= new_face_vector("taux");
         {
if (!((mu.x).i >= 65536)) {
# 138 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 138 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
# 138 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.x.i)] = 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/Delta; } }} } } }
# 139 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 ; }
if (((mu.x).i >= 65536)) {
const struct { double x, y, z; } _const_mu = {_constant[mu.x.i -65536], _constant[mu.y.i - 65536], _constant[mu.z.i - 65536]};
(void)(_const_mu);
# 138 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 138 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
# 138 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.x.i)] = 2.*_const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/Delta; } }} } } }
# 139 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 ; } }

         {
if (!((mu.x).i >= 65536)) {
# 141 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 141 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
# 141 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] +
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4. -
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4.)/Delta; } }} } } }
# 144 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 ; }
if (((mu.x).i >= 65536)) {
const struct { double x, y, z; } _const_mu = {_constant[mu.x.i -65536], _constant[mu.y.i - 65536], _constant[mu.z.i - 65536]};
(void)(_const_mu);
# 141 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 141 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
# 141 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.y.i)] = _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] +
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4. -
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/4.)/Delta; } }} } } }
# 144 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 ; } }


         {
if (!((mu.x).i >= 65536)) {
# 147 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 147 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
# 147 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] +
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4. -
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4.)/Delta; } }} } } }
# 150 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 ; }
if (((mu.x).i >= 65536)) {
const struct { double x, y, z; } _const_mu = {_constant[mu.x.i -65536], _constant[mu.y.i - 65536], _constant[mu.z.i - 65536]};
(void)(_const_mu);
# 147 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 147 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
# 147 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.z.i)] = _const_mu.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] +
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4. -
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4.)/Delta; } }} } } }
# 150 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 ; } }

        boundary_flux(((vector []){{taux.x,taux.y,taux.z},{{-1},{-1},{-1}}}));

         { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 154 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {
            d = 0.0;
            {
# 156 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {
                d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.x.i)];
            }
# 156 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {
                d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(taux.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.y.i)];
            }
# 156 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {
                d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(taux.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.z.i)];
            }}
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(divtauu.x.i)] = d/Delta;
        } } } } }; }
     delete (((scalar []){taux.x,taux.y,taux.z,{-1}})); }
# 136 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {
        vector taux= new_face_vector("taux");
         {
if (!((mu.y).i >= 65536)) {
# 138 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 138 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
# 138 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.y.i)] = 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/Delta; } }} } } }
# 139 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 ; }
if (((mu.y).i >= 65536)) {
const struct { double x, y, z; } _const_mu = {_constant[mu.y.i -65536], _constant[mu.z.i - 65536], _constant[mu.x.i - 65536]};
(void)(_const_mu);
# 138 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 138 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
# 138 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.y.i)] = 2.*_const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/Delta; } }} } } }
# 139 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 ; } }

         {
if (!((mu.y).i >= 65536)) {
# 141 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 141 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
# 141 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] +
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4. -
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4.)/Delta; } }} } } }
# 144 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 ; }
if (((mu.y).i >= 65536)) {
const struct { double x, y, z; } _const_mu = {_constant[mu.y.i -65536], _constant[mu.z.i - 65536], _constant[mu.x.i - 65536]};
(void)(_const_mu);
# 141 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 141 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
# 141 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.z.i)] = _const_mu.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] +
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4. -
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)])/4.)/Delta; } }} } } }
# 144 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 ; } }


         {
if (!((mu.y).i >= 65536)) {
# 147 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 147 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
# 147 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] +
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4. -
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4.)/Delta; } }} } } }
# 150 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 ; }
if (((mu.y).i >= 65536)) {
const struct { double x, y, z; } _const_mu = {_constant[mu.y.i -65536], _constant[mu.z.i - 65536], _constant[mu.x.i - 65536]};
(void)(_const_mu);
# 147 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 147 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
# 147 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.x.i)] = _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] +
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4. -
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/4.)/Delta; } }} } } }
# 150 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 ; } }

        boundary_flux(((vector []){{taux.x,taux.y,taux.z},{{-1},{-1},{-1}}}));

         { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 154 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {
            d = 0.0;
            {
# 156 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {
                d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(taux.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.y.i)];
            }
# 156 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {
                d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(taux.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.z.i)];
            }
# 156 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {
                d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.x.i)];
            }}
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(divtauu.y.i)] = d/Delta;
        } } } } }; }
     delete (((scalar []){taux.x,taux.y,taux.z,{-1}})); }
# 136 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {
        vector taux= new_face_vector("taux");
         {
if (!((mu.z).i >= 65536)) {
# 138 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 138 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
# 138 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.z.i)] = 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)])/Delta; } }} } } }
# 139 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 ; }
if (((mu.z).i >= 65536)) {
const struct { double x, y, z; } _const_mu = {_constant[mu.z.i -65536], _constant[mu.x.i - 65536], _constant[mu.y.i - 65536]};
(void)(_const_mu);
# 138 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 138 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
# 138 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.z.i)] = 2.*_const_mu.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)])/Delta; } }} } } }
# 139 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 ; } }

         {
if (!((mu.z).i >= 65536)) {
# 141 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 141 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
# 141 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)])/4. -
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)])/4.)/Delta; } }} } } }
# 144 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 ; }
if (((mu.z).i >= 65536)) {
const struct { double x, y, z; } _const_mu = {_constant[mu.z.i -65536], _constant[mu.x.i - 65536], _constant[mu.y.i - 65536]};
(void)(_const_mu);
# 141 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 141 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
# 141 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.x.i)] = _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)])/4. -
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)])/4.)/Delta; } }} } } }
# 144 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 ; } }


         {
if (!((mu.z).i >= 65536)) {
# 147 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 147 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
# 147 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mu.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)])/4. -
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)])/4.)/Delta; } }} } } }
# 150 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 ; }
if (((mu.z).i >= 65536)) {
const struct { double x, y, z; } _const_mu = {_constant[mu.z.i -65536], _constant[mu.x.i - 65536], _constant[mu.y.i - 65536]};
(void)(_const_mu);
# 147 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 147 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
# 147 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.y.i)] = _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] +
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)])/4. -
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)])/4.)/Delta; } }} } } }
# 150 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 ; } }

        boundary_flux(((vector []){{taux.x,taux.y,taux.z},{{-1},{-1},{-1}}}));

         { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 154 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {
            d = 0.0;
            {
# 156 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {
                d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(taux.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.z.i)];
            }
# 156 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {
                d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.x.i)];
            }
# 156 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {
                d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(taux.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(taux.y.i)];
            }}
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(divtauu.z.i)] = d/Delta;
        } } } } }; }
     delete (((scalar []){taux.x,taux.y,taux.z,{-1}})); }}
    boundary((scalar *)((vector []){{divtauu.x,divtauu.y,divtauu.z},{{-1},{-1},{-1}}}));

     {


                  {
double _maxres = maxres;
# 164 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"

if (!((target_U.x).i >= 65536) && !((rho).i >= 65536)) {
# 164 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 164 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {

        conv.x = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)]))/(2.0*Delta);

        conv.y = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)]))/(2.0*Delta);


        conv.z = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)]))/(2.0*Delta);







        {
# 179 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            LU.x = ((coord){1.,1.,1.}).x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - (1)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(divtauu.x.i)]*dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)]
                     -(- ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]/eta_s + conv.x )))*dt;
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.x.i)] - LU.x;
            if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.x.i)]) > _maxres) _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.x.i)]);






        }
# 179 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            LU.y = ((coord){1.,1.,1.}).y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - (1)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(divtauu.y.i)]*dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)]
                     -(- ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]/eta_s + conv.y )))*dt;
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.y.i)] - LU.y;
            if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.y.i)]) > _maxres) _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.y.i)]);






        }
# 179 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            LU.z = ((coord){1.,1.,1.}).z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - (1)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(divtauu.z.i)]*dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)]
                     -(- ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]/eta_s + conv.z )))*dt;
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.z.i)] - LU.z;
            if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.z.i)]) > _maxres) _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.z.i)]);






        }}
    } } } } }; }
if (((target_U.x).i >= 65536) && !((rho).i >= 65536)) {
const struct { double x, y, z; } _const_target_U = {_constant[target_U.x.i -65536], _constant[target_U.y.i - 65536], _constant[target_U.z.i - 65536]};
(void)(_const_target_U);
# 164 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 164 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {

        conv.x = (_const_target_U.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + _const_target_U.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + _const_target_U.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)]))/(2.0*Delta);

        conv.y = (_const_target_U.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + _const_target_U.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + _const_target_U.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)]))/(2.0*Delta);


        conv.z = (_const_target_U.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + _const_target_U.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + _const_target_U.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)]))/(2.0*Delta);







        {
# 179 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            LU.x = ((coord){1.,1.,1.}).x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - (1)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(divtauu.x.i)]*dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)]
                     -(- ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]/eta_s + conv.x )))*dt;
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.x.i)] - LU.x;
            if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.x.i)]) > _maxres) _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.x.i)]);






        }
# 179 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            LU.y = ((coord){1.,1.,1.}).y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - (1)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(divtauu.y.i)]*dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)]
                     -(- ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]/eta_s + conv.y )))*dt;
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.y.i)] - LU.y;
            if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.y.i)]) > _maxres) _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.y.i)]);






        }
# 179 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            LU.z = ((coord){1.,1.,1.}).z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - (1)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(divtauu.z.i)]*dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rho.i)]
                     -(- ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]/eta_s + conv.z )))*dt;
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.z.i)] - LU.z;
            if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.z.i)]) > _maxres) _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.z.i)]);






        }}
    } } } } }; }
if (!((target_U.x).i >= 65536) && ((rho).i >= 65536)) {
# 211 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
const double _const_rho = _constant[rho.i -65536];
(void)(_const_rho);
# 164 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 164 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {

        conv.x = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)]))/(2.0*Delta);

        conv.y = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)]))/(2.0*Delta);


        conv.z = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)]))/(2.0*Delta);







        {
# 179 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            LU.x = ((coord){1.,1.,1.}).x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - (1)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(divtauu.x.i)]*dt/_const_rho
                     -(- ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]/eta_s + conv.x )))*dt;
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.x.i)] - LU.x;
            if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.x.i)]) > _maxres) _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.x.i)]);






        }
# 179 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            LU.y = ((coord){1.,1.,1.}).y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - (1)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(divtauu.y.i)]*dt/_const_rho
                     -(- ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]/eta_s + conv.y )))*dt;
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.y.i)] - LU.y;
            if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.y.i)]) > _maxres) _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.y.i)]);






        }
# 179 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            LU.z = ((coord){1.,1.,1.}).z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - (1)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(divtauu.z.i)]*dt/_const_rho
                     -(- ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]/eta_s + conv.z )))*dt;
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.z.i)] - LU.z;
            if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.z.i)]) > _maxres) _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.z.i)]);






        }}
    } } } } }; }
if (((target_U.x).i >= 65536) && ((rho).i >= 65536)) {
const struct { double x, y, z; } _const_target_U = {_constant[target_U.x.i -65536], _constant[target_U.y.i - 65536], _constant[target_U.z.i - 65536]};
(void)(_const_target_U);
# 213 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
const double _const_rho = _constant[rho.i -65536];
(void)(_const_rho);
# 164 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 164 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {

        conv.x = (_const_target_U.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + _const_target_U.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)]) + _const_target_U.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)]))/(2.0*Delta);

        conv.y = (_const_target_U.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + _const_target_U.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)]) + _const_target_U.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.y.i)]))/(2.0*Delta);


        conv.z = (_const_target_U.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + _const_target_U.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.z.i)]) + _const_target_U.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)]))/(2.0*Delta);







        {
# 179 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            LU.x = ((coord){1.,1.,1.}).x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - (1)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(divtauu.x.i)]*dt/_const_rho
                     -(- ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]/eta_s + conv.x )))*dt;
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.x.i)] - LU.x;
            if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.x.i)]) > _maxres) _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.x.i)]);






        }
# 179 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            LU.y = ((coord){1.,1.,1.}).y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - (1)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(divtauu.y.i)]*dt/_const_rho
                     -(- ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]/eta_s + conv.y )))*dt;
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.y.i)] - LU.y;
            if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.y.i)]) > _maxres) _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.y.i)]);






        }
# 179 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            LU.z = ((coord){1.,1.,1.}).z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] - (1)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(divtauu.z.i)]*dt/_const_rho
                     -(- ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]/eta_s + conv.z )))*dt;
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.z.i)] - LU.z;
            if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.z.i)]) > _maxres) _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(res.z.i)]);






        }}
    } } } } }; } if (_maxres > maxres) maxres = _maxres;
                                       ;



}
# 191 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 }
    boundary (resl);
    fprintf(__stderrp, "visc: maxres=%15.12g maxb=%15.12g maxres/maxb=%15.12g\n", maxres, maxb, maxres/maxb);

    { double _ret = maxres/maxb; delete (((scalar []){divtauu.x,divtauu.y,divtauu.z,{-1}})); return _ret; }

 delete (((scalar []){divtauu.x,divtauu.y,divtauu.z,{-1}})); }




mgstats viscosity (struct Viscosity p){ ;
# 211 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 vector u = p.u, r= new_vector("r");
     {
if (!((target_U.x).i >= 65536)) {
# 212 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 212 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {
# 212 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + (+ ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.x.i)])/eta_s))*dt;}
# 212 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + (+ ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.y.i)])/eta_s))*dt;}
# 212 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + (+ ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(target_U.z.i)])/eta_s))*dt;}} } } } }; }
if (((target_U.x).i >= 65536)) {
const struct { double x, y, z; } _const_target_U = {_constant[target_U.x.i -65536], _constant[target_U.y.i - 65536], _constant[target_U.z.i - 65536]};
(void)(_const_target_U);
# 212 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 212 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 {
# 212 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + (+ ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(_const_target_U.x)/eta_s))*dt;}
# 212 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + (+ ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(_const_target_U.y)/eta_s))*dt;}
# 212 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + (+ ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(_const_target_U.z)/eta_s))*dt;}} } } } }; } }
    vector mu = p.mu;
    scalar rho = p.rho;
    restriction (((scalar []){mu.x,mu.y,mu.z,rho,{-1}}));
    if (relative_residual_viscous) {
        double maxb = 0;
         {


                  {
double _maxb = maxb;
# 218 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 218 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
{
            if (fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.x.i)]) > _maxb) _maxb = fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(r.x.i)]);
        } } } } }; if (_maxb > maxb) maxb = _maxb;
                                     ;



}
# 220 "/Users/weugene/basilisk/work/src_local/viscosity-weugene.h"
 }
        if (maxb < 1e-12) maxb = 1;
        p.maxb = maxb;
    }else{
        p.maxb = 1;
    }
    fprintf(__stderrp, "maxb = %g\n", p.maxb);
    { mgstats _ret = mg_solve ((struct MGSolve){(scalar *)((vector []){{u.x,u.y,u.z},{{-1},{-1},{-1}}}), (scalar *)((vector []){{r.x,r.y,r.z},{{-1},{-1},{-1}}}), residual_viscosity, relax_viscosity, &p, p.nrelax, p.res}); delete (((scalar []){r.x,r.y,r.z,{-1}})); ; return _ret; }
 delete (((scalar []){r.x,r.y,r.z,{-1}})); ; }
# 45 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
# 1 "./utils-weugene.h"
# 1 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
void MinMaxValues(scalar * list, double * arr_eps) {
    double arr[10][2];
    int ilist = 0;
    if (list) for (scalar s = *list, *_i94 = list; ((scalar *)&s)->i >= 0; s = *++_i94) {
        double mina= ((double)1e30), maxa= -((double)1e30);
         {


                  {
double _mina = mina; double _maxa = maxa;
# 6 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 6 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
{
            if (fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]) < _mina) _mina = fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]);
            if (fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]) > _maxa) _maxa = fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]);
        } } } } }; if (_mina < mina) mina = _mina;
                                     ;
                  if (_maxa > maxa) maxa = _maxa;
                                     ;



}
# 9 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
 }




        arr[ilist][0] = mina;
        arr[ilist][1] = maxa;
        ilist++;

    }
    int i = 0;
    if (list) for (scalar s = *list, *_i95 = list; ((scalar *)&s)->i >= 0; s = *++_i95){





        arr_eps[i] *= 0.5*(arr[i][0] + arr[i][1]);


        fprintf(__stderrp, "MinMaxValues: name=%s, min=%g, max=%g, eps=%g\n", _attribute[s.i].name, arr[i][0], arr[i][1], arr_eps[i]);

        i++;
    }
}

int count_cells(double t, int i){
    int tnc = 0, nc = 0;
     {


                  {
double _tnc = tnc;
# 37 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 37 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"

        _tnc++; } } } }; tnc += _tnc;
                                    ;



}
# 38 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
 }
# 48 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
 printf("i %d t %g total num cells %d\n", i, t, tnc);

    fflush(__stdoutp);
    return tnc;
}

stats statsf_weugene (scalar f, scalar fs)
{
    double dvr, val, min = 1e100, max = -1e100, sum = 0., sum2 = 0., volume = 0.;
     {


                  {
double _sum = sum; double _sum2 = sum2; double _volume = volume; double _max = max; double _min = min;
# 57 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"

if (!((cm).i >= 65536)) {
# 57 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 58 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
{
        dvr = (((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)])*(1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)]);
        val = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]*(1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)]);
        _volume += dvr;
        _sum += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]*dvr;
        _sum2 += ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]))*dvr;
        if (val > _max) _max = val;
        if (val < _min) _min = val;
    } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 57 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 58 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
{
        dvr = (((Delta)*(Delta)*(Delta))*_const_cm)*(1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)]);
        val = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]*(1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)]);
        _volume += dvr;
        _sum += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]*dvr;
        _sum2 += ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]))*dvr;
        if (val > _max) _max = val;
        if (val < _min) _min = val;
    } } } } }; } sum += _sum;
                                    ;
                  sum2 += _sum2;
                                     ;
                  volume += _volume;
                                       ;
                  if (_max > max) max = _max;
                                    ;
                  if (_min < min) min = _min;
                                    ;



}
# 66 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
 }
 if (volume > 0.){
     sum /= volume; sum2 /= volume;
 }
 sum2 -= ((sum)*(sum));
 fprintf(__stderrp, "***: %g %g\n", sum, sum2);
 stats s;
 s.min = min, s.max = max, s.sum = sum, s.volume = volume;
 s.stddev = sum2 > 0. ? sqrt(sum2) : 0.;
    return s;
}


stats statsf_weugene2 (scalar f, scalar fs)
{
    double dvr, min = 1e100, max = -1e100, sum = 0., sum2 = 0., volume = 0.;
     {


                  {
double _sum = sum; double _sum2 = sum2; double _volume = volume; double _max = max; double _min = min;
# 82 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"

if (!((cm).i >= 65536)) {
# 82 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 83 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)] == 0.) {
        dvr = (((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)])*(1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)]);
        _volume += dvr;
        _sum += dvr*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)];
        _sum2 += dvr*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]));
        if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] > _max) _max = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)];
        if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] < _min) _min = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)];
    } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 82 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 83 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)] == 0.) {
        dvr = (((Delta)*(Delta)*(Delta))*_const_cm)*(1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)]);
        _volume += dvr;
        _sum += dvr*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)];
        _sum2 += dvr*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]));
        if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] > _max) _max = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)];
        if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] < _min) _min = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)];
    } } } } }; } sum += _sum;
                                    ;
                  sum2 += _sum2;
                                     ;
                  volume += _volume;
                                       ;
                  if (_max > max) max = _max;
                                    ;
                  if (_min < min) min = _min;
                                    ;



}
# 91 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
 }
 if (volume > 0.){
     sum /= volume; sum2 /= volume;
 }
 sum2 -= ((sum)*(sum));
    fprintf(__stderrp, "sum=%g\n", sum);
    stats s;
    s.min = min, s.max = max, s.sum = sum, s.volume = volume;
    return s;
}

norm normf_weugene (scalar f, scalar fs)
{
    double avg = 0., rms = 0., max = 0., volume = 0.;
     {


                  {
double _max = max; double _avg = avg; double _rms = rms; double _volume = volume;
# 105 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"

if (!((cm).i >= 65536)) {
# 105 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 106 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
{
        double dvr = (((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)])*(1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)]);
        double v = fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)])*(1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)]);
        if (v > _max) _max = v;
        _volume += dvr;
        _avg += dvr*v;
        _rms += dvr*((v)*(v));
    } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 105 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 106 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
{
        double dvr = (((Delta)*(Delta)*(Delta))*_const_cm)*(1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)]);
        double v = fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)])*(1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)]);
        if (v > _max) _max = v;
        _volume += dvr;
        _avg += dvr*v;
        _rms += dvr*((v)*(v));
    } } } } }; } if (_max > max) max = _max;
                                    ;
                  avg += _avg;
                                    ;
                  rms += _rms;
                                    ;
                  volume += _volume;
                                       ;



}
# 113 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
 }
    norm n;
    n.avg = volume ? avg/volume : 0.;
    n.rms = volume ? sqrt(rms/volume) : 0.;
    n.max = max;
    n.volume = volume;
    return n;
}

double change_weugene (scalar s, scalar sn, scalar fs)
{
    double max = 0., ds;
     {


                  {
double _max = max;
# 125 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 125 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
 {
        ds = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(sn.i)])*(1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)]);
        if (ds > _max)
            _max = ds;
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(sn.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)];
    } } } } }; if (_max > max) max = _max;
                                    ;



}
# 130 "/Users/weugene/basilisk/work/src_local/utils-weugene.h"
 }
    return max;
}
# 46 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
# 57 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
scalar p= {4};
vector u= {{5},{6},{7}}, g= {{8},{9},{10}};
scalar pf= {11};
vector uf= {{12},{13},{14}};
# 83 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 vector mu = {{65536 + 0},{65536 + 1},{65536 + 2}}, a = {{65536 + 0},{65536 + 1},{65536 + 2}}, alpha = {{65536 + 3},{65536 + 4},{65536 + 5}}, kappa = {{65536 + 0},{65536 + 1},{65536 + 2}};
 scalar rho = {(65536 + 6)};
mgstats mgp, mgpf, mgu;
_Bool stokes = 0;
# 104 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
static void _set_boundary0 (void) { _attribute[p.i].boundary[right] = _boundary0; _attribute[p.i].boundary_homogeneous[right] = _boundary0_homogeneous; }
static void _set_boundary1 (void) { _attribute[p.i].boundary[left] = _boundary1; _attribute[p.i].boundary_homogeneous[left] = _boundary1_homogeneous; }
# 114 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
static void _set_boundary2 (void) { _attribute[p.i].boundary[top] = _boundary2; _attribute[p.i].boundary_homogeneous[top] = _boundary2_homogeneous; }
static void _set_boundary3 (void) { _attribute[p.i].boundary[bottom] = _boundary3; _attribute[p.i].boundary_homogeneous[bottom] = _boundary3_homogeneous; }


static void _set_boundary4 (void) { _attribute[p.i].boundary[front] = _boundary4; _attribute[p.i].boundary_homogeneous[front] = _boundary4_homogeneous; }
static void _set_boundary5 (void) { _attribute[p.i].boundary[back] = _boundary5; _attribute[p.i].boundary_homogeneous[back] = _boundary5_homogeneous; }
# 139 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
static int defaults_0_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i = 0); *ip = i; *tp = t; return ret; } static int defaults_0 (const int i, const double t, Event * _ev) { ;
{

  CFL = 0.8;




  _attribute[p.i].nodump = _attribute[pf.i].nodump = 1;




  if (alpha.x.i == unityf.x.i) {
    alpha = fm;
    rho = cm;
  }
  else if (!((alpha.x).i >= 65536)) {
    vector alphav = alpha;
     {
if (!((fm.x).i >= 65536)) {
# 158 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 158 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 158 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alphav.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 158 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 158 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alphav.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]; } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 158 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 158 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alphav.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)]; } }} } } }
# 159 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ; }
if (((fm.x).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 158 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 158 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 158 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alphav.x.i)] = _const_fm.x; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 158 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 158 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alphav.y.i)] = _const_fm.y; } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 158 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 158 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alphav.z.i)] = _const_fm.z; } }} } } }
# 159 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ; } }
    boundary ((scalar *)((vector []){{alpha.x,alpha.y,alpha.z},{{-1},{-1},{-1}}}));
  }






  _attribute[uf.x.i].refine = refine_face_solenoidal;
# 186 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ; } return 0; }





double dtmax;

static int init_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i = 0); *ip = i; *tp = t; return ret; } static int init (const int i, const double t, Event * _ev) { ;
{
  boundary ((scalar *)((vector []){{u.x,u.y,u.z},{{-1},{-1},{-1}}}));
                                                          ;
   {
if (!((fm.x).i >= 65536)) {
# 198 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 198 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 198 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0 -1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/2.); } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 198 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 198 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0 -1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/2.); } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 198 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 198 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)]*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0 -1]) + sizeof(Cell)))[(u.z.i)])/2.); } }} } } }
# 199 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ; }
if (((fm.x).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 198 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 198 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 198 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] = _const_fm.x*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0 -1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/2.); } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 198 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 198 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] = _const_fm.y*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0 -1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/2.); } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 198 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 198 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] = _const_fm.z*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0 -1]) + sizeof(Cell)))[(u.z.i)])/2.); } }} } } }
# 199 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ; } }
  boundary ((scalar *)((vector []){{uf.x,uf.y,uf.z},{{-1},{-1},{-1}}}));




  event ("properties");





  dtmax = DT;
  event ("stability");
                                                                                    ; } return 0; }
# 222 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
static int set_dtmax_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int set_dtmax (const int i, const double t, Event * _ev) { ; dtmax = DT; ; return 0; }

static int stability_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int stability (const int i, const double t, Event * _ev) { ; {
  dt = dtnext (stokes ? dtmax : timestep (uf, dtmax));

  fprintf(__stderrp, "stability: dt=%g DT=%g dtmax=%g", dt, DT, dtmax );
                                                                                         ; } return 0; }







static int vof_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int vof (const int i, const double t, Event * _ev) { ; ; ; return 0; }
static int tracer_advection_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int tracer_advection (const int i, const double t, Event * _ev) { ; ; ; return 0; }






static int properties_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int properties (const int i, const double t, Event * _ev) { ; {
  boundary (((scalar []){alpha.x,alpha.y,alpha.z,mu.x,mu.y,mu.z,rho,kappa.x,kappa.y,kappa.z,{-1}}));
                                                                                          ; } return 0; }

static int tracer_diffusion_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int tracer_diffusion (const int i, const double t, Event * _ev) { ; ; ; return 0; }
# 260 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
void prediction()
{
  vector du;
  {
# 263 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 {
    scalar s = new_scalar("s");
    du.x = s;
  }
# 263 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 {
    scalar s = new_scalar("s");
    du.y = s;
  }
# 263 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 {
    scalar s = new_scalar("s");
    du.z = s;
  }}

  if (_attribute[u.x.i].gradient)
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 269 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

      {
# 270 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 {





          ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(du.x.i)] = _attribute[u.x.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/Delta;
      }
# 270 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 {





          ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(du.y.i)] = _attribute[u.y.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/Delta;
      }
# 270 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 {





          ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(du.z.i)] = _attribute[u.z.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)])/Delta;
      }} } } } }; }
  else
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 279 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

        {
# 280 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 {
# 291 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(du.x.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/(2.*Delta);
    }
# 280 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 {
# 291 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(du.y.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/(2.*Delta);
    }
# 280 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 {
# 291 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(du.z.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)])/(2.*Delta);
    }} } } } }; }
  boundary ((scalar *)((vector []){{du.x,du.y,du.z},{{-1},{-1},{-1}}}));

                                                          ;
   {
if (!((fm.x).i >= 65536)) {
# 296 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 296 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 296 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 {
    double un = dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/(2.*Delta), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.x.i)])*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(du.x.i)]*Delta/2.;

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]) {
      double fyy = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)];
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] -= dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]*fyy/(2.*Delta);
    }


    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+1]) + sizeof(Cell)))[(fm.z.i)]) {
      double fzz = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)];
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] -= dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]*fzz/(2.*Delta);
    }

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] *= ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)];
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 296 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 296 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 {
    double un = dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/(2.*Delta), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(g.y.i)])*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(du.y.i)]*Delta/2.;

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(fm.z.i)] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+1]) + sizeof(Cell)))[(fm.z.i)]) {
      double fyy = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.z.i)] < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+1]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.y.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+-1]) + sizeof(Cell)))[(u.y.i)];
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] -= dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.z.i)]*fyy/(2.*Delta);
    }


    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(fm.x.i)] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]) {
      double fzz = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.x.i)] < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.y.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.y.i)];
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] -= dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.x.i)]*fzz/(2.*Delta);
    }

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] *= ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)];
  } } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 296 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 296 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 {
    double un = dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)])/(2.*Delta), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.z.i)] + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(g.z.i)])*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(du.z.i)]*Delta/2.;

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(fm.x.i)] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+i]) + sizeof(Cell)))[(fm.x.i)]) {
      double fyy = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.x.i)] < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.z.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.z.i)];
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] -= dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.x.i)]*fyy/(2.*Delta);
    }


    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(fm.y.i)] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+i]) + sizeof(Cell)))[(fm.y.i)]) {
      double fzz = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.y.i)] < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+i]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.z.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+i]) + sizeof(Cell)))[(u.z.i)];
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] -= dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.y.i)]*fzz/(2.*Delta);
    }

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] *= ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)];
  } } }} } } }
# 313 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ; }
if (((fm.x).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 296 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 296 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 296 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 {
    double un = dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/(2.*Delta), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.x.i)])*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(du.x.i)]*Delta/2.;

    if (_const_fm.y && _const_fm.y) {
      double fyy = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.x.i)];
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] -= dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]*fyy/(2.*Delta);
    }


    if (_const_fm.z && _const_fm.z) {
      double fzz = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+1]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.x.i)];
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] -= dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]*fzz/(2.*Delta);
    }

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] *= _const_fm.x;
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 296 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 296 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 {
    double un = dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/(2.*Delta), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(g.y.i)])*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(du.y.i)]*Delta/2.;

    if (_const_fm.z && _const_fm.z) {
      double fyy = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.z.i)] < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+1]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.y.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+-1]) + sizeof(Cell)))[(u.y.i)];
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] -= dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.z.i)]*fyy/(2.*Delta);
    }


    if (_const_fm.x && _const_fm.x) {
      double fzz = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.x.i)] < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.y.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.y.i)];
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] -= dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(u.x.i)]*fzz/(2.*Delta);
    }

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] *= _const_fm.y;
  } } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 296 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 296 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 {
    double un = dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(u.z.i)])/(2.*Delta), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.z.i)] + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(g.z.i)])*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(du.z.i)]*Delta/2.;

    if (_const_fm.x && _const_fm.x) {
      double fyy = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.x.i)] < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.z.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.z.i)];
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] -= dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.x.i)]*fyy/(2.*Delta);
    }


    if (_const_fm.y && _const_fm.y) {
      double fzz = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.y.i)] < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+i]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.z.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+i]) + sizeof(Cell)))[(u.z.i)];
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] -= dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(u.y.i)]*fzz/(2.*Delta);
    }

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] *= _const_fm.z;
  } } }} } } }
# 313 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ; } }
  boundary ((scalar *)((vector []){{uf.x,uf.y,uf.z},{{-1},{-1},{-1}}}));

  delete ((scalar *)((vector []){{du.x,du.y,du.z},{{-1},{-1},{-1}}}));
}
# 328 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
static int advection_term_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int advection_term (const int i, const double t, Event * _ev) { ;
{
  if (!stokes) {
    prediction();



    mgpf = project ((struct Project){uf, pf, alpha, dt/2., mgpf.nrelax});

    advection ((struct Advection){(scalar *)((vector []){{u.x,u.y,u.z},{{-1},{-1},{-1}}}), uf, dt, (scalar *)((vector []){{g.x,g.y,g.z},{{-1},{-1},{-1}}})});

  }
                                                                                              ; } return 0; }







static void correction (double dt)
{
  { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 350 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

     {
# 351 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] += dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.x.i)];
# 351 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] += dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.y.i)];
# 351 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] += dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.z.i)];}; } } } }; }
 boundary ((scalar *)((vector []){{u.x,u.y,u.z},{{-1},{-1},{-1}}}));

}
# 364 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
static int viscous_term_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int viscous_term (const int i, const double t, Event * _ev) { ;
{
  if ((((mu.x).i >= 65536) ? _constant[(mu.x).i - 65536] : ((double)1e30)) != 0.) {

    correction (dt);
    mgu = viscosity ((struct Viscosity){u, mu, rho, dt, mgu.nrelax});
    correction (-dt);

  }




  if (!((a.x).i >= 65536)) {
    vector af = a;
                                                            ;
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 380 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 380 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(af.x.i)] = 0.; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 380 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 380 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(af.y.i)] = 0.; } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 380 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 380 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(af.z.i)] = 0.; } }} } } }
# 381 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ; }
  }
                                                                                            ; } return 0; }
# 404 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
static int acceleration_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int acceleration (const int i, const double t, Event * _ev) { ;
{
                                                          ;
  vector ia =a;
   {
if (!((fm.x).i >= 65536) && !((a.x).i >= 65536)) {
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0 -1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/2.) + dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.x.i)]);
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0 -1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/2.) + dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.y.i)]);
  } } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)]*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0 -1]) + sizeof(Cell)))[(u.z.i)])/2.) + dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.z.i)]);
  } } }} } } }
# 410 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ; }
if (((fm.x).i >= 65536) && !((a.x).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] = _const_fm.x*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0 -1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/2.) + dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.x.i)]);
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] = _const_fm.y*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0 -1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/2.) + dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.y.i)]);
  } } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] = _const_fm.z*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0 -1]) + sizeof(Cell)))[(u.z.i)])/2.) + dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.z.i)]);
  } } }} } } }
# 410 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ; }
if (!((fm.x).i >= 65536) && ((a.x).i >= 65536)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0 -1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/2.) + dt*_const_a.x);
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0 -1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/2.) + dt*_const_a.y);
  } } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)]*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0 -1]) + sizeof(Cell)))[(u.z.i)])/2.) + dt*_const_a.z);
  } } }} } } }
# 410 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ; }
if (((fm.x).i >= 65536) && ((a.x).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 432 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] = _const_fm.x*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0 -1][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)])/2.) + dt*_const_a.x);
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] = _const_fm.y*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0 -1] [point.k+0]) + sizeof(Cell)))[(u.y.i)])/2.) + dt*_const_a.y);
  } } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 408 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)] = _const_fm.z*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0 -1]) + sizeof(Cell)))[(u.z.i)])/2.) + dt*_const_a.z);
  } } }} } } }
# 410 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ; } }
  boundary ((scalar *)((vector []){{uf.x,uf.y,uf.z},{a.x,a.y,a.z},{{-1},{-1},{-1}}}));

                                                                                            ; } return 0; }
# 422 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
void centered_gradient (scalar p, vector g)
{





  vector gf= new_face_vector("gf");
   {
if (!((fm.x).i >= 65536) && !((a.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)])/Delta; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(p.i)])/Delta; } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(p.i)])/Delta; } }} } } }
# 431 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ; }
if (((fm.x).i >= 65536) && !((a.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.x.i)] = _const_fm.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)])/Delta; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.y.i)] = _const_fm.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(p.i)])/Delta; } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.z.i)] = _const_fm.z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(p.i)])/Delta; } }} } } }
# 431 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ; }
if (!((fm.x).i >= 65536) && ((a.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 451 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]*_const_a.x - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)])/Delta; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]*_const_a.y - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(p.i)])/Delta; } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)]*_const_a.z - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(p.i)])/Delta; } }} } } }
# 431 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ; }
if (((fm.x).i >= 65536) && ((a.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 453 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.x.i)] = _const_fm.x*_const_a.x - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)])/Delta; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.y.i)] = _const_fm.y*_const_a.y - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(p.i)])/Delta; } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.z.i)] = _const_fm.z*_const_a.z - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(p.i)])/Delta; } }} } } }
# 431 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ; }
if (!((fm.x).i >= 65536) && !((a.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 469 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.x.i)] - _const_alpha.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)])/Delta; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.y.i)] - _const_alpha.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(p.i)])/Delta; } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.z.i)] - _const_alpha.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(p.i)])/Delta; } }} } } }
# 431 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ; }
if (((fm.x).i >= 65536) && !((a.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 471 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.x.i)] = _const_fm.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.x.i)] - _const_alpha.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)])/Delta; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.y.i)] = _const_fm.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.y.i)] - _const_alpha.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(p.i)])/Delta; } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.z.i)] = _const_fm.z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.z.i)] - _const_alpha.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(p.i)])/Delta; } }} } } }
# 431 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ; }
if (!((fm.x).i >= 65536) && ((a.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 451 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 471 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]*_const_a.x - _const_alpha.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)])/Delta; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]*_const_a.y - _const_alpha.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(p.i)])/Delta; } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)]*_const_a.z - _const_alpha.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(p.i)])/Delta; } }} } } }
# 431 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ; }
if (((fm.x).i >= 65536) && ((a.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 453 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 473 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.x.i)] = _const_fm.x*_const_a.x - _const_alpha.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)])/Delta; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.y.i)] = _const_fm.y*_const_a.y - _const_alpha.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(p.i)])/Delta; } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{
# 430 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.z.i)] = _const_fm.z*_const_a.z - _const_alpha.z*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(p.i)])/Delta; } }} } } }
# 431 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 ; } }
  boundary_flux (((vector []){{gf.x,gf.y,gf.z},{{-1},{-1},{-1}}}));





                                                       ;
   {
if (!((fm.x).i >= 65536)) {
# 439 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 439 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    {
# 440 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.x.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.x.i)])/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)] + 1e-12);
# 440 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.y.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(gf.y.i)])/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(fm.y.i)] + 1e-12);
# 440 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.z.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(gf.z.i)])/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(fm.z.i)] + 1e-12);}; } } } }; }
if (((fm.x).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 439 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 439 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    {
# 440 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.x.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.x.i)])/(_const_fm.x + _const_fm.x + 1e-12);
# 440 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.y.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(gf.y.i)])/(_const_fm.y + _const_fm.y + 1e-12);
# 440 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.z.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(gf.z.i)])/(_const_fm.z + _const_fm.z + 1e-12);}; } } } }; } }
  boundary ((scalar *)((vector []){{g.x,g.y,g.z},{{-1},{-1},{-1}}}));
 delete (((scalar []){gf.x,gf.y,gf.z,{-1}})); }






static int projection_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int projection (const int i, const double t, Event * _ev) { ;
{



  mgp = project ((struct Project){uf, p, alpha, dt, mgp.nrelax});

  centered_gradient (p, g);



   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 461 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

    {
# 462 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] += dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.x.i)]*(1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)]);
# 462 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] += dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.y.i)]*(1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)]);
# 462 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] += dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(g.z.i)]*(1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)]);}; } } } }; }
  boundary ((scalar *)((vector []){{u.x,u.y,u.z},{{-1},{-1},{-1}}}));

                                                                                          ; } return 0; }
# 477 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
static int end_timestep_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int end_timestep (const int i, const double t, Event * _ev) { ; ; ; return 0; }




static int vtk_file_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int vtk_file (const int i, const double t, Event * _ev) { ; ; ; return 0; }
# 491 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
static int adapt_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int adapt (const int i, const double t, Event * _ev) { ; {
# 507 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
 event ("properties");
                                                                                     ; } return 0; }
# 20 "tube_bp_rel.c"
# 1 "./two-phase.h"
# 1 "/Users/weugene/basilisk/src/two-phase.h"
# 13 "/Users/weugene/basilisk/src/two-phase.h"
# 1 "./vof.h"
# 1 "/Users/weugene/basilisk/src/vof.h"
# 27 "/Users/weugene/basilisk/src/vof.h"
# 1 "./fractions.h"
# 1 "/Users/weugene/basilisk/src/fractions.h"
# 12 "/Users/weugene/basilisk/src/fractions.h"
# 1 "./geometry.h"
# 1 "/Users/weugene/basilisk/src/geometry.h"
# 28 "/Users/weugene/basilisk/src/geometry.h"
double line_alpha (double c, coord n)
{
  double alpha, n1, n2;

  n1 = fabs (n.x); n2 = fabs (n.y);
  if (n1 > n2)
    { double tmp = n1; n1 = n2; n2 = tmp; };

  c = ((c) < (0.) ? (0.) : (c) > (1.) ? (1.) : (c));
  double v1 = n1/2.;
  if (c <= v1/n2)
    alpha = sqrt (2.*c*n1*n2);
  else if (c <= 1. - v1/n2)
    alpha = c*n2 + v1;
  else
    alpha = n1 + n2 - sqrt (2.*n1*n2*(1. - c));

  if (n.x < 0.)
    alpha += n.x;
  if (n.y < 0.)
    alpha += n.y;

  return alpha - (n.x + n.y)/2.;
}



double plane_alpha (double c, coord n)
{
  double alpha;
  coord n1;

  n1.x = fabs (n.x); n1.y = fabs (n.y); n1.z = fabs (n.z);

  double m1, m2, m3;
  m1 = ((n1.x) < (n1.y) ? (n1.x) : (n1.y));
  m3 = ((n1.x) > (n1.y) ? (n1.x) : (n1.y));
  m2 = n1.z;
  if (m2 < m1) {
    double tmp = m1;
    m1 = m2;
    m2 = tmp;
  }
  else if (m2 > m3) {
    double tmp = m3;
    m3 = m2;
    m2 = tmp;
  }
  double m12 = m1 + m2;
  double pr = ((6.*m1*m2*m3) > (1e-50) ? (6.*m1*m2*m3) : (1e-50));
  double V1 = m1*m1*m1/pr;
  double V2 = V1 + (m2 - m1)/(2.*m3), V3;
  double mm;
  if (m3 < m12) {
    mm = m3;
    V3 = (m3*m3*(3.*m12 - m3) + m1*m1*(m1 - 3.*m3) + m2*m2*(m2 - 3.*m3))/pr;
  }
  else {
    mm = m12;
    V3 = mm/(2.*m3);
  }

  c = ((c) < (0.) ? (0.) : (c) > (1.) ? (1.) : (c));
  double ch = ((c) < (1. - c) ? (c) : (1. - c));
  if (ch < V1)
    alpha = pow (pr*ch, 1./3.);
  else if (ch < V2)
    alpha = (m1 + sqrt(m1*m1 + 8.*m2*m3*(ch - V1)))/2.;
  else if (ch < V3) {
    double p12 = sqrt (2.*m1*m2);
    double q = 3.*(m12 - 2.*m3*ch)/(4.*p12);
    double teta = acos(((q) < (-1.) ? (-1.) : (q) > (1.) ? (1.) : (q)))/3.;
    double cs = cos(teta);
    alpha = p12*(sqrt(3.*(1. - cs*cs)) - cs) + m12;
  }
  else if (m12 < m3)
    alpha = m3*ch + mm/2.;
  else {
    double p = m1*(m2 + m3) + m2*m3 - 1./4., p12 = sqrt(p);
    if (p==0) fprintf(__stderrp,"p=%g p1=%g\n", p, p12);
    double q = 3.*m1*m2*m3*(1./2. - ch)/(2.*p*p12 + 1e-30);
    double teta = acos(((q) < (-1.) ? (-1.) : (q) > (1.) ? (1.) : (q)))/3.;
    double cs = cos(teta);
    alpha = p12*(sqrt(3.*(1. - cs*cs)) - cs) + 1./2.;
  }
  if (c > 1./2.) alpha = 1. - alpha;

  if (n.x < 0.)
    alpha += n.x;
  if (n.y < 0.)
    alpha += n.y;
  if (n.z < 0.)
    alpha += n.z;

  return alpha - (n.x + n.y + n.z)/2.;;
}
# 134 "/Users/weugene/basilisk/src/geometry.h"
double line_area (double nx, double ny, double alpha)
{
  double a, v, area;

  alpha += (nx + ny)/2.;
  if (nx < 0.) {
    alpha -= nx;
    nx = - nx;
  }
  if (ny < 0.) {
    alpha -= ny;
    ny = - ny;
  }

  if (alpha <= 0.)
    return 0.;

  if (alpha >= nx + ny)
    return 1.;

  if (nx < 1e-10)
    area = alpha/ny;
  else if (ny < 1e-10)
    area = alpha/nx;
  else {
    v = ((alpha)*(alpha));

    a = alpha - nx;
    if (a > 0.)
      v -= a*a;

    a = alpha - ny;
    if (a > 0.)
      v -= a*a;

    area = v/(2.*nx*ny);
  }

  return ((area) < (0.) ? (0.) : (area) > (1.) ? (1.) : (area));
}



double plane_volume (coord n, double alpha)
{
  double al = alpha + (n.x + n.y + n.z)/2. +
    ((0.) > (-n.x) ? (0.) : (-n.x)) + ((0.) > (-n.y) ? (0.) : (-n.y)) + ((0.) > (-n.z) ? (0.) : (-n.z));
  if (al <= 0.)
    return 0.;
  double tmp = fabs(n.x) + fabs(n.y) + fabs(n.z);
  if (al >= tmp)
    return 1.;
  if (tmp < 1e-10)
    return 0.;
  double n1 = fabs(n.x)/tmp;
  double n2 = fabs(n.y)/tmp;
  double n3 = fabs(n.z)/tmp;
  al = ((0.) > (((1.) < (al/tmp) ? (1.) : (al/tmp))) ? (0.) : (((1.) < (al/tmp) ? (1.) : (al/tmp))));
  double al0 = ((al) < (1. - al) ? (al) : (1. - al));
  double b1 = ((n1) < (n2) ? (n1) : (n2));
  double b3 = ((n1) > (n2) ? (n1) : (n2));
  double b2 = n3;
  if (b2 < b1) {
    tmp = b1;
    b1 = b2;
    b2 = tmp;
  }
  else if (b2 > b3) {
    tmp = b3;
    b3 = b2;
    b2 = tmp;
  }
  double b12 = b1 + b2;
  double bm = ((b12) < (b3) ? (b12) : (b3));
  double pr = ((6.*b1*b2*b3) > (1e-50) ? (6.*b1*b2*b3) : (1e-50));
  if (al0 < b1)
    tmp = al0*al0*al0/pr;
  else if (al0 < b2)
    tmp = 0.5*al0*(al0 - b1)/(b2*b3) + b1*b1*b1/pr;
  else if (al0 < bm)
    tmp = (al0*al0*(3.*b12 - al0) + b1*b1*(b1 - 3.*al0) +
    b2*b2*(b2 - 3.*al0))/pr;
  else if (b12 < b3)
    tmp = (al0 - 0.5*bm)/b3;
  else
    tmp = (al0*al0*(3. - 2.*al0) + b1*b1*(b1 - 3.*al0) +
    b2*b2*(b2 - 3.*al0) + b3*b3*(b3 - 3.*al0))/pr;

  double volume = al <= 0.5 ? tmp : 1. - tmp;
  return ((volume) < (0.) ? (0.) : (volume) > (1.) ? (1.) : (volume));
}
# 238 "/Users/weugene/basilisk/src/geometry.h"
double rectangle_fraction (coord n, double alpha, coord a, coord b)
{
  coord n1;
  {
# 241 "/Users/weugene/basilisk/src/geometry.h"
 {
    alpha -= n.x*(b.x + a.x)/2.;
    n1.x = n.x*(b.x - a.x);
  }
# 241 "/Users/weugene/basilisk/src/geometry.h"
 {
    alpha -= n.y*(b.y + a.y)/2.;
    n1.y = n.y*(b.y - a.y);
  }
# 241 "/Users/weugene/basilisk/src/geometry.h"
 {
    alpha -= n.z*(b.z + a.z)/2.;
    n1.z = n.z*(b.z - a.z);
  }}
  return plane_volume (n1, alpha);
}
# 278 "/Users/weugene/basilisk/src/geometry.h"
static coord cube_edge[12][2] = {
  {{0.,0.,0.},{1.,0.,0.}},{{0.,0.,1.},{1.,0.,1.}},
  {{0.,1.,1.},{1.,1.,1.}},{{0.,1.,0.},{1.,1.,0.}},
  {{0.,0.,0.},{0.,1.,0.}},{{0.,0.,1.},{0.,1.,1.}},
  {{1.,0.,1.},{1.,1.,1.}},{{1.,0.,0.},{1.,1.,0.}},
  {{0.,0.,0.},{0.,0.,1.}},{{1.,0.,0.},{1.,0.,1.}},
  {{1.,1.,0.},{1.,1.,1.}},{{0.,1.,0.},{0.,1.,1.}}
};




static int cube_connect[12][2][4] = {
  {{9, 1, 8}, {4, 3, 7}},
  {{6, 2, 5}, {8, 0, 9}},
  {{10, 3, 11}, {5, 1, 6}},
  {{7, 0, 4}, {11, 2, 10}},
  {{3, 7, 0}, {8, 5, 11}},
  {{11, 4, 8}, {1, 6, 2}},
  {{2, 5, 1}, {9, 7, 10}},
  {{10, 6, 9}, {0, 4, 3}},
  {{5, 11, 4}, {0, 9, 1}},
  {{1, 8, 0}, {7, 10, 6}},
  {{6, 9, 7}, {3, 11, 2}},
  {{2, 10, 3}, {4, 8, 5}}
};

int facets (coord n, double alpha, coord v[12], double h)
{
  coord a[12];
  int orient[12];

  for (int i = 0; i < 12; i++) {
    coord e, d;
    double den = 0., t = alpha;
    {
# 313 "/Users/weugene/basilisk/src/geometry.h"
 {
      d.x = h*(cube_edge[i][0].x - 0.5);
      e.x = h*(cube_edge[i][1].x - 0.5);
      den += n.x*(e.x - d.x);
      t -= n.x*d.x;
    }
# 313 "/Users/weugene/basilisk/src/geometry.h"
 {
      d.y = h*(cube_edge[i][0].y - 0.5);
      e.y = h*(cube_edge[i][1].y - 0.5);
      den += n.y*(e.y - d.y);
      t -= n.y*d.y;
    }
# 313 "/Users/weugene/basilisk/src/geometry.h"
 {
      d.z = h*(cube_edge[i][0].z - 0.5);
      e.z = h*(cube_edge[i][1].z - 0.5);
      den += n.z*(e.z - d.z);
      t -= n.z*d.z;
    }}
    orient[i] = -1;
    if (fabs (den) > 1e-10) {
      t /= den;
      if (t >= 0. && t < 1.) {
 double s = - alpha;
 {
# 324 "/Users/weugene/basilisk/src/geometry.h"
 {
   a[i].x = d.x + t*(e.x - d.x);
   s += n.x*e.x;
 }
# 324 "/Users/weugene/basilisk/src/geometry.h"
 {
   a[i].y = d.y + t*(e.y - d.y);
   s += n.y*e.y;
 }
# 324 "/Users/weugene/basilisk/src/geometry.h"
 {
   a[i].z = d.z + t*(e.z - d.z);
   s += n.z*e.z;
 }}
 orient[i] = (s > 0.);
      }
    }
  }

  for (int i = 0; i < 12; i++) {
    int nv = 0, e = i;
    while (orient[e] >= 0) {
      int m = 0, * ne = cube_connect[e][orient[e]];
      v[nv++] = a[e];
      orient[e] = -1;
      while (m < 3 && orient[e] < 0)
 e = ne[m++];
    }
    if (nv > 2)
      return nv;
  }
  return 0;
}






double line_length_center (coord m, double alpha, coord * p)
{
  alpha += (m.x + m.y)/2.;

  coord n = m;
  {
# 358 "/Users/weugene/basilisk/src/geometry.h"

    if (n.x < 0.) {
      alpha -= n.x;
      n.x = - n.x;
    }
# 358 "/Users/weugene/basilisk/src/geometry.h"

    if (n.y < 0.) {
      alpha -= n.y;
      n.y = - n.y;
    }}

  p->x = p->y = p->z = 0.;

  if (alpha <= 0. || alpha >= n.x + n.y)
    return 0.;

  {
# 369 "/Users/weugene/basilisk/src/geometry.h"

    if (n.x < 1e-4) {
      p->x = 0.;
      p->y = (m.y < 0. ? 1. - alpha : alpha) - 0.5;
      return 1.;
    }
# 369 "/Users/weugene/basilisk/src/geometry.h"

    if (n.y < 1e-4) {
      p->y = 0.;
      p->x = (m.x < 0. ? 1. - alpha : alpha) - 0.5;
      return 1.;
    }}

  if (alpha >= n.x) {
    p->x += 1.;
    p->y += (alpha - n.x)/n.y;
  }
  else
    p->x += alpha/n.x;

  double ax = p->x, ay = p->y;
  if (alpha >= n.y) {
    p->y += 1.;
    ay -= 1.;
    p->x += (alpha - n.y)/n.x;
    ax -= (alpha - n.y)/n.x;
  }
  else {
    p->y += alpha/n.y;
    ay -= alpha/n.y;
  }

  {
# 395 "/Users/weugene/basilisk/src/geometry.h"
 {
    p->x /= 2.;
    p->x = ((p->x) < (0.) ? (0.) : (p->x) > (1.) ? (1.) : (p->x));
    if (m.x < 0.)
      p->x = 1. - p->x;
    p->x -= 0.5;
  }
# 395 "/Users/weugene/basilisk/src/geometry.h"
 {
    p->y /= 2.;
    p->y = ((p->y) < (0.) ? (0.) : (p->y) > (1.) ? (1.) : (p->y));
    if (m.y < 0.)
      p->y = 1. - p->y;
    p->y -= 0.5;
  }}

  return sqrt (ax*ax + ay*ay);
}




double plane_area_center (coord m, double alpha, coord * p)
{
  {
# 411 "/Users/weugene/basilisk/src/geometry.h"

    if (fabs (m.x) < 1e-4) {
      coord n, q;
      ((double *)&n)[0] = m.y;
      ((double *)&n)[1] = m.z;
      double length = line_length_center (n, alpha, &q);
      p->x = 0.;
      p->y = ((double *)&q)[0];
      p->z = ((double *)&q)[1];
      return length;
    }
# 411 "/Users/weugene/basilisk/src/geometry.h"

    if (fabs (m.y) < 1e-4) {
      coord n, q;
      ((double *)&n)[0] = m.z;
      ((double *)&n)[1] = m.x;
      double length = line_length_center (n, alpha, &q);
      p->y = 0.;
      p->z = ((double *)&q)[0];
      p->x = ((double *)&q)[1];
      return length;
    }
# 411 "/Users/weugene/basilisk/src/geometry.h"

    if (fabs (m.z) < 1e-4) {
      coord n, q;
      ((double *)&n)[0] = m.x;
      ((double *)&n)[1] = m.y;
      double length = line_length_center (n, alpha, &q);
      p->z = 0.;
      p->x = ((double *)&q)[0];
      p->y = ((double *)&q)[1];
      return length;
    }}

  alpha += (m.x + m.y + m.z)/2.;
  coord n = m;
  {
# 425 "/Users/weugene/basilisk/src/geometry.h"

    if (n.x < 0.) {
      alpha -= n.x;
      n.x = - n.x;
    }
# 425 "/Users/weugene/basilisk/src/geometry.h"

    if (n.y < 0.) {
      alpha -= n.y;
      n.y = - n.y;
    }
# 425 "/Users/weugene/basilisk/src/geometry.h"

    if (n.z < 0.) {
      alpha -= n.z;
      n.z = - n.z;
    }}

  double amax = n.x + n.y + n.z;
  if (alpha < 0. || alpha > amax) {
    p->x = p->y = p->z = 0.;
    return 0.;
  }

  double area = ((alpha)*(alpha));
  p->x = p->y = p->z = area*alpha;

  {
# 440 "/Users/weugene/basilisk/src/geometry.h"
 {
    double b = alpha - n.x;
    if (b > 0.) {
      area -= b*b;
      p->x -= b*b*(2.*n.x + alpha);
      p->y -= b*b*b;
      p->z -= b*b*b;
    }
  }
# 440 "/Users/weugene/basilisk/src/geometry.h"
 {
    double b = alpha - n.y;
    if (b > 0.) {
      area -= b*b;
      p->y -= b*b*(2.*n.y + alpha);
      p->z -= b*b*b;
      p->x -= b*b*b;
    }
  }
# 440 "/Users/weugene/basilisk/src/geometry.h"
 {
    double b = alpha - n.z;
    if (b > 0.) {
      area -= b*b;
      p->z -= b*b*(2.*n.z + alpha);
      p->x -= b*b*b;
      p->y -= b*b*b;
    }
  }}

  amax = alpha - amax;
  {
# 451 "/Users/weugene/basilisk/src/geometry.h"
 {
    double b = amax + n.x;
    if (b > 0.) {
      area += b*b;
      p->y += b*b*(2.*n.y + alpha - n.z);
      p->z += b*b*(2.*n.z + alpha - n.y);
      p->x += b*b*b;
    }
  }
# 451 "/Users/weugene/basilisk/src/geometry.h"
 {
    double b = amax + n.y;
    if (b > 0.) {
      area += b*b;
      p->z += b*b*(2.*n.z + alpha - n.x);
      p->x += b*b*(2.*n.x + alpha - n.z);
      p->y += b*b*b;
    }
  }
# 451 "/Users/weugene/basilisk/src/geometry.h"
 {
    double b = amax + n.z;
    if (b > 0.) {
      area += b*b;
      p->x += b*b*(2.*n.x + alpha - n.y);
      p->y += b*b*(2.*n.y + alpha - n.x);
      p->z += b*b*b;
    }
  }}

  area *= 3.;
  {
# 462 "/Users/weugene/basilisk/src/geometry.h"
 {
    if (area) {
      p->x /= area*n.x;
      p->x = ((p->x) < (0.) ? (0.) : (p->x) > (1.) ? (1.) : (p->x));
    }
    else
      p->x = 0.;
    if (m.x < 0.) p->x = 1. - p->x;
    p->x -= 0.5;
  }
# 462 "/Users/weugene/basilisk/src/geometry.h"
 {
    if (area) {
      p->y /= area*n.y;
      p->y = ((p->y) < (0.) ? (0.) : (p->y) > (1.) ? (1.) : (p->y));
    }
    else
      p->y = 0.;
    if (m.y < 0.) p->y = 1. - p->y;
    p->y -= 0.5;
  }
# 462 "/Users/weugene/basilisk/src/geometry.h"
 {
    if (area) {
      p->z /= area*n.z;
      p->z = ((p->z) < (0.) ? (0.) : (p->z) > (1.) ? (1.) : (p->z));
    }
    else
      p->z = 0.;
    if (m.z < 0.) p->z = 1. - p->z;
    p->z -= 0.5;
  }}

  return area*sqrt (1./(((n.x)*(n.x))*((n.y)*(n.y))) +
      1./(((n.x)*(n.x))*((n.z)*(n.z))) +
      1./(((n.z)*(n.z))*((n.y)*(n.y))))/6.;
}






void line_center (coord m, double alpha, double a, coord * p)
{
  alpha += (m.x + m.y)/2.;

  coord n = m;
  {
# 488 "/Users/weugene/basilisk/src/geometry.h"

    if (n.x < 0.) {
      alpha -= n.x;
      n.x = - n.x;
    }
# 488 "/Users/weugene/basilisk/src/geometry.h"

    if (n.y < 0.) {
      alpha -= n.y;
      n.y = - n.y;
    }}

  p->z = 0.;
  if (alpha <= 0.) {
    p->x = p->y = -0.5;
    return;
  }

  if (alpha >= n.x + n.y) {
    p->x = p->y = 0.;
    return;
  }

  {
# 505 "/Users/weugene/basilisk/src/geometry.h"

    if (n.x < 1e-4) {
      p->x = 0.;
      p->y = ((m.y) > 0 ? 1 : -1)*(a/2. - 0.5);
      return;
    }
# 505 "/Users/weugene/basilisk/src/geometry.h"

    if (n.y < 1e-4) {
      p->y = 0.;
      p->x = ((m.x) > 0 ? 1 : -1)*(a/2. - 0.5);
      return;
    }}

  p->x = p->y = ((alpha)*(alpha)*(alpha));

  {
# 514 "/Users/weugene/basilisk/src/geometry.h"
 {
    double b = alpha - n.x;
    if (b > 0.) {
      p->x -= ((b)*(b))*(alpha + 2.*n.x);
      p->y -= ((b)*(b)*(b));
    }
  }
# 514 "/Users/weugene/basilisk/src/geometry.h"
 {
    double b = alpha - n.y;
    if (b > 0.) {
      p->y -= ((b)*(b))*(alpha + 2.*n.y);
      p->x -= ((b)*(b)*(b));
    }
  }}

  {
# 522 "/Users/weugene/basilisk/src/geometry.h"
 {
    p->x /= 6.*((n.x)*(n.x))*n.y*a;
    p->x = ((m.x) > 0 ? 1 : -1)*(p->x - 0.5);
  }
# 522 "/Users/weugene/basilisk/src/geometry.h"
 {
    p->y /= 6.*((n.y)*(n.y))*n.x*a;
    p->y = ((m.y) > 0 ? 1 : -1)*(p->y - 0.5);
  }}
}
# 535 "/Users/weugene/basilisk/src/geometry.h"
void plane_center (coord m, double alpha, double a, coord * p)
{
  {
# 537 "/Users/weugene/basilisk/src/geometry.h"

    if (fabs (m.x) < 1e-4) {
      coord n, q;
      ((double *)&n)[0] = m.y;
      ((double *)&n)[1] = m.z;
      line_center (n, alpha, a, &q);
      p->x = 0.;
      p->y = ((double *)&q)[0];
      p->z = ((double *)&q)[1];
      return;
    }
# 537 "/Users/weugene/basilisk/src/geometry.h"

    if (fabs (m.y) < 1e-4) {
      coord n, q;
      ((double *)&n)[0] = m.z;
      ((double *)&n)[1] = m.x;
      line_center (n, alpha, a, &q);
      p->y = 0.;
      p->z = ((double *)&q)[0];
      p->x = ((double *)&q)[1];
      return;
    }
# 537 "/Users/weugene/basilisk/src/geometry.h"

    if (fabs (m.z) < 1e-4) {
      coord n, q;
      ((double *)&n)[0] = m.x;
      ((double *)&n)[1] = m.y;
      line_center (n, alpha, a, &q);
      p->z = 0.;
      p->x = ((double *)&q)[0];
      p->y = ((double *)&q)[1];
      return;
    }}

  alpha += (m.x + m.y + m.z)/2.;
  coord n = m;
  {
# 551 "/Users/weugene/basilisk/src/geometry.h"

    if (n.x < 0.) {
      alpha -= n.x;
      n.x = - n.x;
    }
# 551 "/Users/weugene/basilisk/src/geometry.h"

    if (n.y < 0.) {
      alpha -= n.y;
      n.y = - n.y;
    }
# 551 "/Users/weugene/basilisk/src/geometry.h"

    if (n.z < 0.) {
      alpha -= n.z;
      n.z = - n.z;
    }}

  if (alpha <= 0. || a == 0.) {
    p->x = p->y = p->z = -0.5;
    return;
  }

  if (alpha >= n.x + n.y + n.z || a == 1.) {
    p->x = p->y = p->z = 0.;
    return;
  }

  p->x = p->y = p->z = ((((alpha)*(alpha)))*(((alpha)*(alpha))));
  {
# 568 "/Users/weugene/basilisk/src/geometry.h"
 {
    double b = alpha - n.x;
    if (b > 0.) {
      p->x -= ((b)*(b)*(b))*(3.*n.x + alpha);
      p->y -= ((((b)*(b)))*(((b)*(b))));
      p->z -= ((((b)*(b)))*(((b)*(b))));
    }
  }
# 568 "/Users/weugene/basilisk/src/geometry.h"
 {
    double b = alpha - n.y;
    if (b > 0.) {
      p->y -= ((b)*(b)*(b))*(3.*n.y + alpha);
      p->z -= ((((b)*(b)))*(((b)*(b))));
      p->x -= ((((b)*(b)))*(((b)*(b))));
    }
  }
# 568 "/Users/weugene/basilisk/src/geometry.h"
 {
    double b = alpha - n.z;
    if (b > 0.) {
      p->z -= ((b)*(b)*(b))*(3.*n.z + alpha);
      p->x -= ((((b)*(b)))*(((b)*(b))));
      p->y -= ((((b)*(b)))*(((b)*(b))));
    }
  }}

  double amax = alpha - (n.x + n.y + n.z);
  {
# 578 "/Users/weugene/basilisk/src/geometry.h"
 {
    double b = amax + n.z;
    if (b > 0.) {
      p->x += ((b)*(b)*(b))*(3.*n.x + alpha - n.y);
      p->y += ((b)*(b)*(b))*(3.*n.y + alpha - n.x);
      p->z += ((((b)*(b)))*(((b)*(b))));
    }
  }
# 578 "/Users/weugene/basilisk/src/geometry.h"
 {
    double b = amax + n.x;
    if (b > 0.) {
      p->y += ((b)*(b)*(b))*(3.*n.y + alpha - n.z);
      p->z += ((b)*(b)*(b))*(3.*n.z + alpha - n.y);
      p->x += ((((b)*(b)))*(((b)*(b))));
    }
  }
# 578 "/Users/weugene/basilisk/src/geometry.h"
 {
    double b = amax + n.y;
    if (b > 0.) {
      p->z += ((b)*(b)*(b))*(3.*n.z + alpha - n.x);
      p->x += ((b)*(b)*(b))*(3.*n.x + alpha - n.z);
      p->y += ((((b)*(b)))*(((b)*(b))));
    }
  }}

  double b = 24.*n.x*n.y*n.z*a;
  {
# 588 "/Users/weugene/basilisk/src/geometry.h"
 {
    p->x /= b*n.x;
    p->x = ((m.x) > 0 ? 1 : -1)*(p->x - 0.5);
  }
# 588 "/Users/weugene/basilisk/src/geometry.h"
 {
    p->y /= b*n.y;
    p->y = ((m.y) > 0 ? 1 : -1)*(p->y - 0.5);
  }
# 588 "/Users/weugene/basilisk/src/geometry.h"
 {
    p->z /= b*n.z;
    p->z = ((m.z) > 0 ? 1 : -1)*(p->z - 0.5);
  }}
}
# 13 "/Users/weugene/basilisk/src/fractions.h"
# 1 "./myc.h"
# 1 "/Users/weugene/basilisk/src/myc.h"
# 16 "/Users/weugene/basilisk/src/myc.h"
coord mycs (Point point, scalar c)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 17 "/Users/weugene/basilisk/src/myc.h"

  double m1,m2,m[4][3],t0,t1,t2;
  int cn;



  m1 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(c.i)] +
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)];
  m2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(c.i)] +
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)];
  m[0][0] = m1 > m2 ? 1. : -1.;

  m1 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)]+ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)]+ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)];
  m2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(c.i)]+ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(c.i)]+ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(c.i)];
  m[0][1] = 0.5*(m1-m2);

  m1 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)]+ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)]+ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)];
  m2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(c.i)]+ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(c.i)]+ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(c.i)];
  m[0][2] = 0.5*(m1-m2);



  m1 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)];
  m2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)];
  m[1][0] = 0.5*(m1-m2);

  m1 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)] +
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)];
  m2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(c.i)] +
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(c.i)];
  m[1][1] = m1 > m2 ? 1. : -1.;

  m1 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(c.i)]+ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)]+ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(c.i)];
  m2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(c.i)]+ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(c.i)]+ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(c.i)];
  m[1][2] = 0.5*(m1-m2);




  m1 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)]+ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(c.i)]+ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)];
  m2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)]+ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(c.i)]+ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)];
  m[2][0] = 0.5*(m1-m2);

  m1 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(c.i)]+ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(c.i)]+ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)];
  m2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(c.i)]+ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(c.i)]+ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(c.i)];
  m[2][1] = 0.5*(m1-m2);

  m1 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(c.i)] +
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)];
  m2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(c.i)] +
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(c.i)];
  m[2][2] = m1 > m2 ? 1. : -1.;


  t0 = fabs(m[0][0]) + fabs(m[0][1]) + fabs(m[0][2]);
  m[0][0] /= t0;
  m[0][1] /= t0;
  m[0][2] /= t0;

  t0 = fabs(m[1][0]) + fabs(m[1][1]) + fabs(m[1][2]);
  m[1][0] /= t0;
  m[1][1] /= t0;
  m[1][2] /= t0;

  t0 = fabs(m[2][0]) + fabs(m[2][1]) + fabs(m[2][2]);
  m[2][0] /= t0;
  m[2][1] /= t0;
  m[2][2] /= t0;


  t0 = fabs(m[0][0]);
  t1 = fabs(m[1][1]);
  t2 = fabs(m[2][2]);

  cn = 0;
  if (t1 > t0) {
    t0 = t1;
    cn = 1;
  }
  if (t2 > t0)
    cn = 2;


  m1 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+1]) + sizeof(Cell)))[(c.i)] +
       2.*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(c.i)]) +
       4.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)];
  m2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+1]) + sizeof(Cell)))[(c.i)] +
       2.*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(c.i)]) +
       4.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)];
  m[3][0] = m1 - m2;

  m1 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+1]) + sizeof(Cell)))[(c.i)] +
       2.*( ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(c.i)]) +
       4.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)];
  m2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+1]) + sizeof(Cell)))[(c.i)] +
       2.*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(c.i)]) +
       4.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(c.i)];
  m[3][1] = m1 - m2;

  m1 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+-1]) + sizeof(Cell)))[(c.i)] +
       2.*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(c.i)]) +
       4.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)];
  m2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+1]) + sizeof(Cell)))[(c.i)] +
       2.*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(c.i)]) +
       4.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(c.i)];
  m[3][2] = m1 - m2;


  t0 = fabs(m[3][0]) + fabs(m[3][1]) + fabs(m[3][2]);
  if (t0 < 1e-30) {
    coord mxyz = {1., 0., 0.};
    return mxyz;
  }

  m[3][0] /= t0;
  m[3][1] /= t0;
  m[3][2] /= t0;


  t0 = fabs (m[3][0]);
  t1 = fabs (m[3][1]);
  t2 = fabs (m[3][2]);
  if (t1 > t0)
    t0 = t1;
  if (t2 > t0)
    t0 = t2;

  if (fabs(m[cn][cn]) > t0)
    cn = 3;


  coord mxyz = {m[cn][0], m[cn][1], m[cn][2]};
  return mxyz;
}
# 22 "/Users/weugene/basilisk/src/fractions.h"
# 41 "/Users/weugene/basilisk/src/fractions.h"
void fraction_refine (Point point, scalar c)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 42 "/Users/weugene/basilisk/src/fractions.h"






  double cc = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)];
  if (cc <= 0. || cc >= 1.)
     { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] = cc; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  else {




    coord n = mycs (point, c);
    double alpha = plane_alpha (cc, n);






     { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; {
      static const coord a = {0.,0.,0.}, b = {.5,.5,.5};
      coord nc;
      {
# 68 "/Users/weugene/basilisk/src/fractions.h"

 nc.x = child.x*n.x;
# 68 "/Users/weugene/basilisk/src/fractions.h"

 nc.y = child.y*n.y;
# 68 "/Users/weugene/basilisk/src/fractions.h"

 nc.z = child.z*n.z;}
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] = rectangle_fraction (nc, alpha, a, b);
    } } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  }
}
# 85 "/Users/weugene/basilisk/src/fractions.h"
static void alpha_refine (Point point, scalar alpha)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 86 "/Users/weugene/basilisk/src/fractions.h"

  vector n = _attribute[alpha.i].n;
  double alphac = 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.i)];
  coord m;
  {
# 90 "/Users/weugene/basilisk/src/fractions.h"

    m.x = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(n.x.i)];
# 90 "/Users/weugene/basilisk/src/fractions.h"

    m.y = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(n.y.i)];
# 90 "/Users/weugene/basilisk/src/fractions.h"

    m.z = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(n.z.i)];}
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; {
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.i)] = alphac;
    {
# 94 "/Users/weugene/basilisk/src/fractions.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.i)] -= child.x*m.x/2.;
# 94 "/Users/weugene/basilisk/src/fractions.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.i)] -= child.y*m.y/2.;
# 94 "/Users/weugene/basilisk/src/fractions.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.i)] -= child.z*m.z/2.;}
  } } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
}
# 121 "/Users/weugene/basilisk/src/fractions.h"
struct Fractions {
  scalar Phi;
  scalar c;
  vector s;
  double val;
};


void fractions (struct Fractions a)
{ ;
  scalar Phi = a.Phi;
  scalar c = a.c;
  vector s = (a.s).x.i ? (a.s) : new_face_vector("s");
  double val = a.val;
# 143 "/Users/weugene/basilisk/src/fractions.h"
 vector p= new_vector("p");
# 155 "/Users/weugene/basilisk/src/fractions.h"
 { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->vertices.n; _k++) { point.i = ((Tree *)grid)->vertices.p[_k].i; point.j = ((Tree *)grid)->vertices.p[_k].j; point.k = ((Tree *)grid)->vertices.p[_k].k; point.level = ((Tree *)grid)->vertices.p[_k].level; _flags = ((Tree *)grid)->vertices.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { x -= Delta/2.; y -= Delta/2.; z -= Delta/2.;{
# 155 "/Users/weugene/basilisk/src/fractions.h"
 {
# 155 "/Users/weugene/basilisk/src/fractions.h"
 if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]))))).flags & vertex)) {





    if ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(Phi.i)] - val)*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(Phi.i)] - val) < 0.) {






      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.x.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(Phi.i)] - val)/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(Phi.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(Phi.i)]);
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(Phi.i)] < val)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.x.i)] = 1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.x.i)];
    }
# 180 "/Users/weugene/basilisk/src/fractions.h"
 else
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.x.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(Phi.i)] > val || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(Phi.i)] > val);
  }
# 155 "/Users/weugene/basilisk/src/fractions.h"
 if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]))))).flags & vertex)) {





    if ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(Phi.i)] - val)*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(Phi.i)] - val) < 0.) {






      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.y.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(Phi.i)] - val)/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(Phi.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(Phi.i)]);
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(Phi.i)] < val)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.y.i)] = 1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.y.i)];
    }
# 180 "/Users/weugene/basilisk/src/fractions.h"
 else
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.y.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(Phi.i)] > val || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(Phi.i)] > val);
  }
# 155 "/Users/weugene/basilisk/src/fractions.h"
 if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]))))).flags & vertex)) {





    if ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(Phi.i)] - val)*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(Phi.i)] - val) < 0.) {






      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.z.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(Phi.i)] - val)/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(Phi.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(Phi.i)]);
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(Phi.i)] < val)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.z.i)] = 1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.z.i)];
    }
# 180 "/Users/weugene/basilisk/src/fractions.h"
 else
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.z.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(Phi.i)] > val || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(Phi.i)] > val);
  }} } } } } }; }
# 194 "/Users/weugene/basilisk/src/fractions.h"
 scalar s_x = s.x, s_y = s.y, s_z = s.z;
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 195 "/Users/weugene/basilisk/src/fractions.h"
{
# 195 "/Users/weugene/basilisk/src/fractions.h"






  {
# 233 "/Users/weugene/basilisk/src/fractions.h"
 coord n;
    double nn = 0.;
    {
# 235 "/Users/weugene/basilisk/src/fractions.h"
 {
      n.x = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.y.i)];
      nn += fabs(n.x);
    }
# 235 "/Users/weugene/basilisk/src/fractions.h"
 {
      n.y = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(p.x.i)];
      nn += fabs(n.y);
    }}





    if (nn == 0.)
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s_z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.x.i)];
    else {





      {
# 252 "/Users/weugene/basilisk/src/fractions.h"

 n.x /= nn;
# 252 "/Users/weugene/basilisk/src/fractions.h"

 n.y /= nn;}






      double alpha = 0., ni = 0.;
      for (int i = 0; i <= 1; i++)
 {
# 262 "/Users/weugene/basilisk/src/fractions.h"

   if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(p.x.i)] > 0. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(p.x.i)] < 1.) {
     double a = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(Phi.i)] - val) > 0 ? 1 : -1)*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(p.x.i)] - 0.5);
     alpha += n.x*a + n.y*(i - 0.5);
     ni++;
   }
# 262 "/Users/weugene/basilisk/src/fractions.h"

   if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.y.i)] > 0. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.y.i)] < 1.) {
     double a = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(Phi.i)] - val) > 0 ? 1 : -1)*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.y.i)] - 0.5);
     alpha += n.y*a + n.x*(i - 0.5);
     ni++;
   }}
# 276 "/Users/weugene/basilisk/src/fractions.h"
 if (ni == 0)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s_z.i)] = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.x.i)]) > (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.y.i)]) ? (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.x.i)]) : (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.y.i)]));
      else if (ni != 4)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s_z.i)] = line_area (n.x, n.y, alpha/ni);
      else {

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s_z.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(p.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.y.i)] > 2.);



      }
    }
  } } }} { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 195 "/Users/weugene/basilisk/src/fractions.h"
{
# 195 "/Users/weugene/basilisk/src/fractions.h"






  {
# 233 "/Users/weugene/basilisk/src/fractions.h"
 coord n;
    double nn = 0.;
    {
# 235 "/Users/weugene/basilisk/src/fractions.h"
 {
      n.y = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(p.z.i)];
      nn += fabs(n.y);
    }
# 235 "/Users/weugene/basilisk/src/fractions.h"
 {
      n.z = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(p.y.i)];
      nn += fabs(n.z);
    }}





    if (nn == 0.)
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s_x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.y.i)];
    else {





      {
# 252 "/Users/weugene/basilisk/src/fractions.h"

 n.y /= nn;
# 252 "/Users/weugene/basilisk/src/fractions.h"

 n.z /= nn;}






      double alpha = 0., ni = 0.;
      for (int i = 0; i <= 1; i++)
 {
# 262 "/Users/weugene/basilisk/src/fractions.h"

   if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(p.y.i)] > 0. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(p.y.i)] < 1.) {
     double a = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(Phi.i)] - val) > 0 ? 1 : -1)*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(p.y.i)] - 0.5);
     alpha += n.y*a + n.z*(i - 0.5);
     ni++;
   }
# 262 "/Users/weugene/basilisk/src/fractions.h"

   if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(p.z.i)] > 0. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(p.z.i)] < 1.) {
     double a = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(Phi.i)] - val) > 0 ? 1 : -1)*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(p.z.i)] - 0.5);
     alpha += n.z*a + n.y*(i - 0.5);
     ni++;
   }}
# 276 "/Users/weugene/basilisk/src/fractions.h"
 if (ni == 0)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s_x.i)] = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.y.i)]) > (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.z.i)]) ? (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.y.i)]) : (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.z.i)]));
      else if (ni != 4)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s_x.i)] = line_area (n.y, n.z, alpha/ni);
      else {

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s_x.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(p.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(p.z.i)] > 2.);



      }
    }
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 195 "/Users/weugene/basilisk/src/fractions.h"
{
# 195 "/Users/weugene/basilisk/src/fractions.h"






  {
# 233 "/Users/weugene/basilisk/src/fractions.h"
 coord n;
    double nn = 0.;
    {
# 235 "/Users/weugene/basilisk/src/fractions.h"
 {
      n.z = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(p.x.i)];
      nn += fabs(n.z);
    }
# 235 "/Users/weugene/basilisk/src/fractions.h"
 {
      n.x = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.z.i)];
      nn += fabs(n.x);
    }}





    if (nn == 0.)
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s_y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.z.i)];
    else {





      {
# 252 "/Users/weugene/basilisk/src/fractions.h"

 n.z /= nn;
# 252 "/Users/weugene/basilisk/src/fractions.h"

 n.x /= nn;}






      double alpha = 0., ni = 0.;
      for (int i = 0; i <= 1; i++)
 {
# 262 "/Users/weugene/basilisk/src/fractions.h"

   if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.z.i)] > 0. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.z.i)] < 1.) {
     double a = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(Phi.i)] - val) > 0 ? 1 : -1)*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.z.i)] - 0.5);
     alpha += n.z*a + n.x*(i - 0.5);
     ni++;
   }
# 262 "/Users/weugene/basilisk/src/fractions.h"

   if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(p.x.i)] > 0. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(p.x.i)] < 1.) {
     double a = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(Phi.i)] - val) > 0 ? 1 : -1)*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(p.x.i)] - 0.5);
     alpha += n.x*a + n.z*(i - 0.5);
     ni++;
   }}
# 276 "/Users/weugene/basilisk/src/fractions.h"
 if (ni == 0)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s_y.i)] = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.z.i)]) > (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.x.i)]) ? (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.z.i)]) : (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.x.i)]));
      else if (ni != 4)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s_y.i)] = line_area (n.z, n.x, alpha/ni);
      else {

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s_y.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(p.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(p.x.i)] > 2.);



      }
    }
  } } }} } } }
# 288 "/Users/weugene/basilisk/src/fractions.h"
 ; }







  boundary_flux (((vector []){{s.x,s.y,s.z},{{-1},{-1},{-1}}}));
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 297 "/Users/weugene/basilisk/src/fractions.h"
 {




    coord n;
    double nn = 0.;
    {
# 304 "/Users/weugene/basilisk/src/fractions.h"
 {
      n.x = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.x.i)];
      nn += fabs(n.x);
    }
# 304 "/Users/weugene/basilisk/src/fractions.h"
 {
      n.y = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.y.i)];
      nn += fabs(n.y);
    }
# 304 "/Users/weugene/basilisk/src/fractions.h"
 {
      n.z = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(s.z.i)];
      nn += fabs(n.z);
    }}
    if (nn == 0.)
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.x.i)];
    else {
      {
# 311 "/Users/weugene/basilisk/src/fractions.h"

 n.x /= nn;
# 311 "/Users/weugene/basilisk/src/fractions.h"

 n.y /= nn;
# 311 "/Users/weugene/basilisk/src/fractions.h"

 n.z /= nn;}






      double alpha = 0., ni = 0.;
      for (int i = 0; i <= 1; i++)
 for (int j = 0; j <= 1; j++)
   {
# 322 "/Users/weugene/basilisk/src/fractions.h"

     if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j]) + sizeof(Cell)))[(p.x.i)] > 0. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j]) + sizeof(Cell)))[(p.x.i)] < 1.) {
       double a = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j]) + sizeof(Cell)))[(Phi.i)] - val) > 0 ? 1 : -1)*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j]) + sizeof(Cell)))[(p.x.i)] - 0.5);
       alpha += n.x*a + n.y*(i - 0.5) + n.z*(j - 0.5);
       ni++;
     }
# 322 "/Users/weugene/basilisk/src/fractions.h"

     if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i]) + sizeof(Cell)))[(p.y.i)] > 0. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i]) + sizeof(Cell)))[(p.y.i)] < 1.) {
       double a = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i]) + sizeof(Cell)))[(Phi.i)] - val) > 0 ? 1 : -1)*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i]) + sizeof(Cell)))[(p.y.i)] - 0.5);
       alpha += n.y*a + n.z*(i - 0.5) + n.x*(j - 0.5);
       ni++;
     }
# 322 "/Users/weugene/basilisk/src/fractions.h"

     if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]) + sizeof(Cell)))[(p.z.i)] > 0. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]) + sizeof(Cell)))[(p.z.i)] < 1.) {
       double a = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]) + sizeof(Cell)))[(Phi.i)] - val) > 0 ? 1 : -1)*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]) + sizeof(Cell)))[(p.z.i)] - 0.5);
       alpha += n.z*a + n.x*(i - 0.5) + n.y*(j - 0.5);
       ni++;
     }}




      if (ni == 0)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.x.i)];
      else if (ni < 3 || ni > 6)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] = 0.;
      else
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] = plane_volume (n, alpha/ni);
    }
  } } } } }; }





  boundary (((scalar []){c,{-1}}));
 delete (((scalar []){p.x,p.y,p.z,{-1}})); { if (!(a.s).x.i) delete (((scalar []){s.x,s.y,s.z,{-1}})); } ; }
# 384 "/Users/weugene/basilisk/src/fractions.h"
coord youngs_normal (Point point, scalar c)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 385 "/Users/weugene/basilisk/src/fractions.h"

  coord n;
  double nn = 0.;
  (__builtin_expect(!(3 == 2), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/fractions.h", 388, "3 == 2") : (void)0);
  {
# 389 "/Users/weugene/basilisk/src/fractions.h"
 {
    n.x = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(c.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)] -
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+ +1][point.j+1] [point.k+0]) + sizeof(Cell)))[(c.i)] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+ +1][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+ +1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)]);
    nn += fabs(n.x);
  }
# 389 "/Users/weugene/basilisk/src/fractions.h"
 {
    n.y = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(c.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(c.i)] -
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+ +1] [point.k+1]) + sizeof(Cell)))[(c.i)] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+ +1] [point.k+0]) + sizeof(Cell)))[(c.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+ +1] [point.k+-1]) + sizeof(Cell)))[(c.i)]);
    nn += fabs(n.y);
  }
# 389 "/Users/weugene/basilisk/src/fractions.h"
 {
    n.z = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)] -
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+ +1]) + sizeof(Cell)))[(c.i)] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+ +1]) + sizeof(Cell)))[(c.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+ +1]) + sizeof(Cell)))[(c.i)]);
    nn += fabs(n.z);
  }}

  if (nn > 0.)
    {
# 396 "/Users/weugene/basilisk/src/fractions.h"

      n.x /= nn;
# 396 "/Users/weugene/basilisk/src/fractions.h"

      n.y /= nn;
# 396 "/Users/weugene/basilisk/src/fractions.h"

      n.z /= nn;}
  else
    n.x = 1.;
  return n;
}





coord facet_normal (Point point, scalar c, vector s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 408 "/Users/weugene/basilisk/src/fractions.h"

  if (s.x.i >= 0) {
    coord n;
    double nn = 0.;
    {
# 412 "/Users/weugene/basilisk/src/fractions.h"
 {
      n.x = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.x.i)];
      nn += fabs(n.x);
    }
# 412 "/Users/weugene/basilisk/src/fractions.h"
 {
      n.y = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.y.i)];
      nn += fabs(n.y);
    }
# 412 "/Users/weugene/basilisk/src/fractions.h"
 {
      n.z = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(s.z.i)];
      nn += fabs(n.z);
    }}
    if (nn > 0.)
      {
# 417 "/Users/weugene/basilisk/src/fractions.h"

 n.x /= nn;
# 417 "/Users/weugene/basilisk/src/fractions.h"

 n.y /= nn;
# 417 "/Users/weugene/basilisk/src/fractions.h"

 n.z /= nn;}
    else
      {
# 420 "/Users/weugene/basilisk/src/fractions.h"

 n.x = 1./3;
# 420 "/Users/weugene/basilisk/src/fractions.h"

 n.y = 1./3;
# 420 "/Users/weugene/basilisk/src/fractions.h"

 n.z = 1./3;}
    return n;
  }
  return mycs (point, c);
}
# 434 "/Users/weugene/basilisk/src/fractions.h"

void reconstruction (const scalar c, vector n, scalar alpha)
{ ;
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 437 "/Users/weugene/basilisk/src/fractions.h"
 {





    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] >= 1.) {
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.i)] = 0.;
      {
# 445 "/Users/weugene/basilisk/src/fractions.h"

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(n.x.i)] = 0.;
# 445 "/Users/weugene/basilisk/src/fractions.h"

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(n.y.i)] = 0.;
# 445 "/Users/weugene/basilisk/src/fractions.h"

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(n.z.i)] = 0.;}
    }
    else {






      coord m = mycs (point, c);
      {
# 456 "/Users/weugene/basilisk/src/fractions.h"

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(n.x.i)] = m.x;
# 456 "/Users/weugene/basilisk/src/fractions.h"

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(n.y.i)] = m.y;
# 456 "/Users/weugene/basilisk/src/fractions.h"

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(n.z.i)] = m.z;}
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.i)] = plane_alpha (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)], m);
    }
  } } } } }; }
# 469 "/Users/weugene/basilisk/src/fractions.h"
 {
# 469 "/Users/weugene/basilisk/src/fractions.h"

    _attribute[n.x.i].refine = _attribute[n.x.i].prolongation = refine_injection;
# 469 "/Users/weugene/basilisk/src/fractions.h"

    _attribute[n.y.i].refine = _attribute[n.y.i].prolongation = refine_injection;
# 469 "/Users/weugene/basilisk/src/fractions.h"

    _attribute[n.z.i].refine = _attribute[n.z.i].prolongation = refine_injection;}




  _attribute[alpha.i].n = n;
  _attribute[alpha.i].refine = _attribute[alpha.i].prolongation = alpha_refine;







  boundary (((scalar []){n.x,n.y,n.z,alpha,{-1}}));
                                                                            ; }
# 505 "/Users/weugene/basilisk/src/fractions.h"
struct OutputFacets {
  scalar c;
  FILE * fp;
  vector s;
};


void output_facets (struct OutputFacets p)
{ ;
  scalar c = p.c;
  vector s = p.s;
  if (!p.fp) p.fp = __stdoutp;
  if (!s.x.i) s.x.i = -1;

   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 519 "/Users/weugene/basilisk/src/fractions.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] > 1e-6 && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] < 1. - 1e-6) {
      coord n = facet_normal (point, c, s);
      double alpha = plane_alpha (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)], n);







      coord v[12];
      int m = facets (n, alpha, v, 1.);
      for (int i = 0; i < m; i++)
 fprintf (p.fp, "%g %g %g\n",
   x + v[i].x*Delta, y + v[i].y*Delta, z + v[i].z*Delta);
      if (m > 0)
 fputc ('\n', p.fp);

    } } } } }; }

  fflush (p.fp);
                                                                           ; }
# 550 "/Users/weugene/basilisk/src/fractions.h"
double interface_area (scalar c)
{ ;
  double area = 0.;
   {


                  {
double _area = area;
# 553 "/Users/weugene/basilisk/src/fractions.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 553 "/Users/weugene/basilisk/src/fractions.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] > 1e-6 && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] < 1. - 1e-6) {
      coord n = mycs (point, c), p;
      double alpha = plane_alpha (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)], n);
      _area += pow(Delta, 3 - 1)*plane_area_center (n, alpha, &p);
    } } } } }; area += _area;
                                     ;



}
# 558 "/Users/weugene/basilisk/src/fractions.h"
 }
  { double _ret = area; ; return _ret; }
                                                                            ; }
# 36 "/Users/weugene/basilisk/src/vof.h"








extern scalar * interfaces;
extern vector uf;
extern double dt;
# 54 "/Users/weugene/basilisk/src/vof.h"

static double vof_concentration_gradient_x (Point point, scalar c, scalar t)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 56 "/Users/weugene/basilisk/src/vof.h"

  static const double cmin = 0.5;
  double cl = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)], cc = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)], cr = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)];
  if (_attribute[t.i].inverse)
    cl = 1. - cl, cc = 1. - cc, cr = 1. - cr;
  if (cc >= cmin && _attribute[t.i].gradient != zero) {
    if (cr >= cmin) {
      if (cl >= cmin) {
 if (_attribute[t.i].gradient)
   return _attribute[t.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]/cl, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]/cc, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]/cr)/Delta;
 else
   return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]/cr - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]/cl)/(2.*Delta);
      }
      else
 return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]/cr - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]/cc)/Delta;
    }
    else if (cl >= cmin)
      return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]/cc - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]/cl)/Delta;
  }
  return 0.;
}
# 54 "/Users/weugene/basilisk/src/vof.h"

static double vof_concentration_gradient_y (Point point, scalar c, scalar t)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 56 "/Users/weugene/basilisk/src/vof.h"

  static const double cmin = 0.5;
  double cl = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)], cc = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)], cr = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(c.i)];
  if (_attribute[t.i].inverse)
    cl = 1. - cl, cc = 1. - cc, cr = 1. - cr;
  if (cc >= cmin && _attribute[t.i].gradient != zero) {
    if (cr >= cmin) {
      if (cl >= cmin) {
 if (_attribute[t.i].gradient)
   return _attribute[t.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(t.i)]/cl, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]/cc, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(t.i)]/cr)/Delta;
 else
   return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(t.i)]/cr - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(t.i)]/cl)/(2.*Delta);
      }
      else
 return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(t.i)]/cr - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]/cc)/Delta;
    }
    else if (cl >= cmin)
      return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]/cc - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(t.i)]/cl)/Delta;
  }
  return 0.;
}
# 54 "/Users/weugene/basilisk/src/vof.h"

static double vof_concentration_gradient_z (Point point, scalar c, scalar t)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 56 "/Users/weugene/basilisk/src/vof.h"

  static const double cmin = 0.5;
  double cl = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)], cc = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)], cr = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(c.i)];
  if (_attribute[t.i].inverse)
    cl = 1. - cl, cc = 1. - cc, cr = 1. - cr;
  if (cc >= cmin && _attribute[t.i].gradient != zero) {
    if (cr >= cmin) {
      if (cl >= cmin) {
 if (_attribute[t.i].gradient)
   return _attribute[t.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(t.i)]/cl, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]/cc, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(t.i)]/cr)/Delta;
 else
   return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(t.i)]/cr - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(t.i)]/cl)/(2.*Delta);
      }
      else
 return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(t.i)]/cr - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]/cc)/Delta;
    }
    else if (cl >= cmin)
      return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]/cc - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(t.i)]/cl)/Delta;
  }
  return 0.;
}






static void vof_concentration_refine (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 84 "/Users/weugene/basilisk/src/vof.h"

if (!((cm).i >= 65536)) {
# 84 "/Users/weugene/basilisk/src/vof.h"

  scalar f = _attribute[s.i].c;
  if ((!_attribute[s.i].inverse && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] <= 0.) || (_attribute[s.i].inverse && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] >= 1.))
     { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = 0.; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  else {
    coord g;
    {
# 91 "/Users/weugene/basilisk/src/vof.h"

      g.x = Delta*vof_concentration_gradient_x (point, f, s);
# 91 "/Users/weugene/basilisk/src/vof.h"

      g.y = Delta*vof_concentration_gradient_y (point, f, s);
# 91 "/Users/weugene/basilisk/src/vof.h"

      g.z = Delta*vof_concentration_gradient_z (point, f, s);}
    double sc = _attribute[s.i].inverse ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]/(1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]) : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)], cmc = 4.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)];
     { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; {
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = sc;
      {
# 96 "/Users/weugene/basilisk/src/vof.h"

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] += child.x*g.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-child.x][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)]/cmc;
# 96 "/Users/weugene/basilisk/src/vof.h"

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] += child.y*g.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-child.y] [point.k+0]) + sizeof(Cell)))[(cm.i)]/cmc;
# 96 "/Users/weugene/basilisk/src/vof.h"

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] += child.z*g.z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-child.z]) + sizeof(Cell)))[(cm.i)]/cmc;}
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] *= _attribute[s.i].inverse ? 1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)];
    } } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  }
 }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 84 "/Users/weugene/basilisk/src/vof.h"

  scalar f = _attribute[s.i].c;
  if ((!_attribute[s.i].inverse && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] <= 0.) || (_attribute[s.i].inverse && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] >= 1.))
     { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = 0.; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  else {
    coord g;
    {
# 91 "/Users/weugene/basilisk/src/vof.h"

      g.x = Delta*vof_concentration_gradient_x (point, f, s);
# 91 "/Users/weugene/basilisk/src/vof.h"

      g.y = Delta*vof_concentration_gradient_y (point, f, s);
# 91 "/Users/weugene/basilisk/src/vof.h"

      g.z = Delta*vof_concentration_gradient_z (point, f, s);}
    double sc = _attribute[s.i].inverse ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]/(1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]) : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)], cmc = 4.*_const_cm;
     { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; {
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = sc;
      {
# 96 "/Users/weugene/basilisk/src/vof.h"

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] += child.x*g.x*_const_cm/cmc;
# 96 "/Users/weugene/basilisk/src/vof.h"

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] += child.y*g.y*_const_cm/cmc;
# 96 "/Users/weugene/basilisk/src/vof.h"

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] += child.z*g.z*_const_cm/cmc;}
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] *= _attribute[s.i].inverse ? 1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)];
    } } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  }
 }}





static int defaults_1_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i = 0); *ip = i; *tp = t; return ret; } static int defaults_1 (const int i, const double t, Event * _ev) { ;
{
  if (interfaces) for (scalar c = *interfaces, *_i96 = interfaces; ((scalar *)&c)->i >= 0; c = *++_i96) {
    _attribute[c.i].refine = _attribute[c.i].prolongation = fraction_refine;
    scalar * tracers = _attribute[c.i].tracers;
    if (tracers) for (scalar t = *tracers, *_i97 = tracers; ((scalar *)&t)->i >= 0; t = *++_i97) {
      _attribute[t.i].restriction = restriction_volume_average;
      _attribute[t.i].refine = _attribute[t.i].prolongation = vof_concentration_refine;
      _attribute[t.i].c = c;
    }
  }
                                                                  ; } return 0; }






static int stability_0_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int stability_0 (const int i, const double t, Event * _ev) { ; {
  if (CFL > 0.5)
    CFL = 0.5;
                                                                   ; } return 0; }
# 142 "/Users/weugene/basilisk/src/vof.h"
# 142 "/Users/weugene/basilisk/src/vof.h"

static void sweep_x (scalar c, scalar cc, scalar * tcl)
{
  vector n= new_vector("n");
  scalar alpha= new_scalar("alpha"), flux= new_scalar("flux");
  double cfl = 0.;
# 156 "/Users/weugene/basilisk/src/vof.h"
 scalar * tracers = _attribute[c.i].tracers, * gfl = ((void*)0), * tfluxl = ((void*)0);
  if (tracers) {
    if (tracers) for (scalar t = *tracers, *_i98 = tracers; ((scalar *)&t)->i >= 0; t = *++_i98) {
      scalar gf = new_scalar("gf"), flux = new_scalar("flux");
      gfl = list_append (gfl, gf);
      tfluxl = list_append (tfluxl, flux);
    }




     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 167 "/Users/weugene/basilisk/src/vof.h"
 {
      scalar t, gf;
      scalar * _i6 = tracers; scalar * _i7 = gfl; if (tracers) for (t = *tracers, gf = *gfl; ((scalar *)&t)->i >= 0; t = *++_i6, gf = *++_i7)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.i)] = vof_concentration_gradient_x (point, c, t);
    } } } } }; }
    boundary (gfl);
  }






  reconstruction (c, n, alpha);

   {


                  {
double _cfl = cfl;
# 182 "/Users/weugene/basilisk/src/vof.h"

if (!((fm.x).i >= 65536) && !((cm).i >= 65536)) {
# 182 "/Users/weugene/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 182 "/Users/weugene/basilisk/src/vof.h"
{
# 182 "/Users/weugene/basilisk/src/vof.h"
 {






    double un = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)]*dt/(Delta*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)] + 1e-12), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;




    if (un*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]*s/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)] + 1e-12) > _cfl)
      _cfl = un*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]*s/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)] + 1e-12);
# 209 "/Users/weugene/basilisk/src/vof.h"
 double cf = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] >= 1.) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] :
      rectangle_fraction ((coord){-s*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(n.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(n.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(n.z.i)]}, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.i)],
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.i)] = cf*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)];






    scalar t, gf, tflux;
    scalar * _i8 = tracers; scalar * _i9 = gfl; scalar * _i10 = tfluxl; if (tracers) for (t = *tracers, gf = *gfl, tflux = *tfluxl; ((scalar *)&t)->i >= 0; t = *++_i8, gf = *++_i9, tflux = *++_i10) {
      double cf1 = cf, ci = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)];
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]/ci + s*((1.) < (1. - s*un) ? (1.) : (1. - s*un))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.i)]*Delta/2.;
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = ff*cf1*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)];
      }
      else
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = 0.;
    }
  } } }} } } }
# 237 "/Users/weugene/basilisk/src/vof.h"
 ; }
if (((fm.x).i >= 65536) && !((cm).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 182 "/Users/weugene/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 182 "/Users/weugene/basilisk/src/vof.h"
{
# 182 "/Users/weugene/basilisk/src/vof.h"
 {






    double un = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)]*dt/(Delta*_const_fm.x + 1e-12), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;




    if (un*_const_fm.x*s/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)] + 1e-12) > _cfl)
      _cfl = un*_const_fm.x*s/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)] + 1e-12);
# 209 "/Users/weugene/basilisk/src/vof.h"
 double cf = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] >= 1.) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] :
      rectangle_fraction ((coord){-s*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(n.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(n.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(n.z.i)]}, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.i)],
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.i)] = cf*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)];






    scalar t, gf, tflux;
    scalar * _i8 = tracers; scalar * _i9 = gfl; scalar * _i10 = tfluxl; if (tracers) for (t = *tracers, gf = *gfl, tflux = *tfluxl; ((scalar *)&t)->i >= 0; t = *++_i8, gf = *++_i9, tflux = *++_i10) {
      double cf1 = cf, ci = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)];
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]/ci + s*((1.) < (1. - s*un) ? (1.) : (1. - s*un))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.i)]*Delta/2.;
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = ff*cf1*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)];
      }
      else
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = 0.;
    }
  } } }} } } }
# 237 "/Users/weugene/basilisk/src/vof.h"
 ; }
if (!((fm.x).i >= 65536) && ((cm).i >= 65536)) {
# 257 "/Users/weugene/basilisk/src/vof.h"
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 182 "/Users/weugene/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 182 "/Users/weugene/basilisk/src/vof.h"
{
# 182 "/Users/weugene/basilisk/src/vof.h"
 {






    double un = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)]*dt/(Delta*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)] + 1e-12), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;




    if (un*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]*s/(_const_cm + 1e-12) > _cfl)
      _cfl = un*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]*s/(_const_cm + 1e-12);
# 209 "/Users/weugene/basilisk/src/vof.h"
 double cf = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] >= 1.) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] :
      rectangle_fraction ((coord){-s*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(n.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(n.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(n.z.i)]}, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.i)],
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.i)] = cf*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)];






    scalar t, gf, tflux;
    scalar * _i8 = tracers; scalar * _i9 = gfl; scalar * _i10 = tfluxl; if (tracers) for (t = *tracers, gf = *gfl, tflux = *tfluxl; ((scalar *)&t)->i >= 0; t = *++_i8, gf = *++_i9, tflux = *++_i10) {
      double cf1 = cf, ci = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)];
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]/ci + s*((1.) < (1. - s*un) ? (1.) : (1. - s*un))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.i)]*Delta/2.;
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = ff*cf1*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)];
      }
      else
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = 0.;
    }
  } } }} } } }
# 237 "/Users/weugene/basilisk/src/vof.h"
 ; }
if (((fm.x).i >= 65536) && ((cm).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 259 "/Users/weugene/basilisk/src/vof.h"
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 182 "/Users/weugene/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 182 "/Users/weugene/basilisk/src/vof.h"
{
# 182 "/Users/weugene/basilisk/src/vof.h"
 {






    double un = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)]*dt/(Delta*_const_fm.x + 1e-12), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;




    if (un*_const_fm.x*s/(_const_cm + 1e-12) > _cfl)
      _cfl = un*_const_fm.x*s/(_const_cm + 1e-12);
# 209 "/Users/weugene/basilisk/src/vof.h"
 double cf = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] >= 1.) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] :
      rectangle_fraction ((coord){-s*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(n.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(n.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(n.z.i)]}, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.i)],
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.i)] = cf*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)];






    scalar t, gf, tflux;
    scalar * _i8 = tracers; scalar * _i9 = gfl; scalar * _i10 = tfluxl; if (tracers) for (t = *tracers, gf = *gfl, tflux = *tfluxl; ((scalar *)&t)->i >= 0; t = *++_i8, gf = *++_i9, tflux = *++_i10) {
      double cf1 = cf, ci = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)];
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]/ci + s*((1.) < (1. - s*un) ? (1.) : (1. - s*un))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.i)]*Delta/2.;
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = ff*cf1*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)];
      }
      else
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = 0.;
    }
  } } }} } } }
# 237 "/Users/weugene/basilisk/src/vof.h"
 ; } if (_cfl > cfl) cfl = _cfl;
                                    ;



}
# 237 "/Users/weugene/basilisk/src/vof.h"
 }
  delete (gfl); free(gfl);
# 248 "/Users/weugene/basilisk/src/vof.h"
 scalar * fluxl = list_concat (((void*)0), tfluxl);
  fluxl = list_append (fluxl, flux);
  for (int l = (grid->depth) - 1; l >= 0; l--)
     { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _cache = ((Tree *)grid)->prolongation[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = l; int _k; for (_k = 0; _k < _cache.n; _k++) { point.i = _cache.p[_k].i; point.j = _cache.p[_k].j; point.k = _cache.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 251 "/Users/weugene/basilisk/src/vof.h"
 {
# 267 "/Users/weugene/basilisk/src/vof.h"
 if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0])))).pid >= 0))
 if (fluxl) for (scalar fl = *fluxl, *_i99 = fluxl; ((scalar *)&fl)->i >= 0; fl = *++_i99)
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fl.i)] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0][2*point.k-2 +0]) + sizeof(Cell)))[(fl.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +1][2*point.k-2 +0]) + sizeof(Cell)))[(fl.i)] +
    ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0][2*point.k-2 +1]) + sizeof(Cell)))[(fl.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +1][2*point.k-2 +1]) + sizeof(Cell)))[(fl.i)])/4.;
      if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0])))).pid >= 0))
 if (fluxl) for (scalar fl = *fluxl, *_i100 = fluxl; ((scalar *)&fl)->i >= 0; fl = *++_i100)
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(fl.i)] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] [2*point.j-2 +0][2*point.k-2 +0]) + sizeof(Cell)))[(fl.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] [2*point.j-2 +1][2*point.k-2 +0]) + sizeof(Cell)))[(fl.i)] +
     ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] [2*point.j-2 +0][2*point.k-2 +1]) + sizeof(Cell)))[(fl.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] [2*point.j-2 +1][2*point.k-2 +1]) + sizeof(Cell)))[(fl.i)])/4.;

    } } } } }; }}; }
  free(fluxl);





  if (cfl > 0.5 + 1e-6)
    fprintf (__stderrp,
      "WARNING: CFL must be <= 0.5 for VOF (cfl - 0.5 = %g)\n",
      cfl - 0.5), fflush (__stderrp);
# 305 "/Users/weugene/basilisk/src/vof.h"
 {
if (!((cm).i >= 65536)) {
# 305 "/Users/weugene/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 305 "/Users/weugene/basilisk/src/vof.h"
 {
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] += dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cc.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)]))/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)]*Delta + 1e-12);
    scalar t, tc, tflux;
    scalar * _i11 = tracers; scalar * _i12 = tcl; scalar * _i13 = tfluxl; if (tracers) for (t = *tracers, tc = *tcl, tflux = *tfluxl; ((scalar *)&t)->i >= 0; t = *++_i11, tc = *++_i12, tflux = *++_i13)
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)] += dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tc.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)]))/
 (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)]*Delta + 1e-12);
  } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 305 "/Users/weugene/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 305 "/Users/weugene/basilisk/src/vof.h"
 {
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] += dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cc.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)]))/(_const_cm*Delta + 1e-12);
    scalar t, tc, tflux;
    scalar * _i11 = tracers; scalar * _i12 = tcl; scalar * _i13 = tfluxl; if (tracers) for (t = *tracers, tc = *tcl, tflux = *tfluxl; ((scalar *)&t)->i >= 0; t = *++_i11, tc = *++_i12, tflux = *++_i13)
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)] += dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tc.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.x.i)]))/
 (_const_cm*Delta + 1e-12);
  } } } } }; } }
  boundary (((scalar []){c,{-1}}));
  boundary (tracers);

  delete (tfluxl); free(tfluxl);
 delete (((scalar []){flux,alpha,n.x,n.y,n.z,{-1}})); }
# 142 "/Users/weugene/basilisk/src/vof.h"

static void sweep_y (scalar c, scalar cc, scalar * tcl)
{
  vector n= new_vector("n");
  scalar alpha= new_scalar("alpha"), flux= new_scalar("flux");
  double cfl = 0.;
# 156 "/Users/weugene/basilisk/src/vof.h"
 scalar * tracers = _attribute[c.i].tracers, * gfl = ((void*)0), * tfluxl = ((void*)0);
  if (tracers) {
    if (tracers) for (scalar t = *tracers, *_i98 = tracers; ((scalar *)&t)->i >= 0; t = *++_i98) {
      scalar gf = new_scalar("gf"), flux = new_scalar("flux");
      gfl = list_append (gfl, gf);
      tfluxl = list_append (tfluxl, flux);
    }




     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 167 "/Users/weugene/basilisk/src/vof.h"
 {
      scalar t, gf;
      scalar * _i6 = tracers; scalar * _i7 = gfl; if (tracers) for (t = *tracers, gf = *gfl; ((scalar *)&t)->i >= 0; t = *++_i6, gf = *++_i7)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.i)] = vof_concentration_gradient_y (point, c, t);
    } } } } }; }
    boundary (gfl);
  }






  reconstruction (c, n, alpha);

   {


                  {
double _cfl = cfl;
# 182 "/Users/weugene/basilisk/src/vof.h"

if (!((fm.y).i >= 65536) && !((cm).i >= 65536)) {
# 182 "/Users/weugene/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 182 "/Users/weugene/basilisk/src/vof.h"
{
# 182 "/Users/weugene/basilisk/src/vof.h"
 {






    double un = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)]*dt/(Delta*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)] + 1e-12), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;




    if (un*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]*s/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)] + 1e-12) > _cfl)
      _cfl = un*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]*s/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)] + 1e-12);
# 209 "/Users/weugene/basilisk/src/vof.h"
 double cf = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(c.i)] >= 1.) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(c.i)] :
      rectangle_fraction ((coord){-s*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(n.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(n.z.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(n.x.i)]}, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(alpha.i)],
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.i)] = cf*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)];






    scalar t, gf, tflux;
    scalar * _i8 = tracers; scalar * _i9 = gfl; scalar * _i10 = tfluxl; if (tracers) for (t = *tracers, gf = *gfl, tflux = *tfluxl; ((scalar *)&t)->i >= 0; t = *++_i8, gf = *++_i9, tflux = *++_i10) {
      double cf1 = cf, ci = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(c.i)];
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(t.i)]/ci + s*((1.) < (1. - s*un) ? (1.) : (1. - s*un))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(gf.i)]*Delta/2.;
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = ff*cf1*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)];
      }
      else
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = 0.;
    }
  } } }} } } }
# 237 "/Users/weugene/basilisk/src/vof.h"
 ; }
if (((fm.y).i >= 65536) && !((cm).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.y.i -65536], _constant[fm.z.i - 65536], _constant[fm.x.i - 65536]};
(void)(_const_fm);
# 182 "/Users/weugene/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 182 "/Users/weugene/basilisk/src/vof.h"
{
# 182 "/Users/weugene/basilisk/src/vof.h"
 {






    double un = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)]*dt/(Delta*_const_fm.y + 1e-12), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;




    if (un*_const_fm.y*s/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)] + 1e-12) > _cfl)
      _cfl = un*_const_fm.y*s/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)] + 1e-12);
# 209 "/Users/weugene/basilisk/src/vof.h"
 double cf = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(c.i)] >= 1.) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(c.i)] :
      rectangle_fraction ((coord){-s*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(n.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(n.z.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(n.x.i)]}, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(alpha.i)],
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.i)] = cf*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)];






    scalar t, gf, tflux;
    scalar * _i8 = tracers; scalar * _i9 = gfl; scalar * _i10 = tfluxl; if (tracers) for (t = *tracers, gf = *gfl, tflux = *tfluxl; ((scalar *)&t)->i >= 0; t = *++_i8, gf = *++_i9, tflux = *++_i10) {
      double cf1 = cf, ci = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(c.i)];
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(t.i)]/ci + s*((1.) < (1. - s*un) ? (1.) : (1. - s*un))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(gf.i)]*Delta/2.;
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = ff*cf1*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)];
      }
      else
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = 0.;
    }
  } } }} } } }
# 237 "/Users/weugene/basilisk/src/vof.h"
 ; }
if (!((fm.y).i >= 65536) && ((cm).i >= 65536)) {
# 257 "/Users/weugene/basilisk/src/vof.h"
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 182 "/Users/weugene/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 182 "/Users/weugene/basilisk/src/vof.h"
{
# 182 "/Users/weugene/basilisk/src/vof.h"
 {






    double un = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)]*dt/(Delta*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)] + 1e-12), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;




    if (un*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]*s/(_const_cm + 1e-12) > _cfl)
      _cfl = un*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]*s/(_const_cm + 1e-12);
# 209 "/Users/weugene/basilisk/src/vof.h"
 double cf = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(c.i)] >= 1.) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(c.i)] :
      rectangle_fraction ((coord){-s*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(n.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(n.z.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(n.x.i)]}, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(alpha.i)],
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.i)] = cf*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)];






    scalar t, gf, tflux;
    scalar * _i8 = tracers; scalar * _i9 = gfl; scalar * _i10 = tfluxl; if (tracers) for (t = *tracers, gf = *gfl, tflux = *tfluxl; ((scalar *)&t)->i >= 0; t = *++_i8, gf = *++_i9, tflux = *++_i10) {
      double cf1 = cf, ci = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(c.i)];
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(t.i)]/ci + s*((1.) < (1. - s*un) ? (1.) : (1. - s*un))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(gf.i)]*Delta/2.;
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = ff*cf1*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)];
      }
      else
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = 0.;
    }
  } } }} } } }
# 237 "/Users/weugene/basilisk/src/vof.h"
 ; }
if (((fm.y).i >= 65536) && ((cm).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.y.i -65536], _constant[fm.z.i - 65536], _constant[fm.x.i - 65536]};
(void)(_const_fm);
# 259 "/Users/weugene/basilisk/src/vof.h"
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 182 "/Users/weugene/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 182 "/Users/weugene/basilisk/src/vof.h"
{
# 182 "/Users/weugene/basilisk/src/vof.h"
 {






    double un = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)]*dt/(Delta*_const_fm.y + 1e-12), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;




    if (un*_const_fm.y*s/(_const_cm + 1e-12) > _cfl)
      _cfl = un*_const_fm.y*s/(_const_cm + 1e-12);
# 209 "/Users/weugene/basilisk/src/vof.h"
 double cf = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(c.i)] >= 1.) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(c.i)] :
      rectangle_fraction ((coord){-s*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(n.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(n.z.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(n.x.i)]}, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(alpha.i)],
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.i)] = cf*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)];






    scalar t, gf, tflux;
    scalar * _i8 = tracers; scalar * _i9 = gfl; scalar * _i10 = tfluxl; if (tracers) for (t = *tracers, gf = *gfl, tflux = *tfluxl; ((scalar *)&t)->i >= 0; t = *++_i8, gf = *++_i9, tflux = *++_i10) {
      double cf1 = cf, ci = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(c.i)];
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(t.i)]/ci + s*((1.) < (1. - s*un) ? (1.) : (1. - s*un))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(gf.i)]*Delta/2.;
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = ff*cf1*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)];
      }
      else
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = 0.;
    }
  } } }} } } }
# 237 "/Users/weugene/basilisk/src/vof.h"
 ; } if (_cfl > cfl) cfl = _cfl;
                                    ;



}
# 237 "/Users/weugene/basilisk/src/vof.h"
 }
  delete (gfl); free(gfl);
# 248 "/Users/weugene/basilisk/src/vof.h"
 scalar * fluxl = list_concat (((void*)0), tfluxl);
  fluxl = list_append (fluxl, flux);
  for (int l = (grid->depth) - 1; l >= 0; l--)
     { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _cache = ((Tree *)grid)->prolongation[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = l; int _k; for (_k = 0; _k < _cache.n; _k++) { point.i = _cache.p[_k].i; point.j = _cache.p[_k].j; point.k = _cache.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 251 "/Users/weugene/basilisk/src/vof.h"
 {
# 267 "/Users/weugene/basilisk/src/vof.h"
 if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0])))).pid >= 0))
 if (fluxl) for (scalar fl = *fluxl, *_i99 = fluxl; ((scalar *)&fl)->i >= 0; fl = *++_i99)
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fl.i)] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0][2*point.k-2 +0]) + sizeof(Cell)))[(fl.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0][2*point.k-2 +1]) + sizeof(Cell)))[(fl.i)] +
    ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +0][2*point.k-2 +0]) + sizeof(Cell)))[(fl.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +0][2*point.k-2 +1]) + sizeof(Cell)))[(fl.i)])/4.;
      if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0])))).pid >= 0))
 if (fluxl) for (scalar fl = *fluxl, *_i100 = fluxl; ((scalar *)&fl)->i >= 0; fl = *++_i100)
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(fl.i)] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +2][2*point.k-2 +0]) + sizeof(Cell)))[(fl.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +2][2*point.k-2 +1]) + sizeof(Cell)))[(fl.i)] +
     ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +2][2*point.k-2 +0]) + sizeof(Cell)))[(fl.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +2][2*point.k-2 +1]) + sizeof(Cell)))[(fl.i)])/4.;

    } } } } }; }}; }
  free(fluxl);





  if (cfl > 0.5 + 1e-6)
    fprintf (__stderrp,
      "WARNING: CFL must be <= 0.5 for VOF (cfl - 0.5 = %g)\n",
      cfl - 0.5), fflush (__stderrp);
# 305 "/Users/weugene/basilisk/src/vof.h"
 {
if (!((cm).i >= 65536)) {
# 305 "/Users/weugene/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 305 "/Users/weugene/basilisk/src/vof.h"
 {
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] += dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(flux.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cc.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)]))/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)]*Delta + 1e-12);
    scalar t, tc, tflux;
    scalar * _i11 = tracers; scalar * _i12 = tcl; scalar * _i13 = tfluxl; if (tracers) for (t = *tracers, tc = *tcl, tflux = *tfluxl; ((scalar *)&t)->i >= 0; t = *++_i11, tc = *++_i12, tflux = *++_i13)
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)] += dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(tflux.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tc.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)]))/
 (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)]*Delta + 1e-12);
  } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 305 "/Users/weugene/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 305 "/Users/weugene/basilisk/src/vof.h"
 {
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] += dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(flux.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cc.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)]))/(_const_cm*Delta + 1e-12);
    scalar t, tc, tflux;
    scalar * _i11 = tracers; scalar * _i12 = tcl; scalar * _i13 = tfluxl; if (tracers) for (t = *tracers, tc = *tcl, tflux = *tfluxl; ((scalar *)&t)->i >= 0; t = *++_i11, tc = *++_i12, tflux = *++_i13)
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)] += dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(tflux.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tc.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(uf.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.y.i)]))/
 (_const_cm*Delta + 1e-12);
  } } } } }; } }
  boundary (((scalar []){c,{-1}}));
  boundary (tracers);

  delete (tfluxl); free(tfluxl);
 delete (((scalar []){flux,alpha,n.x,n.y,n.z,{-1}})); }
# 142 "/Users/weugene/basilisk/src/vof.h"

static void sweep_z (scalar c, scalar cc, scalar * tcl)
{
  vector n= new_vector("n");
  scalar alpha= new_scalar("alpha"), flux= new_scalar("flux");
  double cfl = 0.;
# 156 "/Users/weugene/basilisk/src/vof.h"
 scalar * tracers = _attribute[c.i].tracers, * gfl = ((void*)0), * tfluxl = ((void*)0);
  if (tracers) {
    if (tracers) for (scalar t = *tracers, *_i98 = tracers; ((scalar *)&t)->i >= 0; t = *++_i98) {
      scalar gf = new_scalar("gf"), flux = new_scalar("flux");
      gfl = list_append (gfl, gf);
      tfluxl = list_append (tfluxl, flux);
    }




     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 167 "/Users/weugene/basilisk/src/vof.h"
 {
      scalar t, gf;
      scalar * _i6 = tracers; scalar * _i7 = gfl; if (tracers) for (t = *tracers, gf = *gfl; ((scalar *)&t)->i >= 0; t = *++_i6, gf = *++_i7)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(gf.i)] = vof_concentration_gradient_z (point, c, t);
    } } } } }; }
    boundary (gfl);
  }






  reconstruction (c, n, alpha);

   {


                  {
double _cfl = cfl;
# 182 "/Users/weugene/basilisk/src/vof.h"

if (!((fm.z).i >= 65536) && !((cm).i >= 65536)) {
# 182 "/Users/weugene/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 182 "/Users/weugene/basilisk/src/vof.h"
{
# 182 "/Users/weugene/basilisk/src/vof.h"
 {






    double un = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)]*dt/(Delta*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)] + 1e-12), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;




    if (un*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)]*s/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)] + 1e-12) > _cfl)
      _cfl = un*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)]*s/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)] + 1e-12);
# 209 "/Users/weugene/basilisk/src/vof.h"
 double cf = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(c.i)] >= 1.) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(c.i)] :
      rectangle_fraction ((coord){-s*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(n.z.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(n.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(n.y.i)]}, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(alpha.i)],
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.i)] = cf*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)];






    scalar t, gf, tflux;
    scalar * _i8 = tracers; scalar * _i9 = gfl; scalar * _i10 = tfluxl; if (tracers) for (t = *tracers, gf = *gfl, tflux = *tfluxl; ((scalar *)&t)->i >= 0; t = *++_i8, gf = *++_i9, tflux = *++_i10) {
      double cf1 = cf, ci = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(c.i)];
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(t.i)]/ci + s*((1.) < (1. - s*un) ? (1.) : (1. - s*un))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(gf.i)]*Delta/2.;
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = ff*cf1*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)];
      }
      else
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = 0.;
    }
  } } }} } } }
# 237 "/Users/weugene/basilisk/src/vof.h"
 ; }
if (((fm.z).i >= 65536) && !((cm).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.z.i -65536], _constant[fm.x.i - 65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 182 "/Users/weugene/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 182 "/Users/weugene/basilisk/src/vof.h"
{
# 182 "/Users/weugene/basilisk/src/vof.h"
 {






    double un = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)]*dt/(Delta*_const_fm.z + 1e-12), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;




    if (un*_const_fm.z*s/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)] + 1e-12) > _cfl)
      _cfl = un*_const_fm.z*s/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)] + 1e-12);
# 209 "/Users/weugene/basilisk/src/vof.h"
 double cf = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(c.i)] >= 1.) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(c.i)] :
      rectangle_fraction ((coord){-s*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(n.z.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(n.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(n.y.i)]}, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(alpha.i)],
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.i)] = cf*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)];






    scalar t, gf, tflux;
    scalar * _i8 = tracers; scalar * _i9 = gfl; scalar * _i10 = tfluxl; if (tracers) for (t = *tracers, gf = *gfl, tflux = *tfluxl; ((scalar *)&t)->i >= 0; t = *++_i8, gf = *++_i9, tflux = *++_i10) {
      double cf1 = cf, ci = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(c.i)];
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(t.i)]/ci + s*((1.) < (1. - s*un) ? (1.) : (1. - s*un))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(gf.i)]*Delta/2.;
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = ff*cf1*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)];
      }
      else
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = 0.;
    }
  } } }} } } }
# 237 "/Users/weugene/basilisk/src/vof.h"
 ; }
if (!((fm.z).i >= 65536) && ((cm).i >= 65536)) {
# 257 "/Users/weugene/basilisk/src/vof.h"
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 182 "/Users/weugene/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 182 "/Users/weugene/basilisk/src/vof.h"
{
# 182 "/Users/weugene/basilisk/src/vof.h"
 {






    double un = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)]*dt/(Delta*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)] + 1e-12), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;




    if (un*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)]*s/(_const_cm + 1e-12) > _cfl)
      _cfl = un*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)]*s/(_const_cm + 1e-12);
# 209 "/Users/weugene/basilisk/src/vof.h"
 double cf = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(c.i)] >= 1.) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(c.i)] :
      rectangle_fraction ((coord){-s*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(n.z.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(n.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(n.y.i)]}, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(alpha.i)],
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.i)] = cf*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)];






    scalar t, gf, tflux;
    scalar * _i8 = tracers; scalar * _i9 = gfl; scalar * _i10 = tfluxl; if (tracers) for (t = *tracers, gf = *gfl, tflux = *tfluxl; ((scalar *)&t)->i >= 0; t = *++_i8, gf = *++_i9, tflux = *++_i10) {
      double cf1 = cf, ci = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(c.i)];
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(t.i)]/ci + s*((1.) < (1. - s*un) ? (1.) : (1. - s*un))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(gf.i)]*Delta/2.;
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = ff*cf1*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)];
      }
      else
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = 0.;
    }
  } } }} } } }
# 237 "/Users/weugene/basilisk/src/vof.h"
 ; }
if (((fm.z).i >= 65536) && ((cm).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.z.i -65536], _constant[fm.x.i - 65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 259 "/Users/weugene/basilisk/src/vof.h"
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 182 "/Users/weugene/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 182 "/Users/weugene/basilisk/src/vof.h"
{
# 182 "/Users/weugene/basilisk/src/vof.h"
 {






    double un = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)]*dt/(Delta*_const_fm.z + 1e-12), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;




    if (un*_const_fm.z*s/(_const_cm + 1e-12) > _cfl)
      _cfl = un*_const_fm.z*s/(_const_cm + 1e-12);
# 209 "/Users/weugene/basilisk/src/vof.h"
 double cf = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(c.i)] >= 1.) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(c.i)] :
      rectangle_fraction ((coord){-s*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(n.z.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(n.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(n.y.i)]}, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(alpha.i)],
     (coord){-0.5, -0.5, -0.5},
     (coord){s*un - 0.5, 0.5, 0.5});





    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.i)] = cf*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)];






    scalar t, gf, tflux;
    scalar * _i8 = tracers; scalar * _i9 = gfl; scalar * _i10 = tfluxl; if (tracers) for (t = *tracers, gf = *gfl, tflux = *tfluxl; ((scalar *)&t)->i >= 0; t = *++_i8, gf = *++_i9, tflux = *++_i10) {
      double cf1 = cf, ci = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(c.i)];
      if (_attribute[t.i].inverse)
 cf1 = 1. - cf1, ci = 1. - ci;
      if (ci > 1e-10) {
 double ff = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(t.i)]/ci + s*((1.) < (1. - s*un) ? (1.) : (1. - s*un))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(gf.i)]*Delta/2.;
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = ff*cf1*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)];
      }
      else
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] = 0.;
    }
  } } }} } } }
# 237 "/Users/weugene/basilisk/src/vof.h"
 ; } if (_cfl > cfl) cfl = _cfl;
                                    ;



}
# 237 "/Users/weugene/basilisk/src/vof.h"
 }
  delete (gfl); free(gfl);
# 248 "/Users/weugene/basilisk/src/vof.h"
 scalar * fluxl = list_concat (((void*)0), tfluxl);
  fluxl = list_append (fluxl, flux);
  for (int l = (grid->depth) - 1; l >= 0; l--)
     { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _cache = ((Tree *)grid)->prolongation[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = l; int _k; for (_k = 0; _k < _cache.n; _k++) { point.i = _cache.p[_k].i; point.j = _cache.p[_k].j; point.k = _cache.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 251 "/Users/weugene/basilisk/src/vof.h"
 {
# 267 "/Users/weugene/basilisk/src/vof.h"
 if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1])))).pid >= 0))
 if (fluxl) for (scalar fl = *fluxl, *_i99 = fluxl; ((scalar *)&fl)->i >= 0; fl = *++_i99)
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fl.i)] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0][2*point.k-2 +0]) + sizeof(Cell)))[(fl.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +0][2*point.k-2 +0]) + sizeof(Cell)))[(fl.i)] +
    ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +1][2*point.k-2 +0]) + sizeof(Cell)))[(fl.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +1][2*point.k-2 +0]) + sizeof(Cell)))[(fl.i)])/4.;
      if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1])))).pid >= 0))
 if (fluxl) for (scalar fl = *fluxl, *_i100 = fluxl; ((scalar *)&fl)->i >= 0; fl = *++_i100)
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(fl.i)] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0][2*point.k-2 +2]) + sizeof(Cell)))[(fl.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +0][2*point.k-2 +2]) + sizeof(Cell)))[(fl.i)] +
     ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +1][2*point.k-2 +2]) + sizeof(Cell)))[(fl.i)] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +1][2*point.k-2 +2]) + sizeof(Cell)))[(fl.i)])/4.;

    } } } } }; }}; }
  free(fluxl);





  if (cfl > 0.5 + 1e-6)
    fprintf (__stderrp,
      "WARNING: CFL must be <= 0.5 for VOF (cfl - 0.5 = %g)\n",
      cfl - 0.5), fflush (__stderrp);
# 305 "/Users/weugene/basilisk/src/vof.h"
 {
if (!((cm).i >= 65536)) {
# 305 "/Users/weugene/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 305 "/Users/weugene/basilisk/src/vof.h"
 {
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] += dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(flux.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cc.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(uf.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)]))/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)]*Delta + 1e-12);
    scalar t, tc, tflux;
    scalar * _i11 = tracers; scalar * _i12 = tcl; scalar * _i13 = tfluxl; if (tracers) for (t = *tracers, tc = *tcl, tflux = *tfluxl; ((scalar *)&t)->i >= 0; t = *++_i11, tc = *++_i12, tflux = *++_i13)
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)] += dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(tflux.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tc.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(uf.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)]))/
 (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)]*Delta + 1e-12);
  } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 305 "/Users/weugene/basilisk/src/vof.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 305 "/Users/weugene/basilisk/src/vof.h"
 {
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] += dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(flux.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(flux.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cc.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(uf.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)]))/(_const_cm*Delta + 1e-12);
    scalar t, tc, tflux;
    scalar * _i11 = tracers; scalar * _i12 = tcl; scalar * _i13 = tfluxl; if (tracers) for (t = *tracers, tc = *tcl, tflux = *tfluxl; ((scalar *)&t)->i >= 0; t = *++_i11, tc = *++_i12, tflux = *++_i13)
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)] += dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tflux.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(tflux.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tc.i)]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(uf.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(uf.z.i)]))/
 (_const_cm*Delta + 1e-12);
  } } } } }; } }
  boundary (((scalar []){c,{-1}}));
  boundary (tracers);

  delete (tfluxl); free(tfluxl);
 delete (((scalar []){flux,alpha,n.x,n.y,n.z,{-1}})); }






void vof_advection (scalar * interfaces, int i)
{
  if (interfaces) for (scalar c = *interfaces, *_i101 = interfaces; ((scalar *)&c)->i >= 0; c = *++_i101) {
# 335 "/Users/weugene/basilisk/src/vof.h"
 scalar cc= new_scalar("cc"), * tcl = ((void*)0), * tracers = _attribute[c.i].tracers;
    if (tracers) for (scalar t = *tracers, *_i102 = tracers; ((scalar *)&t)->i >= 0; t = *++_i102) {
      scalar tc = new_scalar("tc");
      tcl = list_append (tcl, tc);

      _attribute[t.i].restriction = restriction_volume_average;
      _attribute[t.i].refine = _attribute[t.i].prolongation = vof_concentration_refine;
      _attribute[t.i].c = c;

    }
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 345 "/Users/weugene/basilisk/src/vof.h"
 {
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cc.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] > 0.5);
      scalar t, tc;
      scalar * _i14 = tracers; scalar * _i15 = tcl; if (tracers) for (t = *tracers, tc = *tcl; ((scalar *)&t)->i >= 0; t = *++_i14, tc = *++_i15) {
 if (_attribute[t.i].inverse)
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tc.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] < 0.5 ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]/(1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)]) : 0.;
 else
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(tc.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] > 0.5 ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] : 0.;
      }
    } } } } }; }






    void (* sweep[3]) (scalar, scalar, scalar *);
    int d = 0;
    {
# 363 "/Users/weugene/basilisk/src/vof.h"

      sweep[d++] = sweep_x;
# 363 "/Users/weugene/basilisk/src/vof.h"

      sweep[d++] = sweep_y;
# 363 "/Users/weugene/basilisk/src/vof.h"

      sweep[d++] = sweep_z;}
    for (d = 0; d < 3; d++)
      sweep[(i + d) % 3] (c, cc, tcl);
    delete (tcl), free(tcl);
   delete (((scalar []){cc,{-1}})); }
}

static int vof_0_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int vof_0 (const int i, const double t, Event * _ev) { ;
  vof_advection (interfaces, i); ; return 0; }
# 14 "/Users/weugene/basilisk/src/two-phase.h"

scalar f= {15}, * interfaces = ((scalar []){{15},{-1}});
double rho1 = 1., mu1 = 0., rho2 = 1., mu2 = 0.;





vector alphav= {{16},{17},{18}};
scalar rhov= {19};

static int defaults_2_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i = 0); *ip = i; *tp = t; return ret; } static int defaults_2 (const int i, const double t, Event * _ev) { ; {
  alpha = alphav;
  rho = rhov;





  if (mu1 || mu2)
    mu = new_face_vector("mu");




  display ((struct _display){"draw_vof (c = 'f');"});
                                                                       ; } return 0; }
# 59 "/Users/weugene/basilisk/src/two-phase.h"
scalar sf= {20};




static int tracer_advection_0_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int tracer_advection_0 (const int i, const double t, Event * _ev) { ;
{
# 78 "/Users/weugene/basilisk/src/two-phase.h"
 { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 78 "/Users/weugene/basilisk/src/two-phase.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(sf.i)] = (8.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] +
     4.*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(f.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(f.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(f.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(f.i)]) +
     2.*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(f.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(f.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(f.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(f.i)] +
  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(f.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(f.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(f.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(f.i)] +
  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(f.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(f.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(f.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(f.i)]) +
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+1]) + sizeof(Cell)))[(f.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+1]) + sizeof(Cell)))[(f.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+-1]) + sizeof(Cell)))[(f.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+1]) + sizeof(Cell)))[(f.i)] +
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+-1]) + sizeof(Cell)))[(f.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(f.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(f.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+1]) + sizeof(Cell)))[(f.i)])/64.; } } } }; }




  _attribute[sf.i].prolongation = refine_bilinear;
  boundary (((scalar []){sf,{-1}}));

                                                                               ; } return 0; }

static int properties_0_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int properties_0 (const int i, const double t, Event * _ev) { ;
{
   {
if (!((fm.x).i >= 65536)) {
# 97 "/Users/weugene/basilisk/src/two-phase.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 97 "/Users/weugene/basilisk/src/two-phase.h"
{
# 97 "/Users/weugene/basilisk/src/two-phase.h"
 {
    double ff = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(sf.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(sf.i)])/2.;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alphav.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]/(((ff) < (0.) ? (0.) : (ff) > (1.) ? (1.) : (ff))*(rho1 - rho2) + rho2);
    if (mu1 || mu2) {
      vector muv = mu;
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(muv.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]*(1./(((ff) < (0) ? (0) : (ff) > (1) ? (1) : (ff))*(1./mu1 - 1./mu2) + 1./mu2));
    }
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 97 "/Users/weugene/basilisk/src/two-phase.h"
{
# 97 "/Users/weugene/basilisk/src/two-phase.h"
 {
    double ff = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(sf.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(sf.i)])/2.;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alphav.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]/(((ff) < (0.) ? (0.) : (ff) > (1.) ? (1.) : (ff))*(rho1 - rho2) + rho2);
    if (mu1 || mu2) {
      vector muv = mu;
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(muv.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]*(1./(((ff) < (0) ? (0) : (ff) > (1) ? (1) : (ff))*(1./mu1 - 1./mu2) + 1./mu2));
    }
  } } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 97 "/Users/weugene/basilisk/src/two-phase.h"
{
# 97 "/Users/weugene/basilisk/src/two-phase.h"
 {
    double ff = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(sf.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(sf.i)])/2.;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alphav.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)]/(((ff) < (0.) ? (0.) : (ff) > (1.) ? (1.) : (ff))*(rho1 - rho2) + rho2);
    if (mu1 || mu2) {
      vector muv = mu;
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(muv.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)]*(1./(((ff) < (0) ? (0) : (ff) > (1) ? (1) : (ff))*(1./mu1 - 1./mu2) + 1./mu2));
    }
  } } }} } } }
# 104 "/Users/weugene/basilisk/src/two-phase.h"
 ; }
if (((fm.x).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 97 "/Users/weugene/basilisk/src/two-phase.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 97 "/Users/weugene/basilisk/src/two-phase.h"
{
# 97 "/Users/weugene/basilisk/src/two-phase.h"
 {
    double ff = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(sf.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(sf.i)])/2.;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alphav.x.i)] = _const_fm.x/(((ff) < (0.) ? (0.) : (ff) > (1.) ? (1.) : (ff))*(rho1 - rho2) + rho2);
    if (mu1 || mu2) {
      vector muv = mu;
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(muv.x.i)] = _const_fm.x*(1./(((ff) < (0) ? (0) : (ff) > (1) ? (1) : (ff))*(1./mu1 - 1./mu2) + 1./mu2));
    }
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 97 "/Users/weugene/basilisk/src/two-phase.h"
{
# 97 "/Users/weugene/basilisk/src/two-phase.h"
 {
    double ff = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(sf.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(sf.i)])/2.;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alphav.y.i)] = _const_fm.y/(((ff) < (0.) ? (0.) : (ff) > (1.) ? (1.) : (ff))*(rho1 - rho2) + rho2);
    if (mu1 || mu2) {
      vector muv = mu;
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(muv.y.i)] = _const_fm.y*(1./(((ff) < (0) ? (0) : (ff) > (1) ? (1) : (ff))*(1./mu1 - 1./mu2) + 1./mu2));
    }
  } } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 97 "/Users/weugene/basilisk/src/two-phase.h"
{
# 97 "/Users/weugene/basilisk/src/two-phase.h"
 {
    double ff = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(sf.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(sf.i)])/2.;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alphav.z.i)] = _const_fm.z/(((ff) < (0.) ? (0.) : (ff) > (1.) ? (1.) : (ff))*(rho1 - rho2) + rho2);
    if (mu1 || mu2) {
      vector muv = mu;
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(muv.z.i)] = _const_fm.z*(1./(((ff) < (0) ? (0) : (ff) > (1) ? (1) : (ff))*(1./mu1 - 1./mu2) + 1./mu2));
    }
  } } }} } } }
# 104 "/Users/weugene/basilisk/src/two-phase.h"
 ; } }
   {
if (!((cm).i >= 65536)) {
# 105 "/Users/weugene/basilisk/src/two-phase.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 105 "/Users/weugene/basilisk/src/two-phase.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rhov.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)]*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(sf.i)]) < (0.) ? (0.) : (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(sf.i)]) > (1.) ? (1.) : (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(sf.i)]))*(rho1 - rho2) + rho2); } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 105 "/Users/weugene/basilisk/src/two-phase.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 105 "/Users/weugene/basilisk/src/two-phase.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(rhov.i)] = _const_cm*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(sf.i)]) < (0.) ? (0.) : (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(sf.i)]) > (1.) ? (1.) : (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(sf.i)]))*(rho1 - rho2) + rho2); } } } }; } }


  _attribute[sf.i].prolongation = fraction_refine;
  boundary (((scalar []){sf,{-1}}));

                                                                          ; } return 0; }
# 21 "tube_bp_rel.c"
# 1 "./tension.h"
# 1 "/Users/weugene/basilisk/src/tension.h"
# 15 "/Users/weugene/basilisk/src/tension.h"
# 1 "./iforce.h"
# 1 "/Users/weugene/basilisk/src/iforce.h"
# 20 "/Users/weugene/basilisk/src/iforce.h"
# 30 "/Users/weugene/basilisk/src/iforce.h"
static int defaults_3_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i = 0); *ip = i; *tp = t; return ret; } static int defaults_3 (const int i, const double t, Event * _ev) { ; {
  if (((a.x).i >= 65536)) {
    a = new_face_vector("a");

     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 34 "/Users/weugene/basilisk/src/iforce.h"
{
# 34 "/Users/weugene/basilisk/src/iforce.h"
{
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.x.i)] = 0.;

    } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 34 "/Users/weugene/basilisk/src/iforce.h"
{
# 34 "/Users/weugene/basilisk/src/iforce.h"
{
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.y.i)] = 0.;

    } } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 34 "/Users/weugene/basilisk/src/iforce.h"
{
# 34 "/Users/weugene/basilisk/src/iforce.h"
{
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.z.i)] = 0.;

    } } }} } } }
# 37 "/Users/weugene/basilisk/src/iforce.h"
 ; }
    boundary ((scalar *)((vector []){{a.x,a.y,a.z},{{-1},{-1},{-1}}}));

  }
                                                                    ; } return 0; }






static int acceleration_0_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int acceleration_0 (const int i, const double t, Event * _ev) { ;
{





  scalar * list = ((void*)0);
  if (interfaces) for (scalar f = *interfaces, *_i103 = interfaces; ((scalar *)&f)->i >= 0; f = *++_i103)
    if (_attribute[f.i].phi.i) {
      list = list_add (list, f);






       { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 65 "/Users/weugene/basilisk/src/iforce.h"

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]) < (0.) ? (0.) : (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]) > (1.) ? (1.) : (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)])); } } } }; }
      boundary (((scalar []){f,{-1}}));
    }
# 78 "/Users/weugene/basilisk/src/iforce.h"
 if (list) for (scalar f = *list, *_i104 = list; ((scalar *)&f)->i >= 0; f = *++_i104)
    _attribute[f.i].prolongation = _attribute[p.i].prolongation;
  boundary (list);
# 90 "/Users/weugene/basilisk/src/iforce.h"
 double alpha_mean = 2.0/(rho1 + rho2);
  vector ia = a;
   {
if (!((fm.x).i >= 65536)) {
# 92 "/Users/weugene/basilisk/src/iforce.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 92 "/Users/weugene/basilisk/src/iforce.h"
{
# 92 "/Users/weugene/basilisk/src/iforce.h"

    if (list) for (scalar f = *list, *_i105 = list; ((scalar *)&f)->i >= 0; f = *++_i105)
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] != ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]) {
# 104 "/Users/weugene/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] < ((double)1e30) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] < ((double)1e30)) ?
   (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)])/2. :
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] :
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] :
   0.;

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(ia.x.i)] += alpha_mean/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]*phif*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)])/Delta;

      } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 92 "/Users/weugene/basilisk/src/iforce.h"
{
# 92 "/Users/weugene/basilisk/src/iforce.h"

    if (list) for (scalar f = *list, *_i105 = list; ((scalar *)&f)->i >= 0; f = *++_i105)
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] != ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(f.i)]) {
# 104 "/Users/weugene/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] < ((double)1e30) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(phi.i)] < ((double)1e30)) ?
   (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(phi.i)])/2. :
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] :
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(phi.i)] :
   0.;

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(ia.y.i)] += alpha_mean/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]*phif*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(f.i)])/Delta;

      } } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 92 "/Users/weugene/basilisk/src/iforce.h"
{
# 92 "/Users/weugene/basilisk/src/iforce.h"

    if (list) for (scalar f = *list, *_i105 = list; ((scalar *)&f)->i >= 0; f = *++_i105)
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] != ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(f.i)]) {
# 104 "/Users/weugene/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] < ((double)1e30) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(phi.i)] < ((double)1e30)) ?
   (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(phi.i)])/2. :
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] :
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(phi.i)] :
   0.;

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(ia.z.i)] += alpha_mean/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)]*phif*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(f.i)])/Delta;

      } } }} } } }
# 114 "/Users/weugene/basilisk/src/iforce.h"
 ; }
if (((fm.x).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 92 "/Users/weugene/basilisk/src/iforce.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 92 "/Users/weugene/basilisk/src/iforce.h"
{
# 92 "/Users/weugene/basilisk/src/iforce.h"

    if (list) for (scalar f = *list, *_i105 = list; ((scalar *)&f)->i >= 0; f = *++_i105)
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] != ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]) {
# 104 "/Users/weugene/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] < ((double)1e30) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] < ((double)1e30)) ?
   (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)])/2. :
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] :
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] :
   0.;

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(ia.x.i)] += alpha_mean/_const_fm.x*phif*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)])/Delta;

      } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 92 "/Users/weugene/basilisk/src/iforce.h"
{
# 92 "/Users/weugene/basilisk/src/iforce.h"

    if (list) for (scalar f = *list, *_i105 = list; ((scalar *)&f)->i >= 0; f = *++_i105)
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] != ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(f.i)]) {
# 104 "/Users/weugene/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] < ((double)1e30) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(phi.i)] < ((double)1e30)) ?
   (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(phi.i)])/2. :
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] :
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(phi.i)] :
   0.;

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(ia.y.i)] += alpha_mean/_const_fm.y*phif*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(f.i)])/Delta;

      } } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 92 "/Users/weugene/basilisk/src/iforce.h"
{
# 92 "/Users/weugene/basilisk/src/iforce.h"

    if (list) for (scalar f = *list, *_i105 = list; ((scalar *)&f)->i >= 0; f = *++_i105)
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] != ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(f.i)]) {
# 104 "/Users/weugene/basilisk/src/iforce.h"
 scalar phi = _attribute[f.i].phi;
 double phif =
   (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] < ((double)1e30) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(phi.i)] < ((double)1e30)) ?
   (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(phi.i)])/2. :
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] :
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(phi.i)] < ((double)1e30) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(phi.i)] :
   0.;

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(ia.z.i)] += alpha_mean/_const_fm.z*phif*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(f.i)])/Delta;

      } } }} } } }
# 114 "/Users/weugene/basilisk/src/iforce.h"
 ; } }






  if (list) for (scalar f = *list, *_i106 = list; ((scalar *)&f)->i >= 0; f = *++_i106)
    _attribute[f.i].prolongation = fraction_refine;
  boundary (list);






  if (list) for (scalar f = *list, *_i107 = list; ((scalar *)&f)->i >= 0; f = *++_i107) {
    scalar phi = _attribute[f.i].phi;
    delete (((scalar []){phi,{-1}}));
    _attribute[f.i].phi.i = 0;
  }
  free(list);
                                                                         ; } return 0; }
# 16 "/Users/weugene/basilisk/src/tension.h"
# 1 "./curvature.h"
# 1 "/Users/weugene/basilisk/src/curvature.h"
# 12 "/Users/weugene/basilisk/src/curvature.h"
static void curvature_restriction (Point point, scalar kappa)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 13 "/Users/weugene/basilisk/src/curvature.h"

  double k = 0., s = 0.;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(kappa.i)] != ((double)1e30))
      k += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(kappa.i)], s++; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(kappa.i)] = s ? k/s : ((double)1e30);
}







static void curvature_prolongation (Point point, scalar kappa)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 28 "/Users/weugene/basilisk/src/curvature.h"

   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; {
    double sk = 0., s = 0.;
    for (int i = 0; i <= 1; i++)

      for (int j = 0; j <= 1; j++)


 for (int k = 0; k <= 1; k++)

   if (((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+child.x*i] [(point.j+2)/2+child.y*j][(point.k+2)/2+child.z*k]) + sizeof(Cell)))[(kappa.i)] != ((double)1e30))
     sk += ((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+child.x*i] [(point.j+2)/2+child.y*j][(point.k+2)/2+child.z*k]) + sizeof(Cell)))[(kappa.i)], s++;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(kappa.i)] = s ? sk/s : ((double)1e30);
  } } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
}
# 66 "/Users/weugene/basilisk/src/curvature.h"
# 1 "./heights.h"
# 1 "/Users/weugene/basilisk/src/heights.h"
# 29 "/Users/weugene/basilisk/src/heights.h"
static inline double height (double H) {
  return H > 20./2. ? H - 20. : H < -20./2. ? H + 20. : H;
}

static inline int orientation (double H) {
  return fabs(H) > 20./2.;
}
# 49 "/Users/weugene/basilisk/src/heights.h"
static void half_column (Point point, scalar c, vector h, vector cs, int j)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 50 "/Users/weugene/basilisk/src/heights.h"







  const int complete = -1;

  {
# 59 "/Users/weugene/basilisk/src/heights.h"
 {







    double S = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)], H = S, ci, a;







    typedef struct { int s; double h; } HState;
    HState state = {0, 0};
    if (j == 1) {




      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.x.i)] == 300.)
 state.s = complete, state.h = ((double)1e30);




      else {
 int s = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.x.i)] + 20./2.)/100.;
 state.h = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.x.i)] - 100.*s;
 state.s = s - 1;
      }





      if (state.s != complete)
 S = state.s, H = state.h;
    }
# 109 "/Users/weugene/basilisk/src/heights.h"
 for (int i = 1; i <= 4; i++) {
      ci = i <= 2 ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i*j][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(i - 2)*j][point.j+0] [point.k+0]) + sizeof(Cell)))[(cs.x.i)];
      H += ci;




      if (S > 0. && S < 1.) {
 S = ci;
 if (ci <= 0. || ci >= 1.) {







   H -= i*ci;
   break;
 }
      }
# 138 "/Users/weugene/basilisk/src/heights.h"
 else if (S >= 1. && ci <= 0.) {
 H = (H - 0.5)*j + (j == -1)*20.;
 S = complete;
 break;
      }
      else if (S <= 0. && ci >= 1.) {
 H = (i + 0.5 - H)*j + (j == 1)*20.;
 S = complete;
 break;
      }
# 156 "/Users/weugene/basilisk/src/heights.h"
 else if (S == ci && modf(H, &a))
 break;
    }





    if (j == -1) {







      if (S != complete && ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] >= 1.) ||
       (S > 0. && S < 1.)))
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.x.i)] = 300.;
      else if (S == complete)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.x.i)] = H;
      else





 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.x.i)] = H + 100.*(1. + (S >= 1.));
    }
    else {
# 195 "/Users/weugene/basilisk/src/heights.h"
 if (state.s != complete ||
   (S == complete && fabs(height(H)) < fabs(height(state.h))))
 state.s = S, state.h = H;





      if (state.s != complete)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.x.i)] = ((double)1e30);
      else
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.x.i)] = (state.h > 1e10 ? ((double)1e30) : state.h);
    }
  }
# 59 "/Users/weugene/basilisk/src/heights.h"
 {







    double S = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)], H = S, ci, a;







    typedef struct { int s; double h; } HState;
    HState state = {0, 0};
    if (j == 1) {




      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)] == 300.)
 state.s = complete, state.h = ((double)1e30);




      else {
 int s = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)] + 20./2.)/100.;
 state.h = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)] - 100.*s;
 state.s = s - 1;
      }





      if (state.s != complete)
 S = state.s, H = state.h;
    }
# 109 "/Users/weugene/basilisk/src/heights.h"
 for (int i = 1; i <= 4; i++) {
      ci = i <= 2 ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i*j] [point.k+0]) + sizeof(Cell)))[(c.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+(i - 2)*j] [point.k+0]) + sizeof(Cell)))[(cs.y.i)];
      H += ci;




      if (S > 0. && S < 1.) {
 S = ci;
 if (ci <= 0. || ci >= 1.) {







   H -= i*ci;
   break;
 }
      }
# 138 "/Users/weugene/basilisk/src/heights.h"
 else if (S >= 1. && ci <= 0.) {
 H = (H - 0.5)*j + (j == -1)*20.;
 S = complete;
 break;
      }
      else if (S <= 0. && ci >= 1.) {
 H = (i + 0.5 - H)*j + (j == 1)*20.;
 S = complete;
 break;
      }
# 156 "/Users/weugene/basilisk/src/heights.h"
 else if (S == ci && modf(H, &a))
 break;
    }





    if (j == -1) {







      if (S != complete && ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] >= 1.) ||
       (S > 0. && S < 1.)))
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)] = 300.;
      else if (S == complete)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)] = H;
      else





 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)] = H + 100.*(1. + (S >= 1.));
    }
    else {
# 195 "/Users/weugene/basilisk/src/heights.h"
 if (state.s != complete ||
   (S == complete && fabs(height(H)) < fabs(height(state.h))))
 state.s = S, state.h = H;





      if (state.s != complete)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)] = ((double)1e30);
      else
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)] = (state.h > 1e10 ? ((double)1e30) : state.h);
    }
  }
# 59 "/Users/weugene/basilisk/src/heights.h"
 {







    double S = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)], H = S, ci, a;







    typedef struct { int s; double h; } HState;
    HState state = {0, 0};
    if (j == 1) {




      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)] == 300.)
 state.s = complete, state.h = ((double)1e30);




      else {
 int s = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)] + 20./2.)/100.;
 state.h = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)] - 100.*s;
 state.s = s - 1;
      }





      if (state.s != complete)
 S = state.s, H = state.h;
    }
# 109 "/Users/weugene/basilisk/src/heights.h"
 for (int i = 1; i <= 4; i++) {
      ci = i <= 2 ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i*j]) + sizeof(Cell)))[(c.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+(i - 2)*j]) + sizeof(Cell)))[(cs.z.i)];
      H += ci;




      if (S > 0. && S < 1.) {
 S = ci;
 if (ci <= 0. || ci >= 1.) {







   H -= i*ci;
   break;
 }
      }
# 138 "/Users/weugene/basilisk/src/heights.h"
 else if (S >= 1. && ci <= 0.) {
 H = (H - 0.5)*j + (j == -1)*20.;
 S = complete;
 break;
      }
      else if (S <= 0. && ci >= 1.) {
 H = (i + 0.5 - H)*j + (j == 1)*20.;
 S = complete;
 break;
      }
# 156 "/Users/weugene/basilisk/src/heights.h"
 else if (S == ci && modf(H, &a))
 break;
    }





    if (j == -1) {







      if (S != complete && ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] <= 0. || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] >= 1.) ||
       (S > 0. && S < 1.)))
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)] = 300.;
      else if (S == complete)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)] = H;
      else





 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)] = H + 100.*(1. + (S >= 1.));
    }
    else {
# 195 "/Users/weugene/basilisk/src/heights.h"
 if (state.s != complete ||
   (S == complete && fabs(height(H)) < fabs(height(state.h))))
 state.s = S, state.h = H;





      if (state.s != complete)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)] = ((double)1e30);
      else
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)] = (state.h > 1e10 ? ((double)1e30) : state.h);
    }
  }}
}
# 222 "/Users/weugene/basilisk/src/heights.h"
static void column_propagation (vector h)
{
   { { Point root = {2,2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) { if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & active) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0)) {{
# 224 "/Users/weugene/basilisk/src/heights.h"

    for (int i = -2; i <= 2; i++)
      {
# 226 "/Users/weugene/basilisk/src/heights.h"

 if (fabs(height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.x.i)])) <= 3.5 &&
     fabs(height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.x.i)]) + i) < fabs(height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.x.i)])))
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.x.i)] + i;
# 226 "/Users/weugene/basilisk/src/heights.h"

 if (fabs(height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(h.y.i)])) <= 3.5 &&
     fabs(height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(h.y.i)]) + i) < fabs(height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)])))
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(h.y.i)] + i;
# 226 "/Users/weugene/basilisk/src/heights.h"

 if (fabs(height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(h.z.i)])) <= 3.5 &&
     fabs(height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(h.z.i)]) + i) < fabs(height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)])))
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(h.z.i)] + i;}; } } continue; } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
  boundary ((scalar *)((vector []){{h.x,h.y,h.z},{{-1},{-1},{-1}}}));
}
# 291 "/Users/weugene/basilisk/src/heights.h"
# 291 "/Users/weugene/basilisk/src/heights.h"

static void refine_h_x (Point point, scalar h)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 293 "/Users/weugene/basilisk/src/heights.h"





  _Bool complete = 1;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; {
    for (int i = -2; i <= 2; i++)
      if ((point.i+i >= 0 && point.i+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) &&
   !(!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0])))).pid >= 0) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0])))).pid < 0) &&
   fabs(height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)])) <= 3.5 &&
   fabs(height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)]) + i) < fabs(height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)])))
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)] + i;
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)] == ((double)1e30))
      complete = 0;
  } } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  if (complete)
    return;
# 319 "/Users/weugene/basilisk/src/heights.h"
 int ori = orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)]);
# 332 "/Users/weugene/basilisk/src/heights.h"
 double H[3][3], H0 = height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)]);
  for (int i = -1; i <= 1; i++)
    for (int j = -1; j <= 1; j++)
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j]) + sizeof(Cell)))[(h.i)] == ((double)1e30) || orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j]) + sizeof(Cell)))[(h.i)]) != ori)
 return;
      else
 H[i+1][j+1] = height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j]) + sizeof(Cell)))[(h.i)]) - H0;

  double h0 =
    2.*H0 + (H[2][2] + H[2][0] + H[0][0] + H[0][2] +
      30.*(H[2][1] + H[0][1] + H[1][0] + H[1][2]))/512.
    + 20.*ori;
  double h1 = (H[2][2] + H[2][0] - H[0][0] - H[0][2] +
        30.*(H[2][1] - H[0][1]))/128.;
  double h2 = (H[2][2] - H[2][0] - H[0][0] + H[0][2] +
        30.*(H[1][2] - H[1][0]))/128.;
  double h3 = (H[0][0] + H[2][2] - H[0][2] - H[2][0])/32.;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)] == ((double)1e30))
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)] = h0 + h1*child.y + h2*child.z + h3*child.y*child.z - child.x/2.; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }

}
# 291 "/Users/weugene/basilisk/src/heights.h"

static void refine_h_y (Point point, scalar h)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 293 "/Users/weugene/basilisk/src/heights.h"





  _Bool complete = 1;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; {
    for (int i = -2; i <= 2; i++)
      if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+i >= 0 && point.j+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) &&
   !(!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0])))).pid >= 0) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0])))).pid < 0) &&
   fabs(height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(h.i)])) <= 3.5 &&
   fabs(height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(h.i)]) + i) < fabs(height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)])))
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(h.i)] + i;
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)] == ((double)1e30))
      complete = 0;
  } } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  if (complete)
    return;
# 319 "/Users/weugene/basilisk/src/heights.h"
 int ori = orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)]);
# 332 "/Users/weugene/basilisk/src/heights.h"
 double H[3][3], H0 = height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)]);
  for (int i = -1; i <= 1; i++)
    for (int j = -1; j <= 1; j++)
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i]) + sizeof(Cell)))[(h.i)] == ((double)1e30) || orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i]) + sizeof(Cell)))[(h.i)]) != ori)
 return;
      else
 H[i+1][j+1] = height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i]) + sizeof(Cell)))[(h.i)]) - H0;

  double h0 =
    2.*H0 + (H[2][2] + H[2][0] + H[0][0] + H[0][2] +
      30.*(H[2][1] + H[0][1] + H[1][0] + H[1][2]))/512.
    + 20.*ori;
  double h1 = (H[2][2] + H[2][0] - H[0][0] - H[0][2] +
        30.*(H[2][1] - H[0][1]))/128.;
  double h2 = (H[2][2] - H[2][0] - H[0][0] + H[0][2] +
        30.*(H[1][2] - H[1][0]))/128.;
  double h3 = (H[0][0] + H[2][2] - H[0][2] - H[2][0])/32.;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)] == ((double)1e30))
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)] = h0 + h1*child.z + h2*child.x + h3*child.z*child.x - child.y/2.; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }

}
# 291 "/Users/weugene/basilisk/src/heights.h"

static void refine_h_z (Point point, scalar h)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 293 "/Users/weugene/basilisk/src/heights.h"





  _Bool complete = 1;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; {
    for (int i = -2; i <= 2; i++)
      if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+i >= 0 && point.k+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) &&
   !(!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i])))).pid >= 0) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i])))).pid < 0) &&
   fabs(height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(h.i)])) <= 3.5 &&
   fabs(height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(h.i)]) + i) < fabs(height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)])))
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(h.i)] + i;
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)] == ((double)1e30))
      complete = 0;
  } } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  if (complete)
    return;
# 319 "/Users/weugene/basilisk/src/heights.h"
 int ori = orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)]);
# 332 "/Users/weugene/basilisk/src/heights.h"
 double H[3][3], H0 = height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)]);
  for (int i = -1; i <= 1; i++)
    for (int j = -1; j <= 1; j++)
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]) + sizeof(Cell)))[(h.i)] == ((double)1e30) || orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]) + sizeof(Cell)))[(h.i)]) != ori)
 return;
      else
 H[i+1][j+1] = height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]) + sizeof(Cell)))[(h.i)]) - H0;

  double h0 =
    2.*H0 + (H[2][2] + H[2][0] + H[0][0] + H[0][2] +
      30.*(H[2][1] + H[0][1] + H[1][0] + H[1][2]))/512.
    + 20.*ori;
  double h1 = (H[2][2] + H[2][0] - H[0][0] - H[0][2] +
        30.*(H[2][1] - H[0][1]))/128.;
  double h2 = (H[2][2] - H[2][0] - H[0][0] + H[0][2] +
        30.*(H[1][2] - H[1][0]))/128.;
  double h3 = (H[0][0] + H[2][2] - H[0][2] - H[2][0])/32.;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)] == ((double)1e30))
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.i)] = h0 + h1*child.x + h2*child.y + h3*child.x*child.y - child.z/2.; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }

}







void heights (scalar c, vector h)
{ ;
  vector cs= new_vector("cs");
  {
# 364 "/Users/weugene/basilisk/src/heights.h"

    for (int i = 0; i < nboundary; i++)
      _attribute[cs.x.i].boundary[i] = _attribute[c.i].boundary[i];
# 364 "/Users/weugene/basilisk/src/heights.h"

    for (int i = 0; i < nboundary; i++)
      _attribute[cs.y.i].boundary[i] = _attribute[c.i].boundary[i];
# 364 "/Users/weugene/basilisk/src/heights.h"

    for (int i = 0; i < nboundary; i++)
      _attribute[cs.z.i].boundary[i] = _attribute[c.i].boundary[i];}





  restriction (((scalar []){c,{-1}}));
  for (int j = -1; j <= 1; j += 2) {





     { { if (0 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[0]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = 0; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 379 "/Users/weugene/basilisk/src/heights.h"

      {
# 380 "/Users/weugene/basilisk/src/heights.h"

        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.x.i)] = ((double)1e30);
# 380 "/Users/weugene/basilisk/src/heights.h"

        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)] = ((double)1e30);
# 380 "/Users/weugene/basilisk/src/heights.h"

        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)] = ((double)1e30);}; } } } }; }}; }

    for (int l = 1; l <= (grid->depth); l++) {




       { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 388 "/Users/weugene/basilisk/src/heights.h"

 {
# 389 "/Users/weugene/basilisk/src/heights.h"

   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cs.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+2*j][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)];
# 389 "/Users/weugene/basilisk/src/heights.h"

   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cs.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+2*j] [point.k+0]) + sizeof(Cell)))[(c.i)];
# 389 "/Users/weugene/basilisk/src/heights.h"

   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cs.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+2*j]) + sizeof(Cell)))[(c.i)];}; } } } }; }}; }
# 400 "/Users/weugene/basilisk/src/heights.h"
 { { if (l - 1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l - 1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = l - 1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 400 "/Users/weugene/basilisk/src/heights.h"

 {
# 401 "/Users/weugene/basilisk/src/heights.h"
 {
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cs.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)];
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+0]) + sizeof(Cell)))[(cs.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+2*j][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)];
        }
# 401 "/Users/weugene/basilisk/src/heights.h"
 {
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cs.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j] [point.k+0]) + sizeof(Cell)))[(c.i)];
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j] [point.k+0]) + sizeof(Cell)))[(cs.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+2*j] [point.k+0]) + sizeof(Cell)))[(c.i)];
        }
# 401 "/Users/weugene/basilisk/src/heights.h"
 {
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cs.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+j]) + sizeof(Cell)))[(c.i)];
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+j]) + sizeof(Cell)))[(cs.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+2*j]) + sizeof(Cell)))[(c.i)];
        }} } } } }; }}; }






       { { if (l - 1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _cache = ((Tree *)grid)->prolongation[l - 1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = l - 1; int _k; for (_k = 0; _k < _cache.n; _k++) { point.i = _cache.p[_k].i; point.j = _cache.p[_k].j; point.k = _cache.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 411 "/Users/weugene/basilisk/src/heights.h"

 {
# 412 "/Users/weugene/basilisk/src/heights.h"

   _attribute[c.i].prolongation (point, cs.x);
# 412 "/Users/weugene/basilisk/src/heights.h"

   _attribute[c.i].prolongation (point, cs.y);
# 412 "/Users/weugene/basilisk/src/heights.h"

   _attribute[c.i].prolongation (point, cs.z);}; } } } }; }}; }
      { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, (scalar *)((vector []){{cs.x,cs.y,cs.z},{{-1},{-1},{-1}}}), l); };





       { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 420 "/Users/weugene/basilisk/src/heights.h"

        half_column (point, c, h, cs, j); } } } }; }}; }
    }
  }






  {
# 430 "/Users/weugene/basilisk/src/heights.h"
 {
    _attribute[h.x.i].prolongation = no_data;
    _attribute[h.x.i].restriction = no_restriction;
  }
# 430 "/Users/weugene/basilisk/src/heights.h"
 {
    _attribute[h.y.i].prolongation = no_data;
    _attribute[h.y.i].restriction = no_restriction;
  }
# 430 "/Users/weugene/basilisk/src/heights.h"
 {
    _attribute[h.z.i].prolongation = no_data;
    _attribute[h.z.i].restriction = no_restriction;
  }}
  boundary ((scalar *)((vector []){{h.x,h.y,h.z},{{-1},{-1},{-1}}}));






  {
# 441 "/Users/weugene/basilisk/src/heights.h"

    _attribute[h.x.i].prolongation = refine_h_x;
# 441 "/Users/weugene/basilisk/src/heights.h"

    _attribute[h.y.i].prolongation = refine_h_y;
# 441 "/Users/weugene/basilisk/src/heights.h"

    _attribute[h.z.i].prolongation = refine_h_z;}




  column_propagation (h);
 delete (((scalar []){cs.x,cs.y,cs.z,{-1}})); ; }
# 67 "/Users/weugene/basilisk/src/curvature.h"
# 104 "/Users/weugene/basilisk/src/curvature.h"
# 104 "/Users/weugene/basilisk/src/curvature.h"

static double kappa_z (Point point, vector h)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 106 "/Users/weugene/basilisk/src/curvature.h"

  int ori = orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)]);
  for (int i = -1; i <= 1; i++)
    for (int j = -1; j <= 1; j++)
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]) + sizeof(Cell)))[(h.z.i)] == ((double)1e30) || orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]) + sizeof(Cell)))[(h.z.i)]) != ori)
 return ((double)1e30);
  double hx = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)])/2.;
  double hy = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(h.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(h.z.i)])/2.;







  double filter = 0.2;
  double hxx = (filter*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(h.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(h.z.i)] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(h.z.i)]) +
  (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)]) +
  filter*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(h.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(h.z.i)] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(h.z.i)]))/
    ((1. + 2.*filter)*Delta);
  double hyy = (filter*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(h.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(h.z.i)] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)]) +
  (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(h.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(h.z.i)] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)]) +
  filter*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(h.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(h.z.i)] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)]))/
    ((1. + 2.*filter)*Delta);
  double hxy = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(h.z.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(h.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1] [point.k+0]) + sizeof(Cell)))[(h.z.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1] [point.k+0]) + sizeof(Cell)))[(h.z.i)])/(4.*Delta);
  return (hxx*(1. + ((hy)*(hy))) + hyy*(1. + ((hx)*(hx))) - 2.*hxy*hx*hy)/
    pow(1. + ((hx)*(hx)) + ((hy)*(hy)), 3/2.);
}
# 104 "/Users/weugene/basilisk/src/curvature.h"

static double kappa_x (Point point, vector h)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 106 "/Users/weugene/basilisk/src/curvature.h"

  int ori = orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.x.i)]);
  for (int i = -1; i <= 1; i++)
    for (int j = -1; j <= 1; j++)
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j]) + sizeof(Cell)))[(h.x.i)] == ((double)1e30) || orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j]) + sizeof(Cell)))[(h.x.i)]) != ori)
 return ((double)1e30);
  double hx = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(h.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(h.x.i)])/2.;
  double hy = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(h.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(h.x.i)])/2.;







  double filter = 0.2;
  double hxx = (filter*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(h.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(h.x.i)] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(h.x.i)]) +
  (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(h.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(h.x.i)] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.x.i)]) +
  filter*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(h.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(h.x.i)] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(h.x.i)]))/
    ((1. + 2.*filter)*Delta);
  double hyy = (filter*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(h.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(h.x.i)] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(h.x.i)]) +
  (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(h.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(h.x.i)] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.x.i)]) +
  filter*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(h.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(h.x.i)] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(h.x.i)]))/
    ((1. + 2.*filter)*Delta);
  double hxy = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(h.x.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+-1]) + sizeof(Cell)))[(h.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+-1]) + sizeof(Cell)))[(h.x.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+1]) + sizeof(Cell)))[(h.x.i)])/(4.*Delta);
  return (hxx*(1. + ((hy)*(hy))) + hyy*(1. + ((hx)*(hx))) - 2.*hxy*hx*hy)/
    pow(1. + ((hx)*(hx)) + ((hy)*(hy)), 3/2.);
}
# 104 "/Users/weugene/basilisk/src/curvature.h"

static double kappa_y (Point point, vector h)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 106 "/Users/weugene/basilisk/src/curvature.h"

  int ori = orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)]);
  for (int i = -1; i <= 1; i++)
    for (int j = -1; j <= 1; j++)
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i]) + sizeof(Cell)))[(h.y.i)] == ((double)1e30) || orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i]) + sizeof(Cell)))[(h.y.i)]) != ori)
 return ((double)1e30);
  double hx = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(h.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(h.y.i)])/2.;
  double hy = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)])/2.;







  double filter = 0.2;
  double hxx = (filter*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(h.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(h.y.i)] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)]) +
  (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(h.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(h.y.i)] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)]) +
  filter*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(h.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(h.y.i)] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)]))/
    ((1. + 2.*filter)*Delta);
  double hyy = (filter*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(h.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(h.y.i)] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(h.y.i)]) +
  (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)]) +
  filter*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(h.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(h.y.i)] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(h.y.i)]))/
    ((1. + 2.*filter)*Delta);
  double hxy = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(h.y.i)] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(h.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+1]) + sizeof(Cell)))[(h.y.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+-1]) + sizeof(Cell)))[(h.y.i)])/(4.*Delta);
  return (hxx*(1. + ((hy)*(hy))) + hyy*(1. + ((hx)*(hx))) - 2.*hxy*hx*hy)/
    pow(1. + ((hx)*(hx)) + ((hy)*(hy)), 3/2.);
}
# 135 "/Users/weugene/basilisk/src/curvature.h"

static coord normal2_z (Point point, vector h)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 137 "/Users/weugene/basilisk/src/curvature.h"

  scalar hz = h.z;
  if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)] == ((double)1e30))
    return (coord){((double)1e30), ((double)1e30), ((double)1e30)};
  int ori = orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)]);
  double a = ori ? -1. : 1.;
  coord n;
  n.z = a;
  {
# 145 "/Users/weugene/basilisk/src/curvature.h"
 {
    if ((point.i+-1 >= 0 && point.i+-1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+-1] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)] != ((double)1e30) && orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)]) == ori) {
      if ((point.i+1 >= 0 && point.i+1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+1] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)] != ((double)1e30) && orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)]) == ori)
 n.x = a*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)])/2.;
      else
 n.x = a*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)]);
    }
    else if ((point.i+1 >= 0 && point.i+1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+1] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)] != ((double)1e30) && orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)]) == ori)
      n.x = a*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)]);
    else
      n.x = ((double)1e30);
  }
# 145 "/Users/weugene/basilisk/src/curvature.h"
 {
    if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+-1 >= 0 && point.j+-1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(hz.i)] != ((double)1e30) && orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(hz.i)]) == ori) {
      if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+1 >= 0 && point.j+1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(hz.i)] != ((double)1e30) && orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(hz.i)]) == ori)
 n.y = a*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(hz.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(hz.i)])/2.;
      else
 n.y = a*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(hz.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)]);
    }
    else if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+1 >= 0 && point.j+1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(hz.i)] != ((double)1e30) && orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(hz.i)]) == ori)
      n.y = a*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(hz.i)]);
    else
      n.y = ((double)1e30);
  }}
  return n;
}
# 135 "/Users/weugene/basilisk/src/curvature.h"

static coord normal2_x (Point point, vector h)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 137 "/Users/weugene/basilisk/src/curvature.h"

  scalar hz = h.x;
  if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)] == ((double)1e30))
    return (coord){((double)1e30), ((double)1e30), ((double)1e30)};
  int ori = orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)]);
  double a = ori ? -1. : 1.;
  coord n;
  n.x = a;
  {
# 145 "/Users/weugene/basilisk/src/curvature.h"
 {
    if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+-1 >= 0 && point.j+-1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(hz.i)] != ((double)1e30) && orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(hz.i)]) == ori) {
      if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+1 >= 0 && point.j+1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(hz.i)] != ((double)1e30) && orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(hz.i)]) == ori)
 n.y = a*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(hz.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(hz.i)])/2.;
      else
 n.y = a*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(hz.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)]);
    }
    else if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+1 >= 0 && point.j+1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(hz.i)] != ((double)1e30) && orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(hz.i)]) == ori)
      n.y = a*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(hz.i)]);
    else
      n.y = ((double)1e30);
  }
# 145 "/Users/weugene/basilisk/src/curvature.h"
 {
    if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+-1 >= 0 && point.k+-1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(hz.i)] != ((double)1e30) && orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(hz.i)]) == ori) {
      if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+1 >= 0 && point.k+1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(hz.i)] != ((double)1e30) && orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(hz.i)]) == ori)
 n.z = a*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(hz.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(hz.i)])/2.;
      else
 n.z = a*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(hz.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)]);
    }
    else if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+1 >= 0 && point.k+1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(hz.i)] != ((double)1e30) && orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(hz.i)]) == ori)
      n.z = a*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(hz.i)]);
    else
      n.z = ((double)1e30);
  }}
  return n;
}
# 135 "/Users/weugene/basilisk/src/curvature.h"

static coord normal2_y (Point point, vector h)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 137 "/Users/weugene/basilisk/src/curvature.h"

  scalar hz = h.y;
  if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)] == ((double)1e30))
    return (coord){((double)1e30), ((double)1e30), ((double)1e30)};
  int ori = orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)]);
  double a = ori ? -1. : 1.;
  coord n;
  n.y = a;
  {
# 145 "/Users/weugene/basilisk/src/curvature.h"
 {
    if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+-1 >= 0 && point.k+-1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(hz.i)] != ((double)1e30) && orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(hz.i)]) == ori) {
      if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+1 >= 0 && point.k+1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(hz.i)] != ((double)1e30) && orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(hz.i)]) == ori)
 n.z = a*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(hz.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(hz.i)])/2.;
      else
 n.z = a*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(hz.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)]);
    }
    else if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+1 >= 0 && point.k+1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(hz.i)] != ((double)1e30) && orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(hz.i)]) == ori)
      n.z = a*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(hz.i)]);
    else
      n.z = ((double)1e30);
  }
# 145 "/Users/weugene/basilisk/src/curvature.h"
 {
    if ((point.i+-1 >= 0 && point.i+-1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+-1] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)] != ((double)1e30) && orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)]) == ori) {
      if ((point.i+1 >= 0 && point.i+1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+1] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)] != ((double)1e30) && orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)]) == ori)
 n.x = a*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)])/2.;
      else
 n.x = a*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)]);
    }
    else if ((point.i+1 >= 0 && point.i+1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+1] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)] != ((double)1e30) && orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)]) == ori)
      n.x = a*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(hz.i)]);
    else
      n.x = ((double)1e30);
  }}
  return n;
}
# 160 "/Users/weugene/basilisk/src/curvature.h"

static coord normal_z (Point point, vector h) { int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 161 "/Users/weugene/basilisk/src/curvature.h"

  coord n = normal2_z (point, h);
  double nn = fabs(n.x) + fabs(n.y) + fabs(n.z);
  if (nn < ((double)1e30)) {
    {
# 165 "/Users/weugene/basilisk/src/curvature.h"

      n.x /= nn;
# 165 "/Users/weugene/basilisk/src/curvature.h"

      n.y /= nn;
# 165 "/Users/weugene/basilisk/src/curvature.h"

      n.z /= nn;}
    return n;
  }
  return (coord){((double)1e30), ((double)1e30), ((double)1e30)};
}
# 160 "/Users/weugene/basilisk/src/curvature.h"

static coord normal_x (Point point, vector h) { int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 161 "/Users/weugene/basilisk/src/curvature.h"

  coord n = normal2_x (point, h);
  double nn = fabs(n.y) + fabs(n.z) + fabs(n.x);
  if (nn < ((double)1e30)) {
    {
# 165 "/Users/weugene/basilisk/src/curvature.h"

      n.y /= nn;
# 165 "/Users/weugene/basilisk/src/curvature.h"

      n.z /= nn;
# 165 "/Users/weugene/basilisk/src/curvature.h"

      n.x /= nn;}
    return n;
  }
  return (coord){((double)1e30), ((double)1e30), ((double)1e30)};
}
# 160 "/Users/weugene/basilisk/src/curvature.h"

static coord normal_y (Point point, vector h) { int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 161 "/Users/weugene/basilisk/src/curvature.h"

  coord n = normal2_y (point, h);
  double nn = fabs(n.z) + fabs(n.x) + fabs(n.y);
  if (nn < ((double)1e30)) {
    {
# 165 "/Users/weugene/basilisk/src/curvature.h"

      n.z /= nn;
# 165 "/Users/weugene/basilisk/src/curvature.h"

      n.x /= nn;
# 165 "/Users/weugene/basilisk/src/curvature.h"

      n.y /= nn;}
    return n;
  }
  return (coord){((double)1e30), ((double)1e30), ((double)1e30)};
}
# 179 "/Users/weugene/basilisk/src/curvature.h"
static double height_curvature (Point point, scalar c, vector h)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 180 "/Users/weugene/basilisk/src/curvature.h"







  typedef struct {
    double n;
    double (* kappa) (Point, vector);
  } NormKappa;
  struct { NormKappa x, y, z; } n;
  {
# 192 "/Users/weugene/basilisk/src/curvature.h"

    n.x.n = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)], n.x.kappa = kappa_x;
# 192 "/Users/weugene/basilisk/src/curvature.h"

    n.y.n = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(c.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)], n.y.kappa = kappa_y;
# 192 "/Users/weugene/basilisk/src/curvature.h"

    n.z.n = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(c.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)], n.z.kappa = kappa_z;}
  double (* kappaf) (Point, vector) = ((void*)0); (void)(kappaf);




  if (fabs(n.x.n) < fabs(n.y.n))
    { NormKappa tmp = n.x; n.x = n.y; n.y = tmp; };

  if (fabs(n.x.n) < fabs(n.z.n))
    { NormKappa tmp = n.x; n.x = n.z; n.z = tmp; };
  if (fabs(n.y.n) < fabs(n.z.n))
    { NormKappa tmp = n.y; n.y = n.z; n.z = tmp; };





  double kappa = ((double)1e30);
  {
# 212 "/Users/weugene/basilisk/src/curvature.h"

    if (kappa == ((double)1e30)) {
      kappa = n.x.kappa (point, h);
      if (kappa != ((double)1e30)) {
 kappaf = n.x.kappa;
 if (n.x.n < 0.)
   kappa = - kappa;
      }
    }
# 212 "/Users/weugene/basilisk/src/curvature.h"

    if (kappa == ((double)1e30)) {
      kappa = n.y.kappa (point, h);
      if (kappa != ((double)1e30)) {
 kappaf = n.y.kappa;
 if (n.y.n < 0.)
   kappa = - kappa;
      }
    }
# 212 "/Users/weugene/basilisk/src/curvature.h"

    if (kappa == ((double)1e30)) {
      kappa = n.z.kappa (point, h);
      if (kappa != ((double)1e30)) {
 kappaf = n.z.kappa;
 if (n.z.n < 0.)
   kappa = - kappa;
      }
    }}

  if (kappa != ((double)1e30)) {




    if (fabs(kappa) > 1./Delta)
      kappa = ((kappa) > 0 ? 1 : -1)/Delta;
# 247 "/Users/weugene/basilisk/src/curvature.h"
 }

  return kappa;
}






coord height_normal (Point point, scalar c, vector h)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 258 "/Users/weugene/basilisk/src/curvature.h"







  typedef struct {
    double n;
    coord (* normal) (Point, vector);
  } NormNormal;
  struct { NormNormal x, y, z; } n;
  {
# 270 "/Users/weugene/basilisk/src/curvature.h"

    n.x.n = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)], n.x.normal = normal_x;
# 270 "/Users/weugene/basilisk/src/curvature.h"

    n.y.n = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(c.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(c.i)], n.y.normal = normal_y;
# 270 "/Users/weugene/basilisk/src/curvature.h"

    n.z.n = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(c.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(c.i)], n.z.normal = normal_z;}




  if (fabs(n.x.n) < fabs(n.y.n))
    { NormNormal tmp = n.x; n.x = n.y; n.y = tmp; };

  if (fabs(n.x.n) < fabs(n.z.n))
    { NormNormal tmp = n.x; n.x = n.z; n.z = tmp; };
  if (fabs(n.y.n) < fabs(n.z.n))
    { NormNormal tmp = n.y; n.y = n.z; n.z = tmp; };





  coord normal = {((double)1e30), ((double)1e30), ((double)1e30)};
  {
# 289 "/Users/weugene/basilisk/src/curvature.h"

    if (normal.x == ((double)1e30))
      normal = n.x.normal (point, h);
# 289 "/Users/weugene/basilisk/src/curvature.h"

    if (normal.y == ((double)1e30))
      normal = n.y.normal (point, h);
# 289 "/Users/weugene/basilisk/src/curvature.h"

    if (normal.z == ((double)1e30))
      normal = n.z.normal (point, h);}

  return normal;
}
# 301 "/Users/weugene/basilisk/src/curvature.h"

coord height_normal_z (Point point, vector h)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 303 "/Users/weugene/basilisk/src/curvature.h"

  coord nx = normal2_x (point, h);
  coord ny = normal2_y (point, h);
  if (fabs(nx.y) < fabs(ny.x)) {
    normalize (&nx);
    return nx;
  }
  else if (ny.x != ((double)1e30)) {
    normalize (&ny);
    return ny;
  }
  return (coord){((double)1e30), ((double)1e30), ((double)1e30)};
}
# 301 "/Users/weugene/basilisk/src/curvature.h"

coord height_normal_x (Point point, vector h)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 303 "/Users/weugene/basilisk/src/curvature.h"

  coord nx = normal2_y (point, h);
  coord ny = normal2_z (point, h);
  if (fabs(nx.z) < fabs(ny.y)) {
    normalize (&nx);
    return nx;
  }
  else if (ny.y != ((double)1e30)) {
    normalize (&ny);
    return ny;
  }
  return (coord){((double)1e30), ((double)1e30), ((double)1e30)};
}
# 301 "/Users/weugene/basilisk/src/curvature.h"

coord height_normal_y (Point point, vector h)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 303 "/Users/weugene/basilisk/src/curvature.h"

  coord nx = normal2_z (point, h);
  coord ny = normal2_x (point, h);
  if (fabs(nx.x) < fabs(ny.z)) {
    normalize (&nx);
    return nx;
  }
  else if (ny.z != ((double)1e30)) {
    normalize (&ny);
    return ny;
  }
  return (coord){((double)1e30), ((double)1e30), ((double)1e30)};
}
# 330 "/Users/weugene/basilisk/src/curvature.h"
# 1 "./parabola.h"
# 1 "/Users/weugene/basilisk/src/parabola.h"







typedef struct {
  coord o;




  double t[3][3];



  double ** M, rhs[6], a[6];


} ParabolaFit;

static void parabola_fit_init (ParabolaFit * p, coord o, coord m)
{
  {
# 25 "/Users/weugene/basilisk/src/parabola.h"

    p->o.x = o.x;
# 25 "/Users/weugene/basilisk/src/parabola.h"

    p->o.y = o.y;
# 25 "/Users/weugene/basilisk/src/parabola.h"

    p->o.z = o.z;}






  double max;
  coord nx = {0., 0., 0.}, ny, nz;
  int d = 0;

  {
# 37 "/Users/weugene/basilisk/src/parabola.h"

    nz.x = m.x;
# 37 "/Users/weugene/basilisk/src/parabola.h"

    nz.y = m.y;
# 37 "/Users/weugene/basilisk/src/parabola.h"

    nz.z = m.z;}
  normalize (&nz);
  max = ((nz.x)*(nz.x));

  if (((nz.y)*(nz.y)) > max) { max = ((nz.y)*(nz.y)); d = 1; }
  if (((nz.z)*(nz.z)) > max) d = 2;
  switch (d) {
  case 0: nx.x = - nz.z/nz.x; nx.z = 1.0; break;
  case 1: nx.y = - nz.z/nz.y; nx.z = 1.0; break;
  case 2: nx.z = - nz.x/nz.z; nx.x = 1.0; break;
  }
  normalize (&nx);


  {
# 52 "/Users/weugene/basilisk/src/parabola.h"

    ny.x = nz.y*nx.z - nz.z*nx.y;
# 52 "/Users/weugene/basilisk/src/parabola.h"

    ny.y = nz.z*nx.x - nz.x*nx.z;
# 52 "/Users/weugene/basilisk/src/parabola.h"

    ny.z = nz.x*nx.y - nz.y*nx.x;}


  p->t[0][0] = nx.x; p->t[0][1] = nx.y; p->t[0][2] = nx.z;
  p->t[1][0] = ny.x; p->t[1][1] = ny.y; p->t[1][2] = ny.z;
  p->t[2][0] = nz.x; p->t[2][1] = nz.y; p->t[2][2] = nz.z;



  int n = 6;


  p->M = (double **) matrix_new (n, n, sizeof(double));
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++)
      p->M[i][j] = 0.;
    p->rhs[i] = 0.;
  }
}

static void parabola_fit_add (ParabolaFit * p, coord m, double w)
{
# 85 "/Users/weugene/basilisk/src/parabola.h"
 double x1 = m.x - p->o.x, y1 = m.y - p->o.y, z1 = m.z - p->o.z;
  double x = p->t[0][0]*x1 + p->t[0][1]*y1 + p->t[0][2]*z1;
  double y = p->t[1][0]*x1 + p->t[1][1]*y1 + p->t[1][2]*z1;
  double z = p->t[2][0]*x1 + p->t[2][1]*y1 + p->t[2][2]*z1;
# 98 "/Users/weugene/basilisk/src/parabola.h"
 double x2 = x*x, x3 = x2*x, x4 = x3*x;
  double y2 = y*y, y3 = y2*y, y4 = y3*y;
  p->M[0][0] += w*x4; p->M[1][1] += w*y4; p->M[2][2] += w*x2*y2;
  p->M[3][3] += w*x2; p->M[4][4] += w*y2; p->M[5][5] += w;
  p->M[0][2] += w*x3*y; p->M[0][3] += w*x3; p->M[0][4] += w*x2*y;
  p->M[1][2] += w*x*y3; p->M[1][3] += w*x*y2; p->M[1][4] += w*y3;
  p->M[2][5] += w*x*y;
  p->M[3][5] += w*x;
  p->M[4][5] += w*y;
  p->rhs[0] += w*x2*z; p->rhs[1] += w*y2*z; p->rhs[2] += w*x*y*z;
  p->rhs[3] += w*x*z; p->rhs[4] += w*y*z; p->rhs[5] += w*z;


}

static double parabola_fit_solve (ParabolaFit * p)
{
# 139 "/Users/weugene/basilisk/src/parabola.h"
 p->M[0][1] = p->M[2][2]; p->M[0][5] = p->M[3][3];
  p->M[1][5] = p->M[4][4];
  p->M[2][3] = p->M[0][4]; p->M[2][4] = p->M[1][3];
  p->M[3][4] = p->M[2][5];
  for (int i = 1; i < 6; i++)
    for (int j = 0; j < i; j++)
      p->M[i][j] = p->M[j][i];
  double pivmin = matrix_inverse (p->M, 6, 1e-10);
  if (pivmin)
    for (int i = 0; i < 6; i++) {
      p->a[i] = 0.;
      for (int j = 0; j < 6; j++)
 p->a[i] += p->M[i][j]*p->rhs[j];
    }
  else
    for (int i = 0; i < 6; i++)
      p->a[i] = 0.;


  matrix_free (p->M);
  return pivmin;
}

static double parabola_fit_curvature (ParabolaFit * p,
          double kappamax, double * kmax)
{
  double kappa;
# 176 "/Users/weugene/basilisk/src/parabola.h"
 double hxx = 2.*p->a[0], hyy = 2.*p->a[1], hxy = p->a[2];
  double hx = p->a[3], hy = p->a[4];

  double dnm = 1. + ((hx)*(hx)) + ((hy)*(hy));
  kappa = - (hxx*(1. + ((hy)*(hy))) + hyy*(1. + ((hx)*(hx))) - 2.*hxy*hx*hy)
    /sqrt (dnm*dnm*dnm);
  if (kmax) {
    double kg = (hxx*hyy - hxy*hxy)/(dnm*dnm);
    double a = kappa*kappa/4. - kg;
    *kmax = fabs (kappa/2.);
    if (a >= 0.)
      *kmax += sqrt (a);
  }

  if (fabs (kappa) > kappamax) {
    if (kmax)
      *kmax = kappamax;
    return kappa > 0. ? kappamax : - kappamax;
  }
  return kappa;
}
# 331 "/Users/weugene/basilisk/src/curvature.h"






static int independents (coord * p, int n)
{
  if (n < 2)
    return n;
  int ni = 1;
  for (int j = 1; j < n; j++) {
    _Bool depends = 0;
    for (int i = 0; i < j && !depends; i++) {
      double d2 = 0.;
      {
# 346 "/Users/weugene/basilisk/src/curvature.h"

 d2 += ((p[i].x - p[j].x)*(p[i].x - p[j].x));
# 346 "/Users/weugene/basilisk/src/curvature.h"

 d2 += ((p[i].y - p[j].y)*(p[i].y - p[j].y));
# 346 "/Users/weugene/basilisk/src/curvature.h"

 d2 += ((p[i].z - p[j].z)*(p[i].z - p[j].z));}
      depends = (d2 < ((0.5)*(0.5)));
    }
    ni += !depends;
  }
  return ni;
}






static double height_curvature_fit (Point point, scalar c, vector h)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 361 "/Users/weugene/basilisk/src/curvature.h"






  coord ip[3 == 2 ? 6 : 27];
  int n = 0;




  {
# 373 "/Users/weugene/basilisk/src/curvature.h"
 {





    int n1 = 0, n2 = 0;






    for (int i = -1; i <= 1; i++)
      for (int j = -1; j <= 1; j++)
 if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]) + sizeof(Cell)))[(h.z.i)] != ((double)1e30)) {
   if (orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]) + sizeof(Cell)))[(h.z.i)])) n1++; else n2++;
 }

    int ori = (n1 > n2);
# 404 "/Users/weugene/basilisk/src/curvature.h"
 for (int i = -1; i <= 1; i++)
      for (int j = -1; j <= 1; j++)
 if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]) + sizeof(Cell)))[(h.z.i)] != ((double)1e30) && orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]) + sizeof(Cell)))[(h.z.i)]) == ori)
   ip[n].x = i, ip[n].y = j, ip[n++].z = height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j] [point.k+0]) + sizeof(Cell)))[(h.z.i)]);

  }
# 373 "/Users/weugene/basilisk/src/curvature.h"
 {





    int n1 = 0, n2 = 0;






    for (int i = -1; i <= 1; i++)
      for (int j = -1; j <= 1; j++)
 if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j]) + sizeof(Cell)))[(h.x.i)] != ((double)1e30)) {
   if (orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j]) + sizeof(Cell)))[(h.x.i)])) n1++; else n2++;
 }

    int ori = (n1 > n2);
# 404 "/Users/weugene/basilisk/src/curvature.h"
 for (int i = -1; i <= 1; i++)
      for (int j = -1; j <= 1; j++)
 if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j]) + sizeof(Cell)))[(h.x.i)] != ((double)1e30) && orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j]) + sizeof(Cell)))[(h.x.i)]) == ori)
   ip[n].y = i, ip[n].z = j, ip[n++].x = height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+j]) + sizeof(Cell)))[(h.x.i)]);

  }
# 373 "/Users/weugene/basilisk/src/curvature.h"
 {





    int n1 = 0, n2 = 0;






    for (int i = -1; i <= 1; i++)
      for (int j = -1; j <= 1; j++)
 if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i]) + sizeof(Cell)))[(h.y.i)] != ((double)1e30)) {
   if (orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i]) + sizeof(Cell)))[(h.y.i)])) n1++; else n2++;
 }

    int ori = (n1 > n2);
# 404 "/Users/weugene/basilisk/src/curvature.h"
 for (int i = -1; i <= 1; i++)
      for (int j = -1; j <= 1; j++)
 if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i]) + sizeof(Cell)))[(h.y.i)] != ((double)1e30) && orientation(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i]) + sizeof(Cell)))[(h.y.i)]) == ori)
   ip[n].z = i, ip[n].x = j, ip[n++].y = height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0] [point.k+i]) + sizeof(Cell)))[(h.y.i)]);

  }}





  if (independents (ip, n) < (3 == 2 ? 3 : 9))
    return ((double)1e30);





  coord m = mycs (point, c), fc;
  double alpha = plane_alpha (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)], m);
  double area = plane_area_center (m, alpha, &fc);
  ParabolaFit fit;
  parabola_fit_init (&fit, fc, m);




  parabola_fit_add (&fit, fc, area*100.);






  for (int i = 0; i < n; i++)
    parabola_fit_add (&fit, ip[i], 1.);
  parabola_fit_solve (&fit);
  double kappa = parabola_fit_curvature (&fit, 2., ((void*)0))/Delta;



  return kappa;
}






static double centroids_curvature_fit (Point point, scalar c)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 454 "/Users/weugene/basilisk/src/curvature.h"






  coord m = mycs (point, c), fc;
  double alpha = plane_alpha (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)], m);
  plane_area_center (m, alpha, &fc);
  ParabolaFit fit;
  parabola_fit_init (&fit, fc, m);





  coord r = {x,y,z};
   { { int _nn = 1 + 0 ? 1 + 0 : 2; int _i = point.i, _j = point.j, _k = point.k; for (int _l = - _nn; _l <= _nn; _l++) { point.i = _i + _l; for (int _m = - _nn; _m <= _nn; _m++) { point.j = _j + _m; for (int _n = - _nn; _n <= _nn; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] > 0. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] < 1.) {
      coord m = mycs (point, c), fc;
      double alpha = plane_alpha (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)], m);
      double area = plane_area_center (m, alpha, &fc);
      coord rn = {x,y,z};
      {
# 477 "/Users/weugene/basilisk/src/curvature.h"

 fc.x += (rn.x - r.x)/Delta;
# 477 "/Users/weugene/basilisk/src/curvature.h"

 fc.y += (rn.y - r.y)/Delta;
# 477 "/Users/weugene/basilisk/src/curvature.h"

 fc.z += (rn.z - r.z)/Delta;}
      parabola_fit_add (&fit, fc, area);
    } } } } point.i = _i; point.j = _j; point.k = _k;}; }
  parabola_fit_solve (&fit);
  double kappa = parabola_fit_curvature (&fit, 2., ((void*)0))/Delta;



  return kappa;
}
# 500 "/Users/weugene/basilisk/src/curvature.h"
static inline _Bool interfacial (Point point, scalar c)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 501 "/Users/weugene/basilisk/src/curvature.h"

  if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] >= 1.) {
    for (int i = -1; i <= 1; i += 2)
      {
# 504 "/Users/weugene/basilisk/src/curvature.h"

 if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] <= 0.)
   return 1;
# 504 "/Users/weugene/basilisk/src/curvature.h"

 if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(c.i)] <= 0.)
   return 1;
# 504 "/Users/weugene/basilisk/src/curvature.h"

 if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(c.i)] <= 0.)
   return 1;}
  }
  else if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] <= 0.) {
    for (int i = -1; i <= 1; i += 2)
      {
# 510 "/Users/weugene/basilisk/src/curvature.h"

 if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0] [point.k+0]) + sizeof(Cell)))[(c.i)] >= 1.)
   return 1;
# 510 "/Users/weugene/basilisk/src/curvature.h"

 if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i] [point.k+0]) + sizeof(Cell)))[(c.i)] >= 1.)
   return 1;
# 510 "/Users/weugene/basilisk/src/curvature.h"

 if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+i]) + sizeof(Cell)))[(c.i)] >= 1.)
   return 1;}
  }
  else
    return 1;
  return 0;
}
# 530 "/Users/weugene/basilisk/src/curvature.h"
typedef struct {
  int h;
  int f;
  int a;
  int c;
} cstats;

struct Curvature {
  scalar c, kappa;
  double sigma;
  _Bool add;
};


cstats curvature (struct Curvature p)
{ ;
  scalar c = p.c, kappa = p.kappa;
  double sigma = p.sigma ? p.sigma : 1.;
  int sh = 0, sf = 0, sa = 0, sc = 0;
  vector ch = _attribute[c.i].height, h = (ch).x.i ? (ch) : new_vector("h");
  if (!ch.x.i)
    heights (c, h);






  _attribute[kappa.i].refine = _attribute[kappa.i].prolongation = curvature_prolongation;
  _attribute[kappa.i].restriction = curvature_restriction;






  scalar k= new_scalar("k");
  scalar_clone (k, kappa);

   {


                  {
double _sh = sh; double _sf = sf;
# 569 "/Users/weugene/basilisk/src/curvature.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 569 "/Users/weugene/basilisk/src/curvature.h"
 {




    if (!interfacial (point, c))
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(k.i)] = ((double)1e30);





    else if ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(k.i)] = height_curvature (point, c, h)) != ((double)1e30))
      _sh++;
    else if ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(k.i)] = height_curvature_fit (point, c, h)) != ((double)1e30))
      _sf++;
  } } } } }; sh += _sh;
                                   ;
                  sf += _sf;
                                   ;



}
# 585 "/Users/weugene/basilisk/src/curvature.h"
 }
  boundary (((scalar []){k,{-1}}));

   {


                  {
double _sa = sa; double _sc = sc;
# 588 "/Users/weugene/basilisk/src/curvature.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 588 "/Users/weugene/basilisk/src/curvature.h"
 {





    double kf;
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(k.i)] < ((double)1e30))
      kf = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(k.i)];
    else if (interfacial (point, c)) {





      double sk = 0., a = 0.;
       { { int _nn = 1 + 0 ? 1 + 0 : 2; int _i = point.i, _j = point.j, _k = point.k; for (int _l = - _nn; _l <= _nn; _l++) { point.i = _i + _l; for (int _m = - _nn; _m <= _nn; _m++) { point.j = _j + _m; for (int _n = - _nn; _n <= _nn; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
 if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(k.i)] < ((double)1e30))
   sk += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(k.i)], a++; } } } point.i = _i; point.j = _j; point.k = _k;}; }
      if (a > 0.)
 kf = sk/a, _sa++;
      else




 kf = centroids_curvature_fit (point, c), _sc++;
    }
    else
      kf = ((double)1e30);




    if (kf == ((double)1e30))
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(kappa.i)] = ((double)1e30);
    else if (p.add)
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(kappa.i)] += sigma*kf;
    else
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(kappa.i)] = sigma*kf;
  } } } } }; sa += _sa;
                                   ;
                  sc += _sc;
                                   ;



}
# 628 "/Users/weugene/basilisk/src/curvature.h"
 }
  boundary (((scalar []){kappa,{-1}}));

  { cstats _ret = (cstats){sh, sf, sa, sc}; delete (((scalar []){k,{-1}})); { if (!(ch).x.i) delete (((scalar []){h.x,h.y,h.z,{-1}})); } ; return _ret; }
 delete (((scalar []){k,{-1}})); { if (!(ch).x.i) delete (((scalar []){h.x,h.y,h.z,{-1}})); } ; }
# 651 "/Users/weugene/basilisk/src/curvature.h"
# 651 "/Users/weugene/basilisk/src/curvature.h"

static double pos_x (Point point, vector h, coord * G, coord * Z)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 653 "/Users/weugene/basilisk/src/curvature.h"

  if (fabs(height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.x.i)])) > 1.)
    return ((double)1e30);
  coord o = {x, y, z};
  o.x += height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.x.i)])*Delta;
  double pos = 0.;
  {
# 659 "/Users/weugene/basilisk/src/curvature.h"

    pos += (o.x - Z->x)*G->x;
# 659 "/Users/weugene/basilisk/src/curvature.h"

    pos += (o.y - Z->y)*G->y;
# 659 "/Users/weugene/basilisk/src/curvature.h"

    pos += (o.z - Z->z)*G->z;}
  return pos;
}
# 651 "/Users/weugene/basilisk/src/curvature.h"

static double pos_y (Point point, vector h, coord * G, coord * Z)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 653 "/Users/weugene/basilisk/src/curvature.h"

  if (fabs(height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)])) > 1.)
    return ((double)1e30);
  coord o = {x, y, z};
  o.y += height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.y.i)])*Delta;
  double pos = 0.;
  {
# 659 "/Users/weugene/basilisk/src/curvature.h"

    pos += (o.y - Z->y)*G->y;
# 659 "/Users/weugene/basilisk/src/curvature.h"

    pos += (o.z - Z->z)*G->z;
# 659 "/Users/weugene/basilisk/src/curvature.h"

    pos += (o.x - Z->x)*G->x;}
  return pos;
}
# 651 "/Users/weugene/basilisk/src/curvature.h"

static double pos_z (Point point, vector h, coord * G, coord * Z)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 653 "/Users/weugene/basilisk/src/curvature.h"

  if (fabs(height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)])) > 1.)
    return ((double)1e30);
  coord o = {x, y, z};
  o.z += height(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(h.z.i)])*Delta;
  double pos = 0.;
  {
# 659 "/Users/weugene/basilisk/src/curvature.h"

    pos += (o.z - Z->z)*G->z;
# 659 "/Users/weugene/basilisk/src/curvature.h"

    pos += (o.x - Z->x)*G->x;
# 659 "/Users/weugene/basilisk/src/curvature.h"

    pos += (o.y - Z->y)*G->y;}
  return pos;
}







static double height_position (Point point, scalar f, vector h,
          coord * G, coord * Z)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 672 "/Users/weugene/basilisk/src/curvature.h"







  typedef struct {
    double n;
    double (* pos) (Point, vector, coord *, coord *);
  } NormPos;
  struct { NormPos x, y, z; } n;
  {
# 684 "/Users/weugene/basilisk/src/curvature.h"

    n.x.n = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)], n.x.pos = pos_x;
# 684 "/Users/weugene/basilisk/src/curvature.h"

    n.y.n = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(f.i)], n.y.pos = pos_y;
# 684 "/Users/weugene/basilisk/src/curvature.h"

    n.z.n = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(f.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(f.i)], n.z.pos = pos_z;}




  if (fabs(n.x.n) < fabs(n.y.n))
    { NormPos tmp = n.x; n.x = n.y; n.y = tmp; };

  if (fabs(n.x.n) < fabs(n.z.n))
    { NormPos tmp = n.x; n.x = n.z; n.z = tmp; };
  if (fabs(n.y.n) < fabs(n.z.n))
    { NormPos tmp = n.y; n.y = n.z; n.z = tmp; };





  double pos = ((double)1e30);
  {
# 703 "/Users/weugene/basilisk/src/curvature.h"

    if (pos == ((double)1e30))
      pos = n.x.pos (point, h, G, Z);
# 703 "/Users/weugene/basilisk/src/curvature.h"

    if (pos == ((double)1e30))
      pos = n.y.pos (point, h, G, Z);
# 703 "/Users/weugene/basilisk/src/curvature.h"

    if (pos == ((double)1e30))
      pos = n.z.pos (point, h, G, Z);}

  return pos;
}
# 719 "/Users/weugene/basilisk/src/curvature.h"
struct Position {
  scalar f, pos;
  coord G, Z;
  _Bool add;
};

void position (struct Position p)
{
  scalar f = p.f, pos = p.pos;
  coord * G = &p.G, * Z = &p.Z;






  _attribute[pos.i].refine = _attribute[pos.i].prolongation = curvature_prolongation;
  _attribute[pos.i].restriction = curvature_restriction;


  vector fh = _attribute[f.i].height, h = (fh).x.i ? (fh) : new_vector("h");
  if (!fh.x.i)
    heights (f, h);
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 742 "/Users/weugene/basilisk/src/curvature.h"
 {
    if (interfacial (point, f)) {
      double hp = height_position (point, f, h, G, Z);
      if (hp == ((double)1e30)) {





 coord n = mycs (point, f), o = {x,y,z}, c;
 double alpha = plane_alpha (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)], n);
 plane_area_center (n, alpha, &c);
 hp = 0.;
 {
# 755 "/Users/weugene/basilisk/src/curvature.h"

   hp += (o.x + Delta*c.x - Z->x)*G->x;
# 755 "/Users/weugene/basilisk/src/curvature.h"

   hp += (o.y + Delta*c.y - Z->y)*G->y;
# 755 "/Users/weugene/basilisk/src/curvature.h"

   hp += (o.z + Delta*c.z - Z->z)*G->z;}
      }
      if (p.add)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(pos.i)] += hp;
      else
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(pos.i)] = hp;
    }
    else
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(pos.i)] = ((double)1e30);
  } } } } }; }
  boundary (((scalar []){pos,{-1}}));
 { if (!(fh).x.i) delete (((scalar []){h.x,h.y,h.z,{-1}})); } }
# 17 "/Users/weugene/basilisk/src/tension.h"
# 37 "/Users/weugene/basilisk/src/tension.h"
_Bool resolve_capillary_effects = 1;
static int stability_1_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int stability_1 (const int i, const double t, Event * _ev) { ; {
  if (resolve_capillary_effects){




  double amin = ((double)1e30), amax = -((double)1e30), dmin = ((double)1e30);
   {


                  {
double _amin = amin; double _amax = amax; double _dmin = dmin;
# 45 "/Users/weugene/basilisk/src/tension.h"

if (!((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 45 "/Users/weugene/basilisk/src/tension.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 45 "/Users/weugene/basilisk/src/tension.h"
{
# 45 "/Users/weugene/basilisk/src/tension.h"
 {
    fprintf(__stderrp, "%g %g %g %g xyzxz: %g %g %g\n", ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)], _amin, _amax, x, y, z);
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)] > _amax) _amax = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)];
      fprintf(__stderrp, "1\n");
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)] < _amin) _amin = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)];
      fprintf(__stderrp, "2\n");
    if (Delta < _dmin) _dmin = Delta;
      fprintf(__stderrp, "3\n");
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 45 "/Users/weugene/basilisk/src/tension.h"
{
# 45 "/Users/weugene/basilisk/src/tension.h"
 {
    fprintf(__stderrp, "%g %g %g %g xyzxz: %g %g %g\n", ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)], _amin, _amax, x, y, z);
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)] > _amax) _amax = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)];
      fprintf(__stderrp, "1\n");
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)] < _amin) _amin = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)];
      fprintf(__stderrp, "2\n");
    if (Delta < _dmin) _dmin = Delta;
      fprintf(__stderrp, "3\n");
  } } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 45 "/Users/weugene/basilisk/src/tension.h"
{
# 45 "/Users/weugene/basilisk/src/tension.h"
 {
    fprintf(__stderrp, "%g %g %g %g xyzxz: %g %g %g\n", ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)], _amin, _amax, x, y, z);
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)] > _amax) _amax = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)];
      fprintf(__stderrp, "1\n");
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)] < _amin) _amin = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)];
      fprintf(__stderrp, "2\n");
    if (Delta < _dmin) _dmin = Delta;
      fprintf(__stderrp, "3\n");
  } } }} } } }
# 53 "/Users/weugene/basilisk/src/tension.h"
 ; }
if (((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 45 "/Users/weugene/basilisk/src/tension.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 45 "/Users/weugene/basilisk/src/tension.h"
{
# 45 "/Users/weugene/basilisk/src/tension.h"
 {
    fprintf(__stderrp, "%g %g %g %g xyzxz: %g %g %g\n", _const_fm.x, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)], _amin, _amax, x, y, z);
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)]/_const_fm.x > _amax) _amax = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)]/_const_fm.x;
      fprintf(__stderrp, "1\n");
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)]/_const_fm.x < _amin) _amin = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)]/_const_fm.x;
      fprintf(__stderrp, "2\n");
    if (Delta < _dmin) _dmin = Delta;
      fprintf(__stderrp, "3\n");
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 45 "/Users/weugene/basilisk/src/tension.h"
{
# 45 "/Users/weugene/basilisk/src/tension.h"
 {
    fprintf(__stderrp, "%g %g %g %g xyzxz: %g %g %g\n", _const_fm.y, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)], _amin, _amax, x, y, z);
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)]/_const_fm.y > _amax) _amax = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)]/_const_fm.y;
      fprintf(__stderrp, "1\n");
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)]/_const_fm.y < _amin) _amin = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)]/_const_fm.y;
      fprintf(__stderrp, "2\n");
    if (Delta < _dmin) _dmin = Delta;
      fprintf(__stderrp, "3\n");
  } } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 45 "/Users/weugene/basilisk/src/tension.h"
{
# 45 "/Users/weugene/basilisk/src/tension.h"
 {
    fprintf(__stderrp, "%g %g %g %g xyzxz: %g %g %g\n", _const_fm.z, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)], _amin, _amax, x, y, z);
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)]/_const_fm.z > _amax) _amax = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)]/_const_fm.z;
      fprintf(__stderrp, "1\n");
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)]/_const_fm.z < _amin) _amin = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)]/_const_fm.z;
      fprintf(__stderrp, "2\n");
    if (Delta < _dmin) _dmin = Delta;
      fprintf(__stderrp, "3\n");
  } } }} } } }
# 53 "/Users/weugene/basilisk/src/tension.h"
 ; }
if (!((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 73 "/Users/weugene/basilisk/src/tension.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 45 "/Users/weugene/basilisk/src/tension.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 45 "/Users/weugene/basilisk/src/tension.h"
{
# 45 "/Users/weugene/basilisk/src/tension.h"
 {
    fprintf(__stderrp, "%g %g %g %g xyzxz: %g %g %g\n", ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)], _const_alpha.x, _amin, _amax, x, y, z);
    if (_const_alpha.x/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)] > _amax) _amax = _const_alpha.x/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)];
      fprintf(__stderrp, "1\n");
    if (_const_alpha.x/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)] < _amin) _amin = _const_alpha.x/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)];
      fprintf(__stderrp, "2\n");
    if (Delta < _dmin) _dmin = Delta;
      fprintf(__stderrp, "3\n");
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 45 "/Users/weugene/basilisk/src/tension.h"
{
# 45 "/Users/weugene/basilisk/src/tension.h"
 {
    fprintf(__stderrp, "%g %g %g %g xyzxz: %g %g %g\n", ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)], _const_alpha.y, _amin, _amax, x, y, z);
    if (_const_alpha.y/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)] > _amax) _amax = _const_alpha.y/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)];
      fprintf(__stderrp, "1\n");
    if (_const_alpha.y/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)] < _amin) _amin = _const_alpha.y/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)];
      fprintf(__stderrp, "2\n");
    if (Delta < _dmin) _dmin = Delta;
      fprintf(__stderrp, "3\n");
  } } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 45 "/Users/weugene/basilisk/src/tension.h"
{
# 45 "/Users/weugene/basilisk/src/tension.h"
 {
    fprintf(__stderrp, "%g %g %g %g xyzxz: %g %g %g\n", ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)], _const_alpha.z, _amin, _amax, x, y, z);
    if (_const_alpha.z/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)] > _amax) _amax = _const_alpha.z/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)];
      fprintf(__stderrp, "1\n");
    if (_const_alpha.z/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)] < _amin) _amin = _const_alpha.z/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)];
      fprintf(__stderrp, "2\n");
    if (Delta < _dmin) _dmin = Delta;
      fprintf(__stderrp, "3\n");
  } } }} } } }
# 53 "/Users/weugene/basilisk/src/tension.h"
 ; }
if (((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 75 "/Users/weugene/basilisk/src/tension.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 45 "/Users/weugene/basilisk/src/tension.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.k = ((Tree *)grid)->faces.p[_k].k; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_x)) {
# 45 "/Users/weugene/basilisk/src/tension.h"
{
# 45 "/Users/weugene/basilisk/src/tension.h"
 {
    fprintf(__stderrp, "%g %g %g %g xyzxz: %g %g %g\n", _const_fm.x, _const_alpha.x, _amin, _amax, x, y, z);
    if (_const_alpha.x/_const_fm.x > _amax) _amax = _const_alpha.x/_const_fm.x;
      fprintf(__stderrp, "1\n");
    if (_const_alpha.x/_const_fm.x < _amin) _amin = _const_alpha.x/_const_fm.x;
      fprintf(__stderrp, "2\n");
    if (Delta < _dmin) _dmin = Delta;
      fprintf(__stderrp, "3\n");
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_y)) {
# 45 "/Users/weugene/basilisk/src/tension.h"
{
# 45 "/Users/weugene/basilisk/src/tension.h"
 {
    fprintf(__stderrp, "%g %g %g %g xyzxz: %g %g %g\n", _const_fm.y, _const_alpha.y, _amin, _amax, x, y, z);
    if (_const_alpha.y/_const_fm.y > _amax) _amax = _const_alpha.y/_const_fm.y;
      fprintf(__stderrp, "1\n");
    if (_const_alpha.y/_const_fm.y < _amin) _amin = _const_alpha.y/_const_fm.y;
      fprintf(__stderrp, "2\n");
    if (Delta < _dmin) _dmin = Delta;
      fprintf(__stderrp, "3\n");
  } } }} { int kg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ;; if ((_flags & face_z)) {
# 45 "/Users/weugene/basilisk/src/tension.h"
{
# 45 "/Users/weugene/basilisk/src/tension.h"
 {
    fprintf(__stderrp, "%g %g %g %g xyzxz: %g %g %g\n", _const_fm.z, _const_alpha.z, _amin, _amax, x, y, z);
    if (_const_alpha.z/_const_fm.z > _amax) _amax = _const_alpha.z/_const_fm.z;
      fprintf(__stderrp, "1\n");
    if (_const_alpha.z/_const_fm.z < _amin) _amin = _const_alpha.z/_const_fm.z;
      fprintf(__stderrp, "2\n");
    if (Delta < _dmin) _dmin = Delta;
      fprintf(__stderrp, "3\n");
  } } }} } } }
# 53 "/Users/weugene/basilisk/src/tension.h"
 ; } if (_amin < amin) amin = _amin;
                                     ;
                  if (_amax > amax) amax = _amax;
                                     ;
                  if (_dmin < dmin) dmin = _dmin;
                                     ;



}
# 53 "/Users/weugene/basilisk/src/tension.h"
 }
  fprintf(__stderrp, "amin=%g amax=%g dmin=%g\n", amin, amax, dmin);
  double rhom = (1./amin + 1./amax)/2.;





  double sigma = 0.;
  if (interfaces) for (scalar c = *interfaces, *_i108 = interfaces; ((scalar *)&c)->i >= 0; c = *++_i108)
    sigma += _attribute[c.i].sigma;
  if (sigma) {
    double dt = sqrt (rhom*((dmin)*(dmin)*(dmin))/(3.14159265358979*sigma));
    if (dt < dtmax)
      dtmax = dt;
  }
  }
                                                                      ; } return 0; }







static int acceleration_1_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int acceleration_1 (const int i, const double t, Event * _ev) { ;
{




  if (interfaces) for (scalar f = *interfaces, *_i109 = interfaces; ((scalar *)&f)->i >= 0; f = *++_i109)
    if (_attribute[f.i].sigma) {





      scalar phi = _attribute[f.i].phi;
      if (phi.i)
 curvature ((struct Curvature){f, phi, _attribute[f.i].sigma, .add = 1});
      else {
 phi = new_scalar("phi");
 curvature ((struct Curvature){f, phi, _attribute[f.i].sigma, .add = 0});
 _attribute[f.i].phi = phi;
      }



    }
                                                                          ; } return 0; }
# 25 "tube_bp_rel.c"
# 1 "./adapt_wavelet_limited.h"
# 1 "/Users/weugene/basilisk/work/src_local/adapt_wavelet_limited.h"
# 18 "/Users/weugene/basilisk/work/src_local/adapt_wavelet_limited.h"
struct Adapt_limited {
  scalar * slist;
  double * max;
  int (*MLFun)(double,double,double);
  int minlevel;
  scalar * list;
};


astats adapt_wavelet_limited (struct Adapt_limited p)
{ ;
  scalar * listcm = ((void*)0);

  if (((cm).i >= 65536)) {
    if (p.list == ((void*)0))
      p.list = all;
    restriction (p.slist);
  }
  else {
    if (p.list == ((void*)0)) {
      listcm = list_concat (((void*)0), ((scalar []){cm,fm.x,fm.y,fm.z,{-1}}));
      if (all) for (scalar s = *all, *_i110 = all; ((scalar *)&s)->i >= 0; s = *++_i110)
 listcm = list_add (listcm, s);
      p.list = listcm;
    }
    scalar * listr = list_concat (p.slist, ((scalar []){cm,{-1}}));
    restriction (listr);
    free(listr);
  }

  astats st = {0, 0};
  scalar * listc = ((void*)0);
  if (p.list) for (scalar s = *p.list, *_i111 = p.list; ((scalar *)&s)->i >= 0; s = *++_i111)
    if (!((s).i >= 65536) && _attribute[s.i].restriction != no_restriction)
      listc = list_add (listc, s);


  if (p.minlevel < 1)
    p.minlevel = 1;
  ((Tree *)grid)->refined.n = 0;
  static const int refined = 1 << user, too_fine = 1 << (user + 1);
   { { Point root = {2,2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 59 "/Users/weugene/basilisk/work/src_local/adapt_wavelet_limited.h"
 {
    int cellMAX = p.MLFun(x,y,z);
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & active)) {
      static const int too_coarse = 1 << (user + 2);
      if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {
 if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & too_coarse) {
   (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_coarse;
   refine_cell (point, listc, refined, &((Tree *)grid)->refined);
   st.nf++;
 }
 continue;
      }
      else {
 if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & refined) {

   (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_coarse;
   continue;
 }

 _Bool local = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0);
 if (!local)
    { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
     if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0))
       local = 1, _l = _m = _n = 2; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
 if (local) {
   int i = 0;
   static const int just_fine = 1 << (user + 3);
   if (p.slist) for (scalar s = *p.slist, *_i112 = p.slist; ((scalar *)&s)->i >= 0; s = *++_i112) {
     double max = p.max[i++], sc[1 << 3];
     int c = 0;
      { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
       sc[c++] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
     _attribute[s.i].prolongation (point, s);
     c = 0;
      { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; {
       double e = fabs(sc[c] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]);
       if (e > max && level < cellMAX) {
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_fine;
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags |= too_coarse;
       }
       else if ((e <= max/1.5 || level > cellMAX) &&
         !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & (too_coarse|just_fine))) {
  if (level >= p.minlevel)
    (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags |= too_fine;
       }
       else if (!((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & too_coarse)) {
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_fine;
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags |= just_fine;
       }
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = sc[c++];
     } } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
   }
    { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; {
     (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~just_fine;
     if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {
       (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_coarse;
       if (level >= cellMAX)
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags |= too_fine;
     }
     else if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & active))
       (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_coarse;
   } } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
 }
      }
    }
    else
      continue;
  } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
  mpi_boundary_refine (listc);



  for (int l = (grid->depth); l >= p.minlevel; l--) {
     { { Point root = {2,2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 132 "/Users/weugene/basilisk/work/src_local/adapt_wavelet_limited.h"

      if (!((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid < 0)) {
 if (level == l) {
   if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {
     if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & refined)

       (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~(refined|too_fine);
     else if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & too_fine) {
       if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0) && coarsen_cell (point, listc))
  st.nc++;
       (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_fine;
     }
   }
   if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & too_fine)
     (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_fine;
   else if ((*((Cell *)((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+0][(point.k+2)/2+0])))).flags & too_fine)
     (*((Cell *)((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+0][(point.k+2)/2+0])))).flags &= ~too_fine;
   continue;
 }
 else if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf))
   continue;
      } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
    mpi_boundary_coarsen (l, too_fine);
  }
  free(listc);

                                          ;
                                          ;
  if (st.nc || st.nf)
    mpi_boundary_update (p.list);
  free(listcm);

  { astats _ret = st; ; return _ret; }
                                                                                                          ; }
# 26 "tube_bp_rel.c"
# 1 "./adapt2.h"
# 1 "/Users/weugene/basilisk/work/src_local/adapt2.h"
struct Adapt2 {
  scalar * slist;
  double * max;
  int * maxlevel;
  int minlevel;
  scalar * list;
};


astats adapt_wavelet2 (struct Adapt2 p)
{ ;
  if (p.list == ((void*)0))
    p.list = all;
  if (((cm).i >= 65536))
    restriction (p.slist);
  else {
    scalar * listr = list_concat (((scalar []){cm,{-1}}), p.slist);
    restriction (listr);
    free(listr);
  }
  astats st = {0, 0};
  scalar * listc = ((void*)0);
  if (p.list) for (scalar s = *p.list, *_i113 = p.list; ((scalar *)&s)->i >= 0; s = *++_i113)
    if (!((s).i >= 65536) && _attribute[s.i].restriction != no_restriction)
      listc = list_add (listc, s);

  if (p.minlevel < 1)
    p.minlevel = 1;
  ((Tree *)grid)->refined.n = 0;
  static const int refined = 1 << user, too_fine = 1 << (user + 1);
   { { Point root = {2,2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 31 "/Users/weugene/basilisk/work/src_local/adapt2.h"
 {
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & active)) {
      static const int too_coarse = 1 << (user + 2);
      if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {
 if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & too_coarse) {
   (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_coarse;
   refine_cell (point, listc, refined, &((Tree *)grid)->refined);
   st.nf++;
 }
 continue;
      }
      else {
 if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & refined) {

   (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_coarse;
   continue;
 }

 _Bool local = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0);
 if (!local)
    { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
     if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0))
       local = 1, _l = _m = _n = 2; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
 if (local) {
   int i = 0;
   static const int just_fine = 1 << (user + 3);
   if (p.slist) for (scalar s = *p.slist, *_i114 = p.slist; ((scalar *)&s)->i >= 0; s = *++_i114) {
     double max = p.max[i], sc[1 << 3];
     int mlev = p.maxlevel[i++];
     int c = 0;
      { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
       sc[c++] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
     _attribute[s.i].prolongation (point, s);
     c = 0;
      { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; {
       double e = fabs(sc[c] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)]);
       if (e > max && level < mlev) {
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_fine;
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags |= too_coarse;
       }
       else if ((e <= max/1.5 || level > (mlev-1)) &&
         !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & (too_coarse|just_fine))) {
  if (level >= p.minlevel)
    (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags |= too_fine;
       }
       else if (!((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & too_coarse)) {
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_fine;
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags |= just_fine;
       }
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] = sc[c++];
     } } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
   }
    { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; {
     (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~just_fine;
     if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {
       (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_coarse;
       if (level >= 13)
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags |= too_fine;
     }
     else if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & active))
       (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_coarse;
   } } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
 }
      }
    }
    else
      continue;
  } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
  mpi_boundary_refine (listc);


  for (int l = (grid->depth); l >= 0; l--) {
     { { Point root = {2,2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 103 "/Users/weugene/basilisk/work/src_local/adapt2.h"

      if (!((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).pid < 0)) {
 if (level == l) {
   if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {
     if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & refined)

       (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~(refined|too_fine);
     else if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & too_fine) {
       if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0) && coarsen_cell (point, listc))
  st.nc++;
       (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_fine;
     }
   }
   if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags & too_fine)
     (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])))).flags &= ~too_fine;
   else if (level > 0 && ((*((Cell *)((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+0][(point.k+2)/2+0])))).flags & too_fine))
     (*((Cell *)((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+0][(point.k+2)/2+0])))).flags &= ~too_fine;
   continue;
 }
 else if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf))
   continue;
      } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
    mpi_boundary_coarsen (l, too_fine);
  }
  free(listc);
                                          ;
                                          ;
  if (st.nc || st.nf)
    mpi_boundary_update (p.list);
  { astats _ret = st; ; return _ret; }
                                                                                    ; }
# 27 "tube_bp_rel.c"
# 1 "./lambda2.h"
# 1 "/Users/weugene/basilisk/src/lambda2.h"
static void eigsrt (double d[3],
      double v[3][3])
{
  int k, j, i;
  double p;

  for (i = 0; i < 3 - 1; i++) {
    p = d[k = i];

    for (j = i + 1; j < 3; j++)
      if (d[j] >= p)
 p = d[k = j];
    if (k != i) {
      d[k] = d[i];
      d[i] = p;
      for (j = 0; j < 3; j++) {
 p = v[j][i];
 v[j][i] = v[j][k];
 v[j][k] = p;
      }
    }
  }
}
# 37 "/Users/weugene/basilisk/src/lambda2.h"
void eigenvalues (double a[3][3],
    double d[3],
    double v[3][3])
{
  int j, iq, ip, i;
  double tresh, theta, tau, t, sm, s, h, g, c, b[3], z[3];

  for (ip = 0; ip < 3; ip++) {
    for (iq = 0; iq < 3; iq++)
      v[ip][iq] = 0.0;
    v[ip][ip] = 1.0;
  }

  for (ip = 0; ip < 3; ip++) {
    b[ip] = d[ip] = a[ip][ip];
    z[ip] = 0.0;
  }

  for (i = 1; i <= 50; i++) {
    sm = 0.0;
    for (ip = 0; ip < 3 - 1; ip++) {
      for (iq = ip + 1; iq < 3; iq++)
 sm += fabs (a[ip][iq]);
    }
    if (sm == 0.0) {
      eigsrt (d, v);
      return;
    }
    if (i < 4)
      tresh = 0.2*sm/(3*3);
    else
      tresh = 0.0;
    for (ip = 0; ip < 3 - 1; ip++) {
      for (iq = ip + 1; iq < 3; iq++) {
 g = 100.0*fabs (a[ip][iq]);
 if (i > 4 && fabs(d[ip]) + g == fabs(d[ip]) &&
     fabs(d[iq]) + g == fabs(d[iq]))
   a[ip][iq] = 0.0;
 else if (fabs (a[ip][iq]) > tresh) {
   h = d[iq] - d[ip];
   if (fabs(h) + g == fabs(h))
     t = a[ip][iq]/h;
   else {
     theta = 0.5*h/a[ip][iq];
     t = 1.0/(fabs (theta) + sqrt (1.0 + theta*theta));
     if (theta < 0.0) t = -t;
   }
   c = 1.0/sqrt (1 + t*t);
   s = t*c;
   tau = s/(1.0 + c);
   h = t*a[ip][iq];
   z[ip] -= h;
   z[iq] += h;
   d[ip] -= h;
   d[iq] += h;
   a[ip][iq] = 0.0;
   for (j = 0; j <= ip - 1; j++)
     { g=a[j][ip];h=a[j][iq];a[j][ip]=g-s*(h+g*tau);a[j][iq]=h+s*(g-h*tau);};
   for (j = ip + 1; j <= iq - 1; j++)
     { g=a[ip][j];h=a[j][iq];a[ip][j]=g-s*(h+g*tau);a[j][iq]=h+s*(g-h*tau);};
   for (j = iq + 1; j < 3; j++)
     { g=a[ip][j];h=a[iq][j];a[ip][j]=g-s*(h+g*tau);a[iq][j]=h+s*(g-h*tau);};
   for (j = 0; j < 3; j++)
     { g=v[j][ip];h=v[j][iq];v[j][ip]=g-s*(h+g*tau);v[j][iq]=h+s*(g-h*tau);};
 }
      }
    }
    for (ip = 0; ip < 3; ip++) {
      b[ip] += z[ip];
      d[ip] = b[ip];
      z[ip] = 0.0;
    }
  }

  for (i = 0; i < 3; i++) {
    for (j = 0; j < 3; j++)
      fprintf (__stderrp, "%10.3g ", a[i][j]);
    fprintf (__stderrp, "\n");
  }
  (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/lambda2.h", 116, "false") : (void)0);
}

void lambda2 (const vector u, scalar l2)
{
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 121 "/Users/weugene/basilisk/src/lambda2.h"
 {
    double JJ[3][3];
    scalar s = u.x;
    int i = 0;
    {
# 125 "/Users/weugene/basilisk/src/lambda2.h"

      JJ[0][i++] = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)])/(2.*Delta));
# 125 "/Users/weugene/basilisk/src/lambda2.h"

      JJ[0][i++] = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(s.i)])/(2.*Delta));
# 125 "/Users/weugene/basilisk/src/lambda2.h"

      JJ[0][i++] = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(s.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(s.i)])/(2.*Delta));}
    s = u.y; i = 0;
    {
# 128 "/Users/weugene/basilisk/src/lambda2.h"

      JJ[1][i++] = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)])/(2.*Delta));
# 128 "/Users/weugene/basilisk/src/lambda2.h"

      JJ[1][i++] = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(s.i)])/(2.*Delta));
# 128 "/Users/weugene/basilisk/src/lambda2.h"

      JJ[1][i++] = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(s.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(s.i)])/(2.*Delta));}
    s = u.z; i = 0;
    {
# 131 "/Users/weugene/basilisk/src/lambda2.h"

      JJ[2][i++] = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(s.i)])/(2.*Delta));
# 131 "/Users/weugene/basilisk/src/lambda2.h"

      JJ[2][i++] = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(s.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(s.i)])/(2.*Delta));
# 131 "/Users/weugene/basilisk/src/lambda2.h"

      JJ[2][i++] = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(s.i)] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(s.i)])/(2.*Delta));}
    double S2O2[3][3];
    for (int i = 0; i < 3; i++)
      for (int j = 0; j < 3; j++) {
 S2O2[i][j] = 0.;
 for (int k = 0; k < 3; k++)
   S2O2[i][j] += JJ[i][k]*JJ[k][j] + JJ[k][i]*JJ[j][k];
      }
    double lambda[3], ev[3][3];
    eigenvalues (S2O2, lambda, ev);
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(l2.i)] = lambda[1]/2.;
  } } } } }; }
  boundary (((scalar []){l2,{-1}}));
}
# 30 "tube_bp_rel.c"
# 1 "./output_vtu_foreach.h"
# 1 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
# 50 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
 char components_name[] = "ComponentName0=\"left_X\" ComponentName1=\"left_Y\" ComponentName2=\"left_Z\" "
                             "ComponentName3=\"right_X\" ComponentName4=\"right_Y\" ComponentName5=\"right_Z\" "
                             "ComponentName6=\"bottom_X\" ComponentName7=\"bottom_Y\" ComponentName8=\"bottom_Z\" "
                             "ComponentName9=\"top_X\" ComponentName10=\"top_Y\" ComponentName11=\"top_Z\" "
                             "ComponentName12=\"back_X\" ComponentName13=\"back_Y\" ComponentName14=\"back_Z\" "
                             "ComponentName15=\"front_X\" ComponentName16=\"front_Y\" ComponentName17=\"fronts_Z\" ";


char array_subname[][40] = { "left", "center", "right",
                                          "bottom", "top",
                                          "back", "front"
                                        };
int aid[7][3] = { {-1,0,0}, {0,0,0}, {1,0,0},
                  {0,-1,0}, {0,1,0},
                  {0,0,-1}, {0,0,1}
                };


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 1 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/endian.h" 1 3 4
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/endian.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/i386/endian.h" 1 3 4
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/endian.h" 2 3 4
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 95 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 3 4
typedef u_int64_t u_quad_t;
typedef int64_t quad_t;
typedef quad_t * qaddr_t;


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_caddr_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_caddr_t.h" 3 4
typedef char * caddr_t;
# 100 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4

typedef int32_t daddr_t;


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_dev_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_dev_t.h" 3 4
typedef __darwin_dev_t dev_t;
# 104 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4

typedef u_int32_t fixpt_t;


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_blkcnt_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_blkcnt_t.h" 3 4
typedef __darwin_blkcnt_t blkcnt_t;
# 108 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_blksize_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_blksize_t.h" 3 4
typedef __darwin_blksize_t blksize_t;
# 109 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_addr_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_addr_t.h" 3 4
typedef __uint32_t in_addr_t;
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_port_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_port_t.h" 3 4
typedef __uint16_t in_port_t;
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ino_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ino_t.h" 3 4
typedef __darwin_ino_t ino_t;
# 113 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_key_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_key_t.h" 3 4
typedef __int32_t key_t;
# 119 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_mode_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_mode_t.h" 3 4
typedef __darwin_mode_t mode_t;
# 120 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_nlink_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_nlink_t.h" 3 4
typedef __uint16_t nlink_t;
# 121 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4




typedef int32_t segsz_t;
typedef int32_t swblk_t;
# 213 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_cond_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_cond_t.h" 3 4
typedef __darwin_pthread_cond_t pthread_cond_t;
# 214 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_condattr_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_condattr_t.h" 3 4
typedef __darwin_pthread_condattr_t pthread_condattr_t;
# 215 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h" 3 4
typedef __darwin_pthread_mutex_t pthread_mutex_t;
# 216 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h" 3 4
typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;
# 217 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_once_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_once_t.h" 3 4
typedef __darwin_pthread_once_t pthread_once_t;
# 218 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlock_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlock_t.h" 3 4
typedef __darwin_pthread_rwlock_t pthread_rwlock_t;
# 219 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlockattr_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlockattr_t.h" 3 4
typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;
# 220 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_key_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_key_t.h" 3 4
typedef __darwin_pthread_key_t pthread_key_t;
# 225 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsblkcnt_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsblkcnt_t.h" 3 4
typedef __darwin_fsblkcnt_t fsblkcnt_t;
# 230 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsfilcnt_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsfilcnt_t.h" 3 4
typedef __darwin_fsfilcnt_t fsfilcnt_t;
# 231 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 68 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/stat.h" 1 3 4
# 182 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/stat.h" 3 4
struct stat { dev_t st_dev; mode_t st_mode; nlink_t st_nlink; __darwin_ino64_t st_ino; uid_t st_uid; gid_t st_gid; dev_t st_rdev; time_t st_atime; long st_atimensec; time_t st_mtime; long st_mtimensec; time_t st_ctime; long st_ctimensec; time_t st_birthtime; long st_birthtimensec; off_t st_size; blkcnt_t st_blocks; blksize_t st_blksize; __uint32_t st_flags; __uint32_t st_gen; __int32_t st_lspare; __int64_t st_qspare[2]; };
# 241 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/stat.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_s_ifmt.h" 1 3 4
# 242 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/stat.h" 2 3 4
# 355 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/stat.h" 3 4
int chmod(const char *, mode_t) __asm("_" "chmod" );
int fchmod(int, mode_t) __asm("_" "fchmod" );
int fstat(int, struct stat *) __asm("_" "fstat" "$INODE64");
int lstat(const char *, struct stat *) __asm("_" "lstat" "$INODE64");
int mkdir(const char *, mode_t);
int mkfifo(const char *, mode_t);
int stat(const char *, struct stat *) __asm("_" "stat" "$INODE64");
int mknod(const char *, mode_t, dev_t);
mode_t umask(mode_t);


int fchmodat(int, const char *, mode_t, int) __attribute__((availability(macosx,introduced=10.10)));
int fstatat(int, const char *, struct stat *, int) __asm("_" "fstatat" "$INODE64") __attribute__((availability(macosx,introduced=10.10)));
int mkdirat(int, const char *, mode_t) __attribute__((availability(macosx,introduced=10.10)));




int futimens(int __fd, const struct timespec __times[2]) __attribute__((availability(macosx,introduced=10.13))) __attribute__((availability(ios,introduced=11.0))) __attribute__((availability(tvos,introduced=11.0))) __attribute__((availability(watchos,introduced=4.0)));
int utimensat(int __fd, const char *__path, const struct timespec __times[2],
  int __flag) __attribute__((availability(macosx,introduced=10.13))) __attribute__((availability(ios,introduced=11.0))) __attribute__((availability(tvos,introduced=11.0))) __attribute__((availability(watchos,introduced=4.0)));
# 69 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h" 2

void output_pvtu_ascii (scalar * list, vector * vlist, vector * fvlist, int n, FILE * fp, char * subname)
{
    int dim=3;
    fputs ("<?xml version=\"1.0\"?>\n"
    "<VTKFile type=\"PUnstructuredGrid\" version=\"1.0\" byte_order=\"LittleEndian\" header_type=\"UInt64\">\n", fp);
    fputs ("\t <PUnstructuredGrid GhostLevel=\"0\">\n", fp);
    fputs ("\t\t\t <PCellData Scalars=\"scalars\">\n", fp);
# 87 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
 if (list) for (scalar s = *list, *_i115 = list; ((scalar *)&s)->i >= 0; s = *++_i115) {
      for (int i=0; i<7; i++)
            fprintf (fp,"\t\t\t\t <PDataArray type=\"Float64\" Name=\"%s_%s\" format=\"ascii\">\n", _attribute[s.i].name, array_subname[i]);
      fputs ("\t\t\t\t </PDataArray>\n", fp);
    }
    if (vlist) for (vector v = *vlist, *_i116 = vlist; ((scalar *)&v)->i >= 0; v = *++_i116) {
        for (int i=0; i<7; i++)
            fprintf (fp,"\t\t\t\t <PDataArray type=\"Float64\" NumberOfComponents=\"%d\" Name=\"%s_%s\" format=\"ascii\">\n", dim, _attribute[v.x.i].name, array_subname[i]);
      fputs ("\t\t\t\t </PDataArray>\n", fp);
    }

    if (fvlist) for (vector v = *fvlist, *_i117 = fvlist; ((scalar *)&v)->i >= 0; v = *++_i117) {
        fprintf (fp,"\t\t\t\t <PDataArray type=\"Float64\" NumberOfComponents=\"%d\" %s Name=\"%s\" format=\"ascii\">\n", 18, components_name, _attribute[v.x.i].name);
        fputs ("\t\t\t\t </PDataArray>\n", fp);
    }
    fputs ("\t\t\t </PCellData>\n", fp);
    fputs ("\t\t\t <PPoints>\n", fp);
    fputs ("\t\t\t\t <PDataArray type=\"Float64\" NumberOfComponents=\"3\" format=\"ascii\">\n", fp);
    fputs ("\t\t\t\t </PDataArray>\n", fp);
    fputs ("\t\t\t </PPoints>\n", fp);

    for (int i = 0; i < 1; i++)
      fprintf (fp, "<Piece Source=\"%s_n%3.3d.vtu\"/> \n", subname, i);

    fputs ("\t </PUnstructuredGrid>\n", fp);
    fputs ("</VTKFile>\n", fp);
}
# 123 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
void output_vtu_ascii_foreach (scalar * list, vector * vlist, vector * fvlist, int n, FILE * fp, _Bool linear)
{
    int dim = 3;
    coord Pmin = {X0 + 1e-12, Y0 + 1e-12, Z0 + 1e-12};
    coord Pmax = {X0 + L0 - 1e-12, Y0 + L0 - 1e-12, Z0 + L0 - 1e-12};





  scalar marker= new_vertex_scalar("marker");
  int no_points = 0, no_cells=0 ;
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->vertices.n; _k++) { point.i = ((Tree *)grid)->vertices.p[_k].i; point.j = ((Tree *)grid)->vertices.p[_k].j; point.k = ((Tree *)grid)->vertices.p[_k].k; point.level = ((Tree *)grid)->vertices.p[_k].level; _flags = ((Tree *)grid)->vertices.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { x -= Delta/2.; y -= Delta/2.; z -= Delta/2.;{
# 135 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
{
    if ((((!Period.x) || (Pmax.x - x - 0.5*Delta > 0)) && ((!Period.y) || (Pmax.y - y - 0.5*Delta > 0)) && ((!Period.z) || (Pmax.z - z - 0.5*Delta > 0)))) {
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(marker.i)] = no_points++;
    }else{
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(marker.i)] = -1;
    }
  } } } } } }; }
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 142 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
{
    if ((((!Period.x) || (Pmax.x - x - 0.5*Delta > 0)) && ((!Period.y) || (Pmax.y - y - 0.5*Delta > 0)) && ((!Period.z) || (Pmax.z - z - 0.5*Delta > 0)))) no_cells += 1;
  } } } } }; }

  fputs ("<?xml version=\"1.0\"?>\n"
  "<VTKFile type=\"UnstructuredGrid\" version=\"1.0\" byte_order=\"LittleEndian\" header_type=\"UInt64\">\n", fp);
  fputs ("\t <UnstructuredGrid>\n", fp);
  fprintf (fp,"\t\t <Piece NumberOfPoints=\"%d\" NumberOfCells=\"%d\">\n", no_points, no_cells);
  fputs ("\t\t\t <CellData Scalars=\"scalars\">\n", fp);
# 178 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
 if (list) for (scalar s = *list, *_i118 = list; ((scalar *)&s)->i >= 0; s = *++_i118) {
      for (int i=0; i<7; i++){
          fprintf (fp,"\t\t\t\t <DataArray type=\"Float64\" Name=\"%s_%s\" format=\"ascii\">\n", _attribute[s.i].name, array_subname[i]);
           { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 181 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
{
              if ((((!Period.x) || (Pmax.x - x - 0.5*Delta > 0)) && ((!Period.y) || (Pmax.y - y - 0.5*Delta > 0)) && ((!Period.z) || (Pmax.z - z - 0.5*Delta > 0))))
                fprintf (fp, "\t\t\t\t\t %g \n",((double *) ((((Tree *)grid)->L[point.level]->m[point.i+aid[i][0]][point.j+aid[i][1]] [point.k+aid[i][2]]) + sizeof(Cell)))[(s.i)]);
          } } } } }; }
      }
      fputs ("\t\t\t\t </DataArray>\n", fp);
  }
  if (vlist) for (vector v = *vlist, *_i119 = vlist; ((scalar *)&v)->i >= 0; v = *++_i119) {
      for (int i=0; i<7; i++){
          fprintf (fp,"\t\t\t\t <DataArray type=\"Float64\" NumberOfComponents=\"%d\" Name=\"%s_%s\" format=\"ascii\">\n", dim, _attribute[v.x.i].name, array_subname[i]);
           { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 191 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
{
              if ((((!Period.x) || (Pmax.x - x - 0.5*Delta > 0)) && ((!Period.y) || (Pmax.y - y - 0.5*Delta > 0)) && ((!Period.z) || (Pmax.z - z - 0.5*Delta > 0)))){







                    fprintf (fp, "\t\t\t\t\t %g %g %g\n", ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+aid[i][0]][point.j+aid[i][1]] [point.k+aid[i][2]]) + sizeof(Cell)))[(v.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+aid[i][0]][point.j+aid[i][1]] [point.k+aid[i][2]]) + sizeof(Cell)))[(v.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+aid[i][0]][point.j+aid[i][1]] [point.k+aid[i][2]]) + sizeof(Cell)))[(v.z.i)]);

              }
          } } } } }; }
    }
    fputs ("\t\t\t\t </DataArray>\n", fp);
  }

  if (fvlist) for (vector v = *fvlist, *_i120 = fvlist; ((scalar *)&v)->i >= 0; v = *++_i120) {
    fprintf (fp,"\t\t\t\t <DataArray type=\"Float64\" NumberOfComponents=\"%d\" %s Name=\"%s\" format=\"ascii\">\n", 18, components_name, _attribute[v.x.i].name);
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 210 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
{
      if ((((!Period.x) || (Pmax.x - x - 0.5*Delta > 0)) && ((!Period.y) || (Pmax.y - y - 0.5*Delta > 0)) && ((!Period.z) || (Pmax.z - z - 0.5*Delta > 0)))){
# 222 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
 double arr[18]={((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)],
                                     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)],
                                     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(v.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(v.z.i)],
                                     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(v.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(v.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(v.z.i)],
                                     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(v.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(v.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)],
                                     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(v.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(v.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(v.z.i)]};

        fprintf (fp, "\t\t\t\t\t ");
        for (int i = 0; i < 18; i++){
            fprintf (fp, "%g ", arr[i]);
        }
        fprintf (fp, "\n");
      }
    } } } } }; }
    fputs ("\t\t\t\t </DataArray>\n", fp);
  }

  fputs ("\t\t\t </CellData>\n", fp);
  fputs ("\t\t\t <Points>\n", fp);
  fputs ("\t\t\t\t <DataArray type=\"Float64\" NumberOfComponents=\"3\" format=\"ascii\">\n", fp);
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->vertices.n; _k++) { point.i = ((Tree *)grid)->vertices.p[_k].i; point.j = ((Tree *)grid)->vertices.p[_k].j; point.k = ((Tree *)grid)->vertices.p[_k].k; point.level = ((Tree *)grid)->vertices.p[_k].level; _flags = ((Tree *)grid)->vertices.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { x -= Delta/2.; y -= Delta/2.; z -= Delta/2.;{
# 242 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
{
    if ((((!Period.x) || (Pmax.x - x - 0.5*Delta > 0)) && ((!Period.y) || (Pmax.y - y - 0.5*Delta > 0)) && ((!Period.z) || (Pmax.z - z - 0.5*Delta > 0))))
        fprintf (fp, "\t\t\t\t\t %g %g %g\n", x, y, z);
  } } } } } }; }
  fputs ("\t\t\t\t </DataArray>\n", fp);
  fputs ("\t\t\t </Points>\n", fp);
  fputs ("\t\t\t <Cells>\n", fp);
  fputs ("\t\t\t\t <DataArray type=\"Int64\" Name=\"connectivity\" format=\"ascii\">\n", fp);
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 250 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
{
    if ((((!Period.x) || (Pmax.x - x - 0.5*Delta > 0)) && ((!Period.y) || (Pmax.y - y - 0.5*Delta > 0)) && ((!Period.z) || (Pmax.z - z - 0.5*Delta > 0))))







      fprintf (fp, "\t\t\t\t\t %d %d %d %d %d %d %d %d \n", (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(marker.i)], (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(marker.i)], (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(marker.i)], (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(marker.i)], (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(marker.i)], (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(marker.i)], (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+1]) + sizeof(Cell)))[(marker.i)], (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(marker.i)]);

  } } } } }; }
  fputs ("\t\t\t\t </DataArray>\n", fp);
  fputs ("\t\t\t\t <DataArray type=\"Int64\" Name=\"offsets\" format=\"ascii\">\n", fp);

  for (int i = 1; i < no_cells+1; i++){




    fprintf (fp, "\t\t\t\t\t %d \n", i*8);

  }
  fputs ("\t\t\t\t </DataArray>\n", fp);
  fputs ("\t\t\t\t <DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">\n", fp);
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 275 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
{
    if ((((!Period.x) || (Pmax.x - x - 0.5*Delta > 0)) && ((!Period.y) || (Pmax.y - y - 0.5*Delta > 0)) && ((!Period.z) || (Pmax.z - z - 0.5*Delta > 0))))







      fputs ("\t\t\t\t\t 12 \n", fp);

  } } } } }; }
  fputs ("\t\t\t\t </DataArray>\n", fp);
  fputs ("\t\t\t </Cells>\n", fp);
  fputs ("\t\t </Piece>\n", fp);
  fputs ("\t </UnstructuredGrid>\n", fp);
  fputs ("</VTKFile>\n", fp);
  fflush (fp);



 delete (((scalar []){marker,{-1}})); }






void output_pvtu_bin (scalar * list, vector * vlist, vector * fvlist, int n, FILE * fp, char * subname)
{
    int dim=3;
    fputs ("<?xml version=\"1.0\"?>\n"
    "<VTKFile type=\"PUnstructuredGrid\" version=\"1.0\" byte_order=\"LittleEndian\" header_type=\"UInt64\">\n", fp);
    fputs ("\t <PUnstructuredGrid GhostLevel=\"0\">\n", fp);
    fputs ("\t\t\t <PCellData Scalars=\"scalars\">\n", fp);
# 318 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
 if (list) for (scalar s = *list, *_i121 = list; ((scalar *)&s)->i >= 0; s = *++_i121) {
        for (int i=0; i<7; i++)
            fprintf (fp,"\t\t\t\t <PDataArray type=\"Float64\" Name=\"%s_%s\" format=\"appended\"/>\n", _attribute[s.i].name, array_subname[i]);
    }
    if (vlist) for (vector v = *vlist, *_i122 = vlist; ((scalar *)&v)->i >= 0; v = *++_i122) {
        for (int i=0; i<7; i++)
            fprintf (fp,"\t\t\t\t <PDataArray type=\"Float64\" NumberOfComponents=\"%d\" Name=\"%s_%s\" format=\"appended\"/>\n", dim, _attribute[v.x.i].name, array_subname[i]);
    }

    if (fvlist) for (vector v = *fvlist, *_i123 = fvlist; ((scalar *)&v)->i >= 0; v = *++_i123) {
        fprintf (fp,"\t\t\t\t <PDataArray type=\"Float64\" NumberOfComponents=\"%d\" %s Name=\"%s\" format=\"appended\"/>\n", 18, components_name, _attribute[v.x.i].name);
    }
    fputs ("\t\t\t </PCellData>\n", fp);
    fputs ("\t\t\t <PPoints>\n", fp);
    fprintf (fp,"\t\t\t\t <PDataArray type=\"Float64\" NumberOfComponents=\"%d\" format=\"ascii\"/>\n", dim);
    fputs ("\t\t\t </PPoints>\n", fp);

    for (int i = 0; i < 1; i++)
      fprintf (fp, "<Piece Source=\"%s_n%3.3d.vtu\"/> \n", subname, i);

    fputs ("\t </PUnstructuredGrid>\n", fp);
    fputs ("</VTKFile>\n", fp);
}
# 351 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
void output_vtu_bin_foreach (scalar * list, vector * vlist, vector * fvlist, int n, FILE * fp, _Bool linear)
{
  int dim = 3;
  coord Pmin = {X0 + 1e-12, Y0 + 1e-12, Z0 + 1e-12};
  coord Pmax = {X0 + L0 - 1e-12, Y0 + L0 - 1e-12, Z0 + L0 - 1e-12};




  scalar marker= new_vertex_scalar("marker");
  int no_points = 0, no_cells = 0;
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->vertices.n; _k++) { point.i = ((Tree *)grid)->vertices.p[_k].i; point.j = ((Tree *)grid)->vertices.p[_k].j; point.k = ((Tree *)grid)->vertices.p[_k].k; point.level = ((Tree *)grid)->vertices.p[_k].level; _flags = ((Tree *)grid)->vertices.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { x -= Delta/2.; y -= Delta/2.; z -= Delta/2.;{
# 362 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
{
    if ((((!Period.x) || (Pmax.x - x - 0.5*Delta > 0)) && ((!Period.y) || (Pmax.y - y - 0.5*Delta > 0)) && ((!Period.z) || (Pmax.z - z - 0.5*Delta > 0)))) {
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(marker.i)] = no_points++;
    }else{
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(marker.i)] = -1;
    }
  } } } } } }; }
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 369 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
{
    if ((((!Period.x) || (Pmax.x - x - 0.5*Delta > 0)) && ((!Period.y) || (Pmax.y - y - 0.5*Delta > 0)) && ((!Period.z) || (Pmax.z - z - 0.5*Delta > 0)))) no_cells++;
  } } } } }; }
  fputs ("<?xml version=\"1.0\"?>\n"
  "<VTKFile type=\"UnstructuredGrid\" version=\"1.0\" byte_order=\"LittleEndian\" header_type=\"UInt64\">\n", fp);
  fputs ("\t <UnstructuredGrid>\n", fp);
  fprintf (fp,"\t\t <Piece NumberOfPoints=\"%d\" NumberOfCells=\"%d\">\n", no_points, no_cells);
  fputs ("\t\t\t <CellData Scalars=\"scalars\">\n", fp);
  int count = 0;
# 390 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
 if (list) for (scalar s = *list, *_i124 = list; ((scalar *)&s)->i >= 0; s = *++_i124) {
      for (int i=0; i<7; i++){
        fprintf (fp,"\t\t\t\t <DataArray type=\"Float64\" Name=\"%s_%s\" format=\"appended\" offset=\"%d\">\n", _attribute[s.i].name, array_subname[i], count);
        count += ((no_cells)+1)*8;
        fputs ("\t\t\t\t </DataArray>\n", fp);
      }
  }
  if (vlist) for (vector v = *vlist, *_i125 = vlist; ((scalar *)&v)->i >= 0; v = *++_i125) {
      for (int i=0; i<7; i++){
        fprintf (fp,"\t\t\t\t <DataArray type=\"Float64\" Name=\"%s_%s\" NumberOfComponents=\"%d\"  format=\"appended\" offset=\"%d\">\n", _attribute[v.x.i].name, array_subname[i], dim, count);
        count += (no_cells*dim+1)*8;
        fputs ("\t\t\t\t </DataArray>\n", fp);
      }
  }

  if (fvlist) for (vector v = *fvlist, *_i126 = fvlist; ((scalar *)&v)->i >= 0; v = *++_i126) {
    fprintf (fp,"\t\t\t\t <DataArray type=\"Float64\" Name=\"%s\" NumberOfComponents=\"%d\"  %s format=\"appended\" offset=\"%d\">\n", _attribute[v.x.i].name, 18, components_name, count);
    count += (no_cells*18 +1)*8;
    fputs ("\t\t\t\t </DataArray>\n", fp);
  }
  fputs ("\t\t\t </CellData>\n", fp);
  fputs ("\t\t\t <Points>\n", fp);
  fprintf (fp,"\t\t\t\t <DataArray type=\"Float64\" NumberOfComponents=\"%d\"  format=\"appended\" offset=\"%d\">\n", dim, count);
  count += (no_points*dim+1)*8;
  fputs ("\t\t\t\t </DataArray>\n", fp);
  fputs ("\t\t\t </Points>\n", fp);
  fputs ("\t\t\t <Cells>\n", fp);
  fputs ("\t\t\t\t <DataArray type=\"Int64\" Name=\"connectivity\" format=\"ascii\">\n", fp);
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 418 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
{
    if ((((!Period.x) || (Pmax.x - x - 0.5*Delta > 0)) && ((!Period.y) || (Pmax.y - y - 0.5*Delta > 0)) && ((!Period.z) || (Pmax.z - z - 0.5*Delta > 0)))) {







     fprintf (fp, "\t\t\t\t\t %d %d %d %d %d %d %d %d \n", (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(marker.i)], (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(marker.i)], (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+0]) + sizeof(Cell)))[(marker.i)], (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(marker.i)], (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(marker.i)], (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+1]) + sizeof(Cell)))[(marker.i)], (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1] [point.k+1]) + sizeof(Cell)))[(marker.i)], (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+1]) + sizeof(Cell)))[(marker.i)]);

    }
  } } } } }; }
  fputs ("\t\t\t\t </DataArray>\n", fp);
  fputs ("\t\t\t\t <DataArray type=\"Int64\" Name=\"offsets\" format=\"ascii\">\n", fp);
  for (int i = 1; i < no_cells+1; i++){







    fprintf (fp, "%d \n", i*8);

  }
  fputs ("\t\t\t\t </DataArray>\n", fp);
  fputs ("\t\t\t\t <DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">\n", fp);
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 446 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
{
    if ((((!Period.x) || (Pmax.x - x - 0.5*Delta > 0)) && ((!Period.y) || (Pmax.y - y - 0.5*Delta > 0)) && ((!Period.z) || (Pmax.z - z - 0.5*Delta > 0))))







      fputs ("12 \n", fp);

  } } } } }; }
  fputs ("\t\t\t\t </DataArray>\n", fp);
  fputs ("\t\t\t </Cells>\n", fp);
  fputs ("\t\t </Piece>\n", fp);
  fputs ("\t </UnstructuredGrid>\n", fp);
  fputs ("\t <AppendedData encoding=\"raw\">\n", fp);
  fputs ("_", fp);
  unsigned long long block_len=no_cells*8;
# 503 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
 if (list) for (scalar s = *list, *_i127 = list; ((scalar *)&s)->i >= 0; s = *++_i127) {
      for (int i=0; i<7; i++){
          fwrite (&block_len, sizeof (unsigned long long), 1, fp);
           { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 506 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"

            if ((((!Period.x) || (Pmax.x - x - 0.5*Delta > 0)) && ((!Period.y) || (Pmax.y - y - 0.5*Delta > 0)) && ((!Period.z) || (Pmax.z - z - 0.5*Delta > 0))))
                fwrite (&((double *) ((((Tree *)grid)->L[point.level]->m[point.i+aid[i][0]][point.j+aid[i][1]] [point.k+aid[i][2]]) + sizeof(Cell)))[(s.i)], sizeof (double), 1, fp); } } } }; }
    }
  }
  block_len=no_cells*8*dim;
  if (vlist) for (vector v = *vlist, *_i128 = vlist; ((scalar *)&v)->i >= 0; v = *++_i128) {
      for (int i=0; i<7; i++){
        int ai=aid[i][0], aj=aid[i][1], ak=aid[i][2];
        fwrite (&block_len, sizeof (unsigned long long), 1, fp);
         { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 516 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
{
          if ((((!Period.x) || (Pmax.x - x - 0.5*Delta > 0)) && ((!Period.y) || (Pmax.y - y - 0.5*Delta > 0)) && ((!Period.z) || (Pmax.z - z - 0.5*Delta > 0)))){
# 529 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
 fwrite (&((double *) ((((Tree *)grid)->L[point.level]->m[point.i+ai][point.j+aj] [point.k+ak]) + sizeof(Cell)))[(v.x.i)], sizeof (double), 1, fp);
            fwrite (&((double *) ((((Tree *)grid)->L[point.level]->m[point.i+ai][point.j+aj] [point.k+ak]) + sizeof(Cell)))[(v.y.i)], sizeof (double), 1, fp);
            fwrite (&((double *) ((((Tree *)grid)->L[point.level]->m[point.i+ai][point.j+aj] [point.k+ak]) + sizeof(Cell)))[(v.z.i)], sizeof (double), 1, fp);

          }
        } } } } }; }
    }
  }

  block_len=no_cells*8*18;
  if (fvlist) for (vector v = *fvlist, *_i129 = fvlist; ((scalar *)&v)->i >= 0; v = *++_i129) {
    fwrite (&block_len, sizeof (unsigned long long), 1, fp);
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 541 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
{
      if ((((!Period.x) || (Pmax.x - x - 0.5*Delta > 0)) && ((!Period.y) || (Pmax.y - y - 0.5*Delta > 0)) && ((!Period.z) || (Pmax.z - z - 0.5*Delta > 0)))){
# 556 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
 double arr[18]={ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)],
                                   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)],
                                   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(v.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1] [point.k+0]) + sizeof(Cell)))[(v.z.i)],
                                   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(v.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(v.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(v.z.i)],
                                   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(v.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+-1]) + sizeof(Cell)))[(v.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(v.z.i)],
                                   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(v.x.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(v.y.i)], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(v.z.i)]
                                };

        fwrite (&arr, 18*sizeof(double), 1, fp);
      }
    } } } } }; }
  }
  block_len=no_points*8*dim;
  fwrite (&block_len, sizeof (unsigned long long), 1, fp);
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->vertices.n; _k++) { point.i = ((Tree *)grid)->vertices.p[_k].i; point.j = ((Tree *)grid)->vertices.p[_k].j; point.k = ((Tree *)grid)->vertices.p[_k].k; point.level = ((Tree *)grid)->vertices.p[_k].level; _flags = ((Tree *)grid)->vertices.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { x -= Delta/2.; y -= Delta/2.; z -= Delta/2.;{
# 570 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
{
    if ((((!Period.x) || (Pmax.x - x - 0.5*Delta > 0)) && ((!Period.y) || (Pmax.y - y - 0.5*Delta > 0)) && ((!Period.z) || (Pmax.z - z - 0.5*Delta > 0)))){
      fwrite (&x, sizeof (double), 1, fp);
      fwrite (&y, sizeof (double), 1, fp);
      fwrite (&z, sizeof (double), 1, fp);
    }
  } } } } } }; }
  fputs ("\t\n", fp);
  fputs ("\t </AppendedData>\n", fp);
  fputs ("</VTKFile>\n", fp);
  fflush (fp);



 delete (((scalar []){marker,{-1}})); }

void output_pvd_file(FILE * fp, int nf, float * file_timesteps, char * subname){

    fputs ("<VTKFile type=\"Collection\" version=\"1.0\" byte_order=\"LittleEndian\" header_type=\"UInt64\">\n"
           "\t <Collection>\n", fp);
    for (int i=0; i<=nf; i++) {
        fprintf(fp, "\t\t<DataSet timestep=\"%g\" part=\"0\" file=\"res/%s_0_%4.4d.pvtu\"/>\n", file_timesteps[i], subname, i);
    }
    fputs ("\t </Collection>\n "
           "</VTKFile>\n", fp);
}



struct PVD_output {
    char * subname;
    double myt;
    scalar * list;
    vector * vlist;
    vector * fvlist;
};

struct stat st = {0};
static int iter_fp=0;
static float file_timesteps[9999];
void output_vtu_MPI(struct PVD_output o){
    scalar * list = o.list;
    vector * vlist = o.vlist;
    vector * fvlist = o.fvlist;
    char * subname = o.subname;
    double myt = o.myt;
    int nf = iter_fp;
    char name_vtu[80];
    if (iter_fp == 0) {
        if (stat("res", &st) == -1) {
            mkdir("res", 0755);
        }
    }
    FILE *fp;
    if (nf>9999) { fprintf(__stderrp, "too many files, more than 9999"); exit(1); }
    __builtin___sprintf_chk (name_vtu, 0, __builtin_object_size (name_vtu, 2 > 1 ? 1 : 0), "res/%s_%4.4d_n%3.3d.vtu", subname, nf, 0);
    fp = fopen(name_vtu, "w");
    output_vtu_bin_foreach(list, vlist, fvlist, 64, fp, 1);
    fclose(fp);
    if (0 == 0) {

        char name_pvtu[80], tmp[80];
     __builtin___sprintf_chk (name_pvtu, 0, __builtin_object_size (name_pvtu, 2 > 1 ? 1 : 0), "res/%s_0_%4.4d.pvtu", subname, nf);
        __builtin___sprintf_chk (tmp, 0, __builtin_object_size (tmp, 2 > 1 ? 1 : 0), "%s_%4.4d", subname, nf);
        fprintf(__stderrp, "+++vtk_file: %s, %s\n", name_pvtu, name_vtu);
        fp = fopen(name_pvtu, "w");
        output_pvtu_bin(list, vlist, fvlist, 64, fp, tmp);
        fclose(fp);

        char name_pvd[80];
        __builtin___sprintf_chk (name_pvd, 0, __builtin_object_size (name_pvd, 2 > 1 ? 1 : 0), "%s.pvd", subname);
        fp = fopen(name_pvd, "w");
        file_timesteps[nf] = myt;
        output_pvd_file(fp, nf, file_timesteps, subname);
        fclose(fp);
    }






    iter_fp++;
}


void face_vector2vector(vector fv, vector mapped_data_lower, vector mapped_data_upper){



     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 660 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"

    {
# 661 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
{
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mapped_data_lower.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fv.x.i)];
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mapped_data_upper.x.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0] [point.k+0]) + sizeof(Cell)))[(fv.x.i)];
    }
# 661 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
{
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mapped_data_lower.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fv.y.i)];
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mapped_data_upper.y.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1] [point.k+0]) + sizeof(Cell)))[(fv.y.i)];
    }
# 661 "/Users/weugene/basilisk/work/src_local/output_vtu_foreach.h"
{
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mapped_data_lower.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fv.z.i)];
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(mapped_data_upper.z.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+1]) + sizeof(Cell)))[(fv.z.i)];
    }} } } } }; }
}
# 31 "tube_bp_rel.c"
# 1 "./maxruntime.h"
# 1 "/Users/weugene/basilisk/src/maxruntime.h"
# 18 "/Users/weugene/basilisk/src/maxruntime.h"
static double _maxruntime = ((double)1e30);

static int runtime_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i += 10); *ip = i; *tp = t; return ret; } static int runtime (const int i, const double t, Event * _ev) { ; {
                                              ;
  if (perf.t >= _maxruntime - 300) {
    dump ((struct Dump){.file = "restart"});
    { int _ret = 1; ; return _ret; }
  }
                                                                     ; } return 0; }

void maxruntime (int * argc, char * argv[])
{
  for (int i = 0; i < *argc; i++)
    if (!strcmp (argv[i], "--maxruntime") || !strcmp (argv[i], "-m")) {
      if (i + 1 < *argc) {
 char * s = strtok (argv[i + 1], ":");
 int n = 0;
 _maxruntime = 0;
 do {
   _maxruntime = 60*_maxruntime + atoi(s);
   n++;
 } while ((s = strtok (((void*)0), ":")));
 if (n > 3) {
   fprintf (__stderrp, "maxruntime: TIME format must be H:M:S\n");
   exit (1);
 }
      }
      else {
 fprintf (__stderrp, "usage: %s TIME\n", argv[i]);
 exit (1);
      }
      *argc -= 2;
      for (int j = i; j < *argc; j++)
 argv[j] = argv[j + 2];
    }
}
# 32 "tube_bp_rel.c"
# 1 "./tag.h"
# 1 "/Users/weugene/basilisk/src/tag.h"
# 13 "/Users/weugene/basilisk/src/tag.h"
static void restriction_tag (Point point, scalar t)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); int kg = 0; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 14 "/Users/weugene/basilisk/src/tag.h"

  double min = ((double)1e30);
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2, _k = 2*point.k - 2; point.level++; for (int _l = 0; _l < 2; _l++) { point.i = _i + _l; for (int _m = 0; _m < 2; _m++) { point.j = _j + _m; for (int _n = 0; _n < 2; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)] < min)
      min = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]; } } } point.i = (_i + 2)/2;point.j = (_j + 2)/2;point.k = (_k + 2)/2; point.level--;}; }
  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)] = min;
}







static long lookup_tag (Array * a, double tag)
{
  long len = a->len/sizeof(double);
  double * p = (double *) a->p;
  if (tag == p[0])
    return 0;
  if (tag == p[len - 1])
    return len - 1;

  long s = 0, e = len - 1;
  while (s < e - 1) {
    long m = (s + e)/2;
    if (p[m] <= tag)
      s = m;
    else
      e = m;
  }
  return s;
}
# 61 "/Users/weugene/basilisk/src/tag.h"

int tag (scalar t)
{ ;




  _attribute[t.i].restriction = restriction_tag;

  _attribute[t.i].refine = _attribute[t.i].prolongation = refine_injection;
# 86 "/Users/weugene/basilisk/src/tag.h"
 long i = 1;
   { { Point root = {2,2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 87 "/Users/weugene/basilisk/src/tag.h"

    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) {
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)] != 0)*i++;
      continue;
    } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }

  boundary (((scalar []){t,{-1}}));





  _Bool changed;
  do {






    restriction (((scalar []){t,{-1}}));





    changed = 0;
    for (int l = 1; l <= grid->maxdepth; l++) {






       { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 121 "/Users/weugene/basilisk/src/tag.h"

 if (((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+0][(point.k+2)/2+0]) + sizeof(Cell)))[(t.i)])
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)] = ((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+0][(point.k+2)/2+0]) + sizeof(Cell)))[(t.i)]; } } } }; }}; }
      boundary_level (((scalar []){t,{-1}}), l);







       {


                  {
double _changed = changed;
# 132 "/Users/weugene/basilisk/src/tag.h"
{ if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; point.k = _active.p[_k].k; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 132 "/Users/weugene/basilisk/src/tag.h"

        if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]) {
   double min = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)];
    { { int _nn = 1 + 0 ? 1 + 0 : 2; int _i = point.i, _j = point.j, _k = point.k; for (int _l = - _nn; _l <= _nn; _l++) { point.i = _i + _l; for (int _m = - _nn; _m <= _nn; _m++) { point.j = _j + _m; for (int _n = - _nn; _n <= _nn; _n++) { point.k = _k + _n; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
     if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)] < min)
       min = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]; } } } point.i = _i; point.j = _j; point.k = _k;}; }






   {
# 144 "/Users/weugene/basilisk/src/tag.h"

     for (int i = -1; i <= 2; i += 3)
       if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+(2*i - 1)/3][point.j+0] [point.k+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+(2*i - 1)/3][point.j+0] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+(2*i - 1)/3][point.j+0] [point.k+0])))).pid >= 0))
  for (int j = 0; j <= 1; j++)
    for (int k = 0; k <= 1; k++)
      if (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +i] [2*point.j-2 +j][2*point.k-2 +k]) + sizeof(Cell)))[(t.i)] && ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +i] [2*point.j-2 +j][2*point.k-2 +k]) + sizeof(Cell)))[(t.i)] < min)
        min = ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +i] [2*point.j-2 +j][2*point.k-2 +k]) + sizeof(Cell)))[(t.i)];
# 144 "/Users/weugene/basilisk/src/tag.h"

     for (int i = -1; i <= 2; i += 3)
       if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+(2*i - 1)/3] [point.k+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+(2*i - 1)/3] [point.k+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+(2*i - 1)/3] [point.k+0])))).pid >= 0))
  for (int j = 0; j <= 1; j++)
    for (int k = 0; k <= 1; k++)
      if (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +k] [2*point.j-2 +i][2*point.k-2 +j]) + sizeof(Cell)))[(t.i)] && ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +k] [2*point.j-2 +i][2*point.k-2 +j]) + sizeof(Cell)))[(t.i)] < min)
        min = ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +k] [2*point.j-2 +i][2*point.k-2 +j]) + sizeof(Cell)))[(t.i)];
# 144 "/Users/weugene/basilisk/src/tag.h"

     for (int i = -1; i <= 2; i += 3)
       if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+(2*i - 1)/3]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+(2*i - 1)/3])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+(2*i - 1)/3])))).pid >= 0))
  for (int j = 0; j <= 1; j++)
    for (int k = 0; k <= 1; k++)
      if (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +j] [2*point.j-2 +k][2*point.k-2 +i]) + sizeof(Cell)))[(t.i)] && ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +j] [2*point.j-2 +k][2*point.k-2 +i]) + sizeof(Cell)))[(t.i)] < min)
        min = ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +j] [2*point.j-2 +k][2*point.k-2 +i]) + sizeof(Cell)))[(t.i)];}


   if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)] != min) {
     _changed = 1;
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)] = min;
   }
 } } } } }; }}; if (_changed > changed) changed = _changed;
                                        ;



}
# 157 "/Users/weugene/basilisk/src/tag.h"
 }
      boundary_level (((scalar []){t,{-1}}), l);
    }
  } while (changed);
# 171 "/Users/weugene/basilisk/src/tag.h"
 Array * a = array_new();
   { { Point root = {2,2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) { if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & active) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0)) {{
# 172 "/Users/weugene/basilisk/src/tag.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)] > 0) {







      double tag = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)], * ap = (double *) a->p;
      long s = -1;
      if (a->len == 0 || tag > ap[a->len/sizeof(double) - 1])
 s = a->len/sizeof(double);
      else if (tag < ap[0])
 s = 0;
      else {






 s = lookup_tag (a, tag) + 1;
 if (tag == ap[s - 1] || tag == ap[s])
   s = -1;
      }
      if (s >= 0) {





 array_append (a, &tag, sizeof(double)), ap = (double *) a->p;
 for (int i = a->len/sizeof(double) - 1; i > s; i--)
   ap[i] = ap[i-1];
 ap[s] = tag;
      }
    } } } continue; } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
# 259 "/Users/weugene/basilisk/src/tag.h"
 { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 259 "/Users/weugene/basilisk/src/tag.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)] > 0)
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)] = lookup_tag (a, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(t.i)]) + 1; } } } }; }
  boundary (((scalar []){t,{-1}}));




  int n = a->len/sizeof(double);
  array_free (a);
  { int _ret = n; ; return _ret; }
                                                           ; }
# 279 "/Users/weugene/basilisk/src/tag.h"
struct RemoveDroplets {
  scalar f;
  int minsize;
  double threshold;
  _Bool bubbles;
};

void remove_droplets (struct RemoveDroplets p)
{
  scalar d= new_scalar("d"), f = p.f;
  double threshold = p.threshold ? p.threshold : 1e-4;
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 290 "/Users/weugene/basilisk/src/tag.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(d.i)] = (p.bubbles ? 1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]) > threshold; } } } }; }
  int n = tag (d), size[n];
  for (int i = 0; i < n; i++)
    size[i] = 0;
   { { Point root = {2,2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) { if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & active) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0)) {{
# 295 "/Users/weugene/basilisk/src/tag.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(d.i)] > 0)
      size[((int) ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(d.i)]) - 1]++; } } continue; } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }



  int minsize = pow (p.minsize ? p.minsize : 3, 3);
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 302 "/Users/weugene/basilisk/src/tag.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(d.i)] > 0 && size[((int) ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(d.i)]) - 1] < minsize)
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] = p.bubbles; } } } }; }
  boundary (((scalar []){f,{-1}}));
 delete (((scalar []){d,{-1}})); }
# 33 "tube_bp_rel.c"





double Vd, Vdst, deq, dst = 0.2, rst = 0.1, r_bub, l_bub;
double RhoR, MuR;
double Rho1, Rho2;
double Mu1, Mu2;
double Sigma;
double diam_tube;
double dt_vtk;
double lDomain;
int bubcase;

typedef struct {
    double Ca;
    double Vd;
    double Uc;
    double Ud;
    double delta;
} Cases;


Cases cases[26]={
        {0,0,0,0,0},
        {0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},
        {6.44e-4, 0.0349e-9, 0.0454, 0.0533, 0.1055},
        {8.42e-4, 0.0439e-9, 0.0593, 0.0697, 0.074},
        {7.34e-4, 0.0602e-9, 0.0557, 0.0607, 0.027},
        {6.64e-4, 0.0745e-9, 0.0534, 0.0550, 0.001},
        {6.697e-4, 0.1893e-9, 0.0543, 0.0554, 0.006},
        {0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},
        {0.003, 0.1751e-9, 0.242, 0.261, 0.013},
        {0.008, 0.1715e-9, 0.666, 0.704, 0.023},
        {0.0098, 0.2208e-9, 0.757, 0.815, 0.025},
        {0.015, 0.1882e-9, 1.118 , 1.293, 0.039},
        {0.0230, 0.2179e-9, 1.580, 1.944, 0.054},
        {0.0306, 0.2179e-9, 2.060, 2.511, 1e-9},
        {0.0386, 0.2179e-9, 2.575, 3.165, 1e-9},
        {0.0463, 0.2179e-9, 3.09, 3.8, 1e-9}
};

double Ca;
double Ca_mod;
double Re;
double G;
double Umean, UMEAN;
double x_init = 2;
int maxlevel = 8;
int minlevel = 5;
int LEVEL = 7;
int adapt_method = 0;
int snapshot_i = 100;
double fseps = 1e-3, ueps = 1e-2;
double TOLERANCE_P = 1e-5, TOLERANCE_V = 1e-5;
_Bool ellipse_shape = 0, cylinder_shape = 1;
double Ubmean = 0, dUbmean = 0;


vector define_v (void) {
  double vx = -Ubmean, vy = 0, vz = 0;
  vector v= new_const_vector("v", 12, (double []) {vx, vy, vz});
  return v;
}


int main (int argc, char * argv[]) { _init_solver();
    fprintf(__stderrp, "./a.out maxlevel bubcase adapt_method iter_fp lDomain dt_vtk snapshot_i\n");

    eta_s = 1e-5;
    TOLERANCE = 1e-6;
    NITERMIN = 1;
    NITERMAX = 100;
    DT = 1e-4;
    cylinder_shape = 1;


    _attribute[fs.i].refine = _attribute[fs.i].prolongation = fraction_refine;
    _attribute[f.i].refine = _attribute[f.i].prolongation = fraction_refine;
    bubcase = 22;

    if (argc > 1)
        maxlevel = atoi (argv[1]);
    if (argc > 2)
        bubcase = atoi (argv[2]);

    if ((bubcase >= 8 && bubcase <= 12) || bubcase >= 18) {
        Rho1 = 997, Rho2 = 1.204;
        Mu1 = 0.88e-3, Mu2 = 0.019e-3;
        Sigma = 72.8e-6;
        diam_tube = 514e-6;
        dt_vtk = 1e-1;
        lDomain = 12;
    }else {
        Rho1 = 1250, Rho2 = 1.204;
        Mu1 = 550e-3, Mu2 = 0.019e-3;
        Sigma = 63.4e-3;
        diam_tube = 494e-6;
        dt_vtk = 1e-2;
        lDomain = 12;
    }
    Ca = cases[bubcase].Ca;
    Vd = cases[bubcase].Vd;
    UMEAN = cases[bubcase].Uc;

    if (argc > 3)
        adapt_method = atoi (argv[3]);
    if (argc > 4)
        iter_fp = atoi (argv[4]);
    if (argc > 5)
        lDomain = atof (argv[5]);
    if (argc > 6)
        dt_vtk = atof (argv[6]);
    if (argc > 7)
        snapshot_i = atoi (argv[7]);

    size (lDomain);
    tree_periodic(top);
    tree_periodic(front);
    origin ((struct _origin){0., -L0/2., -L0/2.});
    init_grid (1 << LEVEL);

    deq = pow(6.0*Vd/3.14159265358979, 1./3.);
    dst = deq/diam_tube;
    rst = 0.5*dst;
    Vdst = (4./3.)*3.14159265358979*((rst)*(rst)*(rst));

    Ca_mod = Mu1*UMEAN/Sigma;
    Re = UMEAN*diam_tube*Rho1/Mu1;
    G = 32.0*Mu1*UMEAN/((diam_tube)*(diam_tube));

    if (ellipse_shape || dst < 0.9) {
        r_bub = ((rst) < (0.4) ? (rst) : (0.4));
        l_bub = ((rst)*(rst)*(rst)) / ((r_bub)*(r_bub));
        ellipse_shape = 1;
        cylinder_shape = 0;
    }else if (cylinder_shape){
        r_bub = 0.45;
        l_bub = (Vdst - (4./3.)*3.14159265358979*((r_bub)*(r_bub)*(r_bub)))/(3.14159265358979*((r_bub)*(r_bub)));
    } else{
        (__builtin_expect(!(0 && "set shape"), 0) ? __assert_rtn(__func__, "tube_bp_rel.c", 174, "false && \"set shape\"") : (void)0);
    }
    x_init = 2.5*l_bub;

    fprintf(__stderrp,"BP:             eta_s=%g,     DT=%g\n"
                 "Solver:         NITERMIN=%d   NITERMAX=%d      TOLERANCE=%g  relative_residual_poisson=%d relative_residual_viscous=%d\n"
                 "OUTPUT:         dt_vtk=%g number of procs=%d\n"
                 "ADAPT:          minlevel=%d,  maxlevel=%d      adapt_meth=%d fseps=%g ueps=%g\n"
                 "Bubble case: %d\n"
                 "Properties(SI): Mu1=%g Mu2=%g Rho1=%g Rho2=%g  Sigma=%g G=%g UMEAN=%g\n"
                 "Apparatus:      diam_tube=%g  tube_length=%g\n"
                 "Bubble:         Vd=%g deq=%g  ellipse_shape=%d cylinder_shape=%d\n",
                 eta_s, DT,
                 NITERMIN, NITERMAX, TOLERANCE, relative_residual_poisson, relative_residual_viscous,
                 dt_vtk, 1,
                 minlevel, maxlevel, adapt_method, fseps, ueps,
                 bubcase,
                 Mu1, Mu2, Rho1, Rho2, Sigma, G, UMEAN,
                 diam_tube, L0,
                 Vd, deq, ellipse_shape, cylinder_shape);


    G /= Rho1*((UMEAN)*(UMEAN))/diam_tube;
    Umean = 1;
    diam_tube /= diam_tube;
    RhoR = Rho1/Rho2;
    MuR = Mu1/Mu2;

    rho1 = 1.;
    rho2 = 1./RhoR;
    mu1 = 1./Re;
    mu2 = 1./(MuR*Re);
    _attribute[f.i].sigma = 1./(Re*Ca_mod);
    fprintf(__stderrp,"Dimensionless Parameters: mu1=%g mu2=%g rho1=%g rho2=%g sigma=%g G=%g  Umean=%g\n"
                 "Dimensionless nums:       Re=%g  Ca=%g  Ca_mod=%g\n"
                 "Bubble:                   Vdst=%g dst=%g  rst=%g  r_bub=%g l_bub_cyl=%g l_bub=%g x_init=%g\n",
            mu1, mu2, rho1, rho2, _attribute[f.i].sigma, G, Umean,
            Re, Ca, Ca_mod,
            Vdst, dst, rst, r_bub, l_bub, (ellipse_shape || dst < 0.9) ? l_bub : l_bub + 2*r_bub, x_init);
# 223 "tube_bp_rel.c"
 target_U = target_Uv;
    run();
 free_solver(); }



static void _set_boundary6 (void) { _attribute[u.x.i].boundary[left] = _boundary6; _attribute[u.x.i].boundary_homogeneous[left] = _boundary6_homogeneous; }


static void _set_boundary7 (void) { _attribute[p.i].boundary[left] = _boundary7; _attribute[p.i].boundary_homogeneous[left] = _boundary7_homogeneous; }
static void _set_boundary8 (void) { _attribute[pf.i].boundary[left] = _boundary8; _attribute[pf.i].boundary_homogeneous[left] = _boundary8_homogeneous; }
static void _set_boundary9 (void) { _attribute[f.i].boundary[left] = _boundary9; _attribute[f.i].boundary_homogeneous[left] = _boundary9_homogeneous; }
static void _set_boundary10 (void) { _attribute[fs.i].boundary[left] = _boundary10; _attribute[fs.i].boundary_homogeneous[left] = _boundary10_homogeneous; }



static void _set_boundary11 (void) { _attribute[u.x.i].boundary[right] = _boundary11; _attribute[u.x.i].boundary_homogeneous[right] = _boundary11_homogeneous; }
static void _set_boundary12 (void) { _attribute[u.z.i].boundary[right] = _boundary12; _attribute[u.z.i].boundary_homogeneous[right] = _boundary12_homogeneous; }
static void _set_boundary13 (void) { _attribute[u.y.i].boundary[right] = _boundary13; _attribute[u.y.i].boundary_homogeneous[right] = _boundary13_homogeneous; }
static void _set_boundary14 (void) { _attribute[p.i].boundary[right] = _boundary14; _attribute[p.i].boundary_homogeneous[right] = _boundary14_homogeneous; }
static void _set_boundary15 (void) { _attribute[pf.i].boundary[right] = _boundary15; _attribute[pf.i].boundary_homogeneous[right] = _boundary15_homogeneous; }


static void _set_boundary16 (void) { _attribute[f.i].boundary[right] = _boundary16; _attribute[f.i].boundary_homogeneous[right] = _boundary16_homogeneous; }
static void _set_boundary17 (void) { _attribute[fs.i].boundary[right] = _boundary17; _attribute[fs.i].boundary_homogeneous[right] = _boundary17_homogeneous; }
# 268 "tube_bp_rel.c"
void geometry(scalar fs)
{

    scalar phi= new_vertex_scalar("phi");
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->vertices.n; _k++) { point.i = ((Tree *)grid)->vertices.p[_k].i; point.j = ((Tree *)grid)->vertices.p[_k].j; point.k = ((Tree *)grid)->vertices.p[_k].k; point.level = ((Tree *)grid)->vertices.p[_k].level; _flags = ((Tree *)grid)->vertices.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { x -= Delta/2.; y -= Delta/2.; z -= Delta/2.;{
# 272 "tube_bp_rel.c"
 {
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] = ((y)*(y)) + ((z)*(z)) - ((0.5)*(0.5));
    } } } } } }; }
    boundary (((scalar []){phi,{-1}}));
    fractions ((struct Fractions){phi, fs});
 delete (((scalar []){phi,{-1}})); }

void bubble(scalar f)
{
    scalar phi= new_vertex_scalar("phi");
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->vertices.n; _k++) { point.i = ((Tree *)grid)->vertices.p[_k].i; point.j = ((Tree *)grid)->vertices.p[_k].j; point.k = ((Tree *)grid)->vertices.p[_k].k; point.level = ((Tree *)grid)->vertices.p[_k].level; _flags = ((Tree *)grid)->vertices.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; { x -= Delta/2.; y -= Delta/2.; z -= Delta/2.;{
# 282 "tube_bp_rel.c"
 {
        if (ellipse_shape)
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] = (((x - x_init)/l_bub)*((x - x_init)/l_bub)) + ((y/r_bub)*(y/r_bub)) + ((z/r_bub)*(z/r_bub)) - ((1)*(1));
        else if (cylinder_shape)
        {
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] = ((0.5*l_bub - fabs(x - x_init)) < (((r_bub)*(r_bub)) - ((y)*(y)) - ((z)*(z))) ? (0.5*l_bub - fabs(x - x_init)) : (((r_bub)*(r_bub)) - ((y)*(y)) - ((z)*(z))));
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)]) > (((r_bub)*(r_bub)) - ((fabs(x - x_init) - 0.5*l_bub)*(fabs(x - x_init) - 0.5*l_bub)) - ((y)*(y)) - ((z)*(z))) ? (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)]) : (((r_bub)*(r_bub)) - ((fabs(x - x_init) - 0.5*l_bub)*(fabs(x - x_init) - 0.5*l_bub)) - ((y)*(y)) - ((z)*(z))));
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(phi.i)] *= -1;
        }
    } } } } } }; }
    boundary (((scalar []){phi,{-1}}));
    fractions ((struct Fractions){phi, f});
 delete (((scalar []){phi,{-1}})); }

int maXlevel(double x,double y, double z){
    double x0 = fabs(x - x_init - Umean*t);
    int n = ceil(((0) > (0.5*(x0/l_bub - 3)) ? (0) : (0.5*(x0/l_bub - 3))));
    return ((maxlevel-n) > (10) ? (maxlevel-n) : (10));
}




static int init_0_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (t = 0); *ip = i; *tp = t; return ret; } static int init_0 (const int i, const double t, Event * _ev) { ; {
    if (!restore ((struct Dump){.file = "restart"})) {
        int it = 1;
        astats s;
        do {
            fprintf(__stderrp, "iteration=%d\n", it);
            count_cells(t, i);
            geometry(fs);
            bubble(f);
             { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 314 "tube_bp_rel.c"
 {
                ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] = (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(2.*(1. - 4*((y)*(y)) - 4*((z)*(z))));
                ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] = 0;
                ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] = 0;
            } } } } }; }
            Ubmean = 0;
            boundary((scalar *)((vector []){{u.x,u.y,u.z},{{-1},{-1},{-1}}}));
            if (adapt_method == 0)
                s = adapt_wavelet((struct Adapt){(scalar *) ((scalar []){f,fs,u.x,{-1}}), (double[]) {fseps, fseps, ueps}, maxlevel, minlevel});
            else if (adapt_method == 1)
                s = adapt_wavelet_limited((struct Adapt_limited){(scalar *) ((scalar []){f,fs,u.x,{-1}}), (double []) {fseps, fseps, ueps}, maXlevel, minlevel});
            else if (adapt_method == 2)
                s = adapt_wavelet2((struct Adapt2){(scalar *) ((scalar []){f,fs,u.x,{-1}}), (double[]) {fseps, fseps, ueps}, (int[]) {maxlevel, maxlevel, maxlevel-2}, minlevel});
            fprintf(__stderrp, "Adaptation: nf=%d nc=%d\n", s.nf, s.nc);
            if (s.nf == 0 || it > 5) break;
            it++;
        } while(1);
        fprintf(__stderrp, "In frame of the bubble reference\n");
        double volumeg = 0, dvr;
         {


                  {
double _Ubmean = Ubmean; double _volumeg = volumeg;
# 333 "tube_bp_rel.c"

if (!((cm).i >= 65536)) {
# 333 "tube_bp_rel.c"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 333 "tube_bp_rel.c"
{
            dvr = (((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)])*(1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]);
            _volumeg += dvr;
            _Ubmean += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]*dvr;
        } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 333 "tube_bp_rel.c"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 333 "tube_bp_rel.c"
{
            dvr = (((Delta)*(Delta)*(Delta))*_const_cm)*(1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]);
            _volumeg += dvr;
            _Ubmean += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]*dvr;
        } } } } }; } Ubmean += _Ubmean;
                                       ;
                  volumeg += _volumeg;
                                        ;



}
# 337 "tube_bp_rel.c"
 }
        Ubmean /= volumeg;
         { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 339 "tube_bp_rel.c"
 {
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] -= Ubmean;
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)] = 0;
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)] = 0;
        } } } } }; }
        target_Uv = define_v();
        boundary((scalar *)((vector []){{u.x,u.y,u.z},{{-1},{-1},{-1}}}));
        target_U = target_Uv;
        event("vtk_file");
    }else{
        stats s;
        double volumes = 0, volumeg = 0, dvs, dvg;
         {


                  {
double _Ubmean = Ubmean; double _dUbmean = dUbmean; double _volumes = volumes; double _volumeg = volumeg;
# 351 "tube_bp_rel.c"

if (!((cm).i >= 65536)) {
# 351 "tube_bp_rel.c"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 352 "tube_bp_rel.c"
{
            dvs = (((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)];
            dvg = (((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)])*(1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]);
            _volumes += dvs;
            _volumeg += dvg;
            _Ubmean += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]*dvs;
            _dUbmean += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]*dvg;
        } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 351 "tube_bp_rel.c"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 352 "tube_bp_rel.c"
{
            dvs = (((Delta)*(Delta)*(Delta))*_const_cm)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)];
            dvg = (((Delta)*(Delta)*(Delta))*_const_cm)*(1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]);
            _volumes += dvs;
            _volumeg += dvg;
            _Ubmean += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]*dvs;
            _dUbmean += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]*dvg;
        } } } } }; } Ubmean += _Ubmean;
                                       ;
                  dUbmean += _dUbmean;
                                        ;
                  volumes += _volumes;
                                        ;
                  volumeg += _volumeg;
                                        ;



}
# 359 "tube_bp_rel.c"
 }
        Ubmean /= volumes;
        dUbmean /= volumeg;
        Ubmean -= dUbmean;
         { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 363 "tube_bp_rel.c"
 {
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] -= dUbmean;
        } } } } }; };
        target_Uv = define_v();
        boundary((scalar *)((vector []){{u.x,u.y,u.z},{{-1},{-1},{-1}}}));
        target_U = target_Uv;
        fprintf(__stderrp, "file is read\n");
    }
    fprintf(__stderrp, "Ubmean=%g dUbmean=%g", Ubmean, dUbmean);
                                          ; } return 0; }
static int advection_term_0_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int advection_term_0 (const int i, const double t, Event * _ev) { ; {
    TOLERANCE = TOLERANCE_P;
                                                    ; } return 0; }

static int viscous_term_0_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int viscous_term_0 (const int i, const double t, Event * _ev) { ; {
    TOLERANCE = TOLERANCE_V;
                                                  ; } return 0; }

static int projection_0_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int projection_0 (const int i, const double t, Event * _ev) { ; {
    TOLERANCE = TOLERANCE_P;
                                                ; } return 0; }
# 394 "tube_bp_rel.c"
static int end_timestep_0_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int end_timestep_0 (const int i, const double t, Event * _ev) { ; {
    dUbmean = 0;
    double volumeg = 0, dvg;

     {


                  {
double _dUbmean = dUbmean; double _volumeg = volumeg;
# 398 "tube_bp_rel.c"

if (!((cm).i >= 65536)) {
# 398 "tube_bp_rel.c"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 398 "tube_bp_rel.c"
 {
        dvg = (((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)])*(1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]);
        _volumeg += dvg;
        _dUbmean += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]*dvg;
    } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 398 "tube_bp_rel.c"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 398 "tube_bp_rel.c"
 {
        dvg = (((Delta)*(Delta)*(Delta))*_const_cm)*(1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]);
        _volumeg += dvg;
        _dUbmean += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]*dvg;
    } } } } }; } dUbmean += _dUbmean;
                                        ;
                  volumeg += _volumeg;
                                        ;



}
# 402 "tube_bp_rel.c"
 }
    dUbmean /=volumeg;
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 404 "tube_bp_rel.c"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)] -= dUbmean; } } } }; }
    Ubmean -= dUbmean;
    boundary((scalar *)((vector []){{u.x,u.y,u.z},{{-1},{-1},{-1}}}));
    target_Uv = define_v();
    target_U = target_Uv;
    fprintf(__stderrp, "Ubmean=%g dUbmean=%g\n", Ubmean, dUbmean);
                                                  ; } return 0; }
# 419 "tube_bp_rel.c"
static int logfile_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i +=1); *ip = i; *tp = t; return ret; } static int logfile (const int i, const double t, Event * _ev) { ;
{
    double x_mean = 0, velamean = 0, dvtmp, delta_min=1e+9, delta_mean=0, delta_max=-1e+9, r, r_min=1e+9;
    double x_min = 1e+9, x_max = -1e+9, length = 0, volume_clip = 0, volumeg = 0, f_p_min;
    double vel_bubx=0, vel_buby=0, vel_bubz=0;
    coord p_min, coord_tail;



    scalar m= new_scalar("m");
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 429 "tube_bp_rel.c"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(m.i)] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] < 0.999; } } } }; }
    int n = tag (m);







    double v[n];
    coord b[n];
    for (int j = 0; j < n; j++)
        v[j] = b[j].x = b[j].y = b[j].z = 0.;
    double vol_sum = 0;
     {
if (!((cm).i >= 65536)) {
# 443 "tube_bp_rel.c"
{ Point root = {2,2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) { if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & active) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0)) {{
# 443 "tube_bp_rel.c"

        if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(m.i)] > 0) {
            int j = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(m.i)] - 1;
            v[j] += (((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)];
            vol_sum += v[j];
            coord p = {x,y,z};
            {
# 449 "tube_bp_rel.c"

                b[j].x += (((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]*p.x;
# 449 "tube_bp_rel.c"

                b[j].y += (((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]*p.y;
# 449 "tube_bp_rel.c"

                b[j].z += (((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]*p.z;}
        } } } continue; } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 443 "tube_bp_rel.c"
{ Point root = {2,2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point = {0}; int kg = 0; (void)(kg); struct { int l, i, j, k, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].k = root.k; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; point.k = stack[_s].k; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] && point.k+0 >= 0 && point.k+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;; if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & leaf)) { if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).flags & active) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]))))).pid == 0)) {{
# 443 "tube_bp_rel.c"

        if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(m.i)] > 0) {
            int j = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(m.i)] - 1;
            v[j] += (((Delta)*(Delta)*(Delta))*_const_cm)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)];
            vol_sum += v[j];
            coord p = {x,y,z};
            {
# 449 "tube_bp_rel.c"

                b[j].x += (((Delta)*(Delta)*(Delta))*_const_cm)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]*p.x;
# 449 "tube_bp_rel.c"

                b[j].y += (((Delta)*(Delta)*(Delta))*_const_cm)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]*p.y;
# 449 "tube_bp_rel.c"

                b[j].z += (((Delta)*(Delta)*(Delta))*_const_cm)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]*p.z;}
        } } } continue; } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 4; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 4: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 5; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 5: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 6; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; case 6: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].k = point.k; stack[_s].stage = 7; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = (2*point.k - 2); stack[_s].stage = 0; }; break; case 7: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].k = ((2*point.k - 2) + 1); stack[_s].stage = 0; }; break; } } } }; } }
# 464 "tube_bp_rel.c"
 int i_vol_max;
    double vol_max=-1e+9;
    for (int j = 0; j < n; j++){
        if (v[j] > vol_max) {
            vol_max = v[j];
            i_vol_max = j;
        }
        fprintf (__stdoutp, "statistics: %d %g %d %g %g %g\n",
        i, t, j, v[j], b[j].x/v[j], b[j].y/v[j]);
    }
    fprintf(__stderrp, "i_vol_max= %d vol_max= %g\n", i_vol_max, vol_max);
     {


                  {
double _x_mean = x_mean; double _volumeg = volumeg; double _vel_bubx = vel_bubx; double _vel_buby = vel_buby; double _vel_bubz = vel_bubz; double _delta_min = delta_min; double _x_min = x_min; double _x_max = x_max;
# 475 "tube_bp_rel.c"

if (!((cm).i >= 65536)) {
# 475 "tube_bp_rel.c"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 477 "tube_bp_rel.c"
 {
        if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)]<1 && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(m.i)] == 1 + i_vol_max){
            dvtmp = (1.0 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)])*(1.0 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)]);
            _volumeg += dvtmp;
            _x_mean += x*dvtmp;
            _vel_bubx += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]*dvtmp; _vel_buby += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]*dvtmp; _vel_bubz += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]*dvtmp;
            if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] > 0 && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] < 1) {
                r = sqrt(((y)*(y)) + ((z)*(z))) + Delta*(0.5 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]);
                if (0.5 - r < _delta_min) {
                    p_min.x = x;
                    p_min.y = y;
                    p_min.z = z;
                    f_p_min = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)];
                    _delta_min = 0.5 - r;
                }
                if (x < _x_min) _x_min = x;
                if (x > _x_max) _x_max = x;
            }
        }
    } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 475 "tube_bp_rel.c"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 477 "tube_bp_rel.c"
 {
        if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)]<1 && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(m.i)] == 1 + i_vol_max){
            dvtmp = (1.0 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)])*(1.0 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)])*(((Delta)*(Delta)*(Delta))*_const_cm);
            _volumeg += dvtmp;
            _x_mean += x*dvtmp;
            _vel_bubx += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.x.i)]*dvtmp; _vel_buby += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.y.i)]*dvtmp; _vel_bubz += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(u.z.i)]*dvtmp;
            if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] > 0 && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] < 1) {
                r = sqrt(((y)*(y)) + ((z)*(z))) + Delta*(0.5 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]);
                if (0.5 - r < _delta_min) {
                    p_min.x = x;
                    p_min.y = y;
                    p_min.z = z;
                    f_p_min = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)];
                    _delta_min = 0.5 - r;
                }
                if (x < _x_min) _x_min = x;
                if (x > _x_max) _x_max = x;
            }
        }
    } } } } }; } x_mean += _x_mean;
                                       ;
                  volumeg += _volumeg;
                                        ;
                  vel_bubx += _vel_bubx;
                                         ;
                  vel_buby += _vel_buby;
                                         ;
                  vel_bubz += _vel_bubz;
                                         ;
                  if (_delta_min < delta_min) delta_min = _delta_min;
                                          ;
                  if (_x_min < x_min) x_min = _x_min;
                                      ;
                  if (_x_max > x_max) x_max = _x_max;
                                      ;



}
# 496 "tube_bp_rel.c"
 }
    vel_bubx /= volumeg; vel_buby /= volumeg; vel_bubz /= volumeg;
    x_mean /= volumeg; velamean = sqrt(((vel_bubx)*(vel_bubx)) + ((vel_buby)*(vel_buby)) + ((vel_bubz)*(vel_bubz))); length = x_max - x_min;

     {


                  {
double _volume_clip = volume_clip; double _delta_max = delta_max; double _r_min = r_min;
# 500 "tube_bp_rel.c"

if (!((cm).i >= 65536)) {
# 500 "tube_bp_rel.c"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 500 "tube_bp_rel.c"
 {
        if ( ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] < 1 && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(m.i)] == 1 + i_vol_max){
            if (x > p_min.x && x < x_mean && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(m.i)] == 1 + i_vol_max){
                _volume_clip += (1.0 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)])*(((Delta)*(Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(cm.i)]);
                if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] > 0 && 0.5 - r > _delta_max) {
                    r = sqrt(((y)*(y)) + ((z)*(z))) + Delta * (0.5 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]);
                    _delta_max = 0.5 - r;
                }
            }
            if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] > 0 && x < x_mean) {
                r = sqrt(((y)*(y)) + ((z)*(z)));
                if (r < _r_min) {
                    _r_min = r;
                    coord_tail.x = x;
                    coord_tail.y = y;
                    coord_tail.z = z;
                }
            }
        }
    } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 500 "tube_bp_rel.c"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 500 "tube_bp_rel.c"
 {
        if ( ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] < 1 && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(m.i)] == 1 + i_vol_max){
            if (x > p_min.x && x < x_mean && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(m.i)] == 1 + i_vol_max){
                _volume_clip += (1.0 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)])*(((Delta)*(Delta)*(Delta))*_const_cm);
                if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] > 0 && 0.5 - r > _delta_max) {
                    r = sqrt(((y)*(y)) + ((z)*(z))) + Delta * (0.5 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)]);
                    _delta_max = 0.5 - r;
                }
            }
            if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(f.i)] > 0 && x < x_mean) {
                r = sqrt(((y)*(y)) + ((z)*(z)));
                if (r < _r_min) {
                    _r_min = r;
                    coord_tail.x = x;
                    coord_tail.y = y;
                    coord_tail.z = z;
                }
            }
        }
    } } } } }; } volume_clip += _volume_clip;
                                            ;
                  if (_delta_max > delta_max) delta_max = _delta_max;
                                          ;
                  if (_r_min < r_min) r_min = _r_min;
                                      ;



}
# 519 "tube_bp_rel.c"
 }
    delta_mean = 0.5 - sqrt(volume_clip/(3.14159265358979*(x_mean - p_min.x)));
        fprintf (__stderrp, "maxlevel= %d i= %d t= %g dt= %g volumeg= %g volume_clip= %g vel_bub= %g %g %g velamean= %g vel_bubx/U0-1= %g\n"
                   "x_min= %g x_peak_max= %g %g %g coord_tail= %g %g %g x_mean= %g x_max= %g\n"
                   "delta_min= %g delta_mean(NOTE:x_mean_x_of_max_y)= %g delta_max= %g length= %g f_p_min(full_cell?)= %g it_fp= %d\n",
            maxlevel, i, t, dt, volumeg, volume_clip, vel_bubx, vel_buby, vel_bubz, velamean, (vel_bubx/Umean - 1),
            x_min, p_min.x, p_min.y, p_min.z, coord_tail.x, coord_tail.y, coord_tail.z, x_mean, x_max,
            delta_min, delta_mean, delta_max, x_max - x_min, f_p_min, iter_fp);
    fprintf(__stderrp, "Ca\tUflow_m_s\tU_meanVT\tU_meanVT_m_s\tdelta_minVT\tdelta_meanVT\tdelta_maxVT\tmaxlevel\tlDomain\tdx\tN_per_delta\n");
    double dx_min = lDomain/pow(2., maxlevel);
   fprintf(__stderrp, "%8.5g\t%8.5g\t%8.5g\t%8.5g\t%8.5g\t%8.5g\t%8.5g\t%8d\t%8.5g\t%8.5g\t%8.5g\n",
            mu1*vel_bubx/_attribute[f.i].sigma, UMEAN, vel_bubx, vel_bubx*UMEAN, delta_min, delta_mean, delta_max,
            maxlevel, lDomain, dx_min, delta_min/dx_min);
    if (i==0) fprintf(__stdoutp, "t\tx_tail\tx_peak\tr_peak\tx_mean\tx_nose\tx_nose_ISC\tvolume\tUmeanV\tdelta_min\tdelta_mean\tdelta_max\tdelta_min_smooth\tdelta_max_smooth\n");
    fprintf (__stdoutp, "%g\t%g\t%g\t%g\t%g\t%g\t%g\t%g\t%g\t%g\t%g\t%g\n",
    t, coord_tail.x, p_min.x, 0.5 - delta_min, x_mean, x_max, 0.0, volumeg, vel_bubx,
    delta_min, delta_mean, delta_max);
    fflush(__stdoutp);
 delete (((scalar []){m,{-1}})); ; } return 0; }


static int snapshot_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i += snapshot_i); *ip = i; *tp = t; return ret; } static int snapshot (const int i, const double t, Event * _ev) { ;

{
# 552 "tube_bp_rel.c"
 ; } return 0; }

static int snapshot_vtk_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i += 10000); *ip = i; *tp = t; return ret; } static int snapshot_vtk (const int i, const double t, Event * _ev) { ;
{



                                                ; } return 0; }


static int vtk_file_0_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i += 1); *ip = i; *tp = t; return ret; } static int vtk_file_0 (const int i, const double t, Event * _ev) { ;

{
    char subname[80]; __builtin___sprintf_chk (subname, 0, __builtin_object_size (subname, 2 > 1 ? 1 : 0), "tube_bp_rel");
    scalar l= new_scalar("l"); { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 566 "tube_bp_rel.c"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(l.i)] = level; } } } }; }
    scalar np= new_scalar("np"); { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {0}; point.i = 2; point.j = 2; point.k = 2; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.k = ((Tree *)grid)->leaves.p[_k].k; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;{
# 567 "tube_bp_rel.c"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(np.i)] = 0; } } } }; }
    scalar omega= new_scalar("omega"); vorticity (u, omega);
    scalar l2= new_scalar("l2"); lambda2 (u, l2);

    output_vtu_MPI((struct PVD_output){ subname, (iter_fp) ? t + dt : 0, (scalar *) ((scalar []){p,fs,f,np,l,omega,l2,{-1}}), (vector *) ((vector []){{u.x,u.y,u.z},{{-1},{-1},{-1}}})});


 delete (((scalar []){l2,omega,np,l,{-1}})); ; } return 0; }
# 584 "tube_bp_rel.c"
static int adapt_0_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int adapt_0 (const int i, const double t, Event * _ev) { ;
{
    double eps_arr[] = {fseps, ueps, ueps, ueps};
    fprintf(__stderrp, "beginning adapt\n");

    if (adapt_method == 0)
        adapt_wavelet ((struct Adapt){(scalar *) ((scalar []){f,u.x,u.y,u.z,{-1}}), (double []) {fseps, ueps, ueps, ueps}, .maxlevel = maxlevel, .minlevel = minlevel});
    else if (adapt_method == 1)

        adapt_wavelet_limited ((struct Adapt_limited){(scalar *) ((scalar []){f,u.x,u.y,u.z,{-1}}), (double []) {fseps, ueps, ueps, ueps}, maXlevel, minlevel});
    else if (adapt_method == 2)
        adapt_wavelet2((struct Adapt2){(scalar *)((scalar []){f,u.x,u.y,u.z,{-1}}), (double []) {fseps, ueps, ueps, ueps},(int []){maxlevel, maxlevel-1, maxlevel-2, maxlevel-2, maxlevel-2}, minlevel});

    fprintf(__stderrp, "ended adapt\n");
    count_cells(t, i);
    geometry(fs);
    double eps_arr2[] = {1, 1, 1, 1};
    if (i % 10 == 0 || i < 5) MinMaxValues (((scalar []){u.x,u.y,u.z,p,{-1}}), eps_arr2);
                                           ; } return 0; }

static int stop_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (t=L0/Umean); *ip = i; *tp = t; return ret; } static int stop (const int i, const double t, Event * _ev) { ; ; ; return 0; }
# 104 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
static double _boundary0 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 103 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 104 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(a.x.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(fm.x.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(alpha.x.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 104 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((_const_a.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(fm.x.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(alpha.x.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 124 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 104 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(a.x.i)]*_const_fm.x/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(alpha.x.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 126 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 104 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((_const_a.x*_const_fm.x/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(alpha.x.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 142 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 104 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(a.x.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(fm.x.i)]/_const_alpha.x)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 144 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 104 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((_const_a.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(fm.x.i)]/_const_alpha.x)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 124 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 144 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 104 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(a.x.i)]*_const_fm.x/_const_alpha.x)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 126 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 146 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 104 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((_const_a.x*_const_fm.x/_const_alpha.x)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); } return 0.; } static double _boundary0_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 103 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 104 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 104 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 124 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 104 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 126 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 104 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 142 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 104 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 144 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 104 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 124 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 144 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 104 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 126 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 146 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 104 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); } return 0.; }
# 105 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
static double _boundary1 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 104 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 105 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.x.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 105 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (_const_a.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 125 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 105 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.x.i)]*_const_fm.x/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 127 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 105 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (_const_a.x*_const_fm.x/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.x.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 143 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 105 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.x.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]/_const_alpha.x)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 145 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 105 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (_const_a.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.x.i)]/_const_alpha.x)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 125 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 145 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 105 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.x.i)]*_const_fm.x/_const_alpha.x)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 127 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 147 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 105 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (_const_a.x*_const_fm.x/_const_alpha.x)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); } return 0.; } static double _boundary1_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 104 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 105 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 105 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 125 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 105 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 127 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 105 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 143 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 105 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 145 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 105 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 125 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 145 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 105 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 127 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 147 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 105 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); } return 0.; }
# 114 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
static double _boundary2 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 113 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 114 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(a.y.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(fm.y.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(alpha.y.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 114 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((_const_a.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(fm.y.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(alpha.y.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 134 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 114 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(a.y.i)]*_const_fm.y/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(alpha.y.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 136 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 114 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((_const_a.y*_const_fm.y/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(alpha.y.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 152 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 114 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(a.y.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(fm.y.i)]/_const_alpha.y)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 154 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 114 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((_const_a.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(fm.y.i)]/_const_alpha.y)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 134 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 154 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 114 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(a.y.i)]*_const_fm.y/_const_alpha.y)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 136 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 156 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 114 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((_const_a.y*_const_fm.y/_const_alpha.y)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); } return 0.; } static double _boundary2_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 113 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 114 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 114 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 134 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 114 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 136 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 114 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 152 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 114 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 154 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 114 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 134 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 154 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 114 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 136 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 156 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 114 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); } return 0.; }
# 115 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
static double _boundary3 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 114 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 115 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.y.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 115 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (_const_a.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 135 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 115 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.y.i)]*_const_fm.y/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 137 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 115 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (_const_a.y*_const_fm.y/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.y.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 153 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 115 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.y.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]/_const_alpha.y)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 155 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 115 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (_const_a.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.y.i)]/_const_alpha.y)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 135 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 155 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 115 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.y.i)]*_const_fm.y/_const_alpha.y)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 137 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 157 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 115 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (_const_a.y*_const_fm.y/_const_alpha.y)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); } return 0.; } static double _boundary3_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 114 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 115 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 115 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 135 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 115 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 137 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 115 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 153 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 115 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 155 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 115 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 135 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 155 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 115 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 137 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 157 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 115 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); } return 0.; }
# 118 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
static double _boundary4 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 117 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 118 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(a.z.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(fm.z.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(alpha.z.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 118 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((_const_a.z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(fm.z.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(alpha.z.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 138 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 118 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(a.z.i)]*_const_fm.z/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(alpha.z.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 140 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 118 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((_const_a.z*_const_fm.z/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(alpha.z.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 156 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 118 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(a.z.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(fm.z.i)]/_const_alpha.z)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 158 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 118 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((_const_a.z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(fm.z.i)]/_const_alpha.z)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 138 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 158 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 118 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)] [point.k+(kg > 0 ? 1 : kg < 0 ? -1 : 0)]) + sizeof(Cell)))[(a.z.i)]*_const_fm.z/_const_alpha.z)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 140 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 160 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 118 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*((_const_a.z*_const_fm.z/_const_alpha.z)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); } return 0.; } static double _boundary4_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 117 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 118 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 118 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 138 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 118 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 140 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 118 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 156 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 118 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 158 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 118 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 138 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 158 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 118 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 140 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 160 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 118 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); } return 0.; }
# 119 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
static double _boundary5 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 118 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 119 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.z.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 119 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (_const_a.z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 139 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 119 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.z.i)]*_const_fm.z/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 141 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 119 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (_const_a.z*_const_fm.z/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(alpha.z.i)])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 157 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 119 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.z.i)]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)]/_const_alpha.z)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 159 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 119 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (_const_a.z*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fm.z.i)]/_const_alpha.z)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 139 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 159 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 119 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(a.z.i)]*_const_fm.z/_const_alpha.z)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 141 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 161 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 119 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (Delta*(- (_const_a.z*_const_fm.z/_const_alpha.z)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); } return 0.; } static double _boundary5_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 118 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"

if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 119 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 119 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 139 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 119 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 141 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 119 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 157 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 119 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 159 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 119 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 139 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 159 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 119 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y, z; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536], _constant[a.z.i - 65536]};
(void)(_const_a);
# 141 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536], _constant[fm.z.i - 65536]};
(void)(_const_fm);
# 161 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
const struct { double x, y, z; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536], _constant[alpha.z.i - 65536]};
(void)(_const_alpha);
# 119 "/Users/weugene/basilisk/work/src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); } return 0.; }
# 229 "tube_bp_rel.c"
static double _boundary6 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 228 "tube_bp_rel.c"
return (Delta*(0) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; } static double _boundary6_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 228 "tube_bp_rel.c"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; }
# 232 "tube_bp_rel.c"
static double _boundary7 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 231 "tube_bp_rel.c"
return (2.*(0) - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; } static double _boundary7_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 231 "tube_bp_rel.c"
return (- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; }
# 233 "tube_bp_rel.c"
static double _boundary8 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 232 "tube_bp_rel.c"
return (2.*(0) - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; } static double _boundary8_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 232 "tube_bp_rel.c"
return (- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; }
# 234 "tube_bp_rel.c"
static double _boundary9 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 233 "tube_bp_rel.c"
return (Delta*(0) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; } static double _boundary9_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 233 "tube_bp_rel.c"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; }
# 235 "tube_bp_rel.c"
static double _boundary10 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 234 "tube_bp_rel.c"
return (Delta*(0) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; } static double _boundary10_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 234 "tube_bp_rel.c"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; }
# 239 "tube_bp_rel.c"
static double _boundary11 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 238 "tube_bp_rel.c"
return (2.*((2.*(1. - 4*((y)*(y)) - 4*((z)*(z))))*(1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(fs.i)]) - Ubmean) - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; } static double _boundary11_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 238 "tube_bp_rel.c"
return (- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; }
# 240 "tube_bp_rel.c"
static double _boundary12 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 239 "tube_bp_rel.c"
return (2.*(0) - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; } static double _boundary12_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 239 "tube_bp_rel.c"
return (- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; }
# 241 "tube_bp_rel.c"
static double _boundary13 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 240 "tube_bp_rel.c"
return (2.*(0) - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; } static double _boundary13_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 240 "tube_bp_rel.c"
return (- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; }
# 242 "tube_bp_rel.c"
static double _boundary14 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 241 "tube_bp_rel.c"
return (Delta*(0) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; } static double _boundary14_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 241 "tube_bp_rel.c"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; }
# 243 "tube_bp_rel.c"
static double _boundary15 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 242 "tube_bp_rel.c"
return (Delta*(0) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; } static double _boundary15_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 242 "tube_bp_rel.c"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; }
# 246 "tube_bp_rel.c"
static double _boundary16 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 245 "tube_bp_rel.c"
return (2.*(1) - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; } static double _boundary16_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 245 "tube_bp_rel.c"
return (- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; }
# 247 "tube_bp_rel.c"
static double _boundary17 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 246 "tube_bp_rel.c"
return (Delta*(0) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; } static double _boundary17_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); int kg = neighbor.k - point.k; if (kg == 0) kg = _attribute[_s.i].d.z; (void)(kg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double Delta_z = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = (kg/2. + (point.k - 2) + 0.5)*Delta + Z0; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); (void)(Delta_z); ; int level = point.level; (void)(level); struct { int x, y, z; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1, 2*((point.k+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2; parent.k = (point.k + 2)/2;;
# 246 "tube_bp_rel.c"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0] [point.k+0]) + sizeof(Cell)))[(_s.i)]); return 0.; }
size_t datasize = 21*sizeof (double);
static int defaults (const int i, const double t, Event * _ev);
static int defaults_expr0 (int * ip, double * tp, Event * _ev);
static int cleanup (const int i, const double t, Event * _ev);
static int cleanup_expr0 (int * ip, double * tp, Event * _ev);
static int defaults_0 (const int i, const double t, Event * _ev);
static int defaults_0_expr0 (int * ip, double * tp, Event * _ev);
static int init (const int i, const double t, Event * _ev);
static int init_expr0 (int * ip, double * tp, Event * _ev);
static int set_dtmax (const int i, const double t, Event * _ev);
static int set_dtmax_expr0 (int * ip, double * tp, Event * _ev);
static int stability (const int i, const double t, Event * _ev);
static int stability_expr0 (int * ip, double * tp, Event * _ev);
static int vof (const int i, const double t, Event * _ev);
static int vof_expr0 (int * ip, double * tp, Event * _ev);
static int tracer_advection (const int i, const double t, Event * _ev);
static int tracer_advection_expr0 (int * ip, double * tp, Event * _ev);
static int properties (const int i, const double t, Event * _ev);
static int properties_expr0 (int * ip, double * tp, Event * _ev);
static int tracer_diffusion (const int i, const double t, Event * _ev);
static int tracer_diffusion_expr0 (int * ip, double * tp, Event * _ev);
static int advection_term (const int i, const double t, Event * _ev);
static int advection_term_expr0 (int * ip, double * tp, Event * _ev);
static int viscous_term (const int i, const double t, Event * _ev);
static int viscous_term_expr0 (int * ip, double * tp, Event * _ev);
static int acceleration (const int i, const double t, Event * _ev);
static int acceleration_expr0 (int * ip, double * tp, Event * _ev);
static int projection (const int i, const double t, Event * _ev);
static int projection_expr0 (int * ip, double * tp, Event * _ev);
static int end_timestep (const int i, const double t, Event * _ev);
static int end_timestep_expr0 (int * ip, double * tp, Event * _ev);
static int vtk_file (const int i, const double t, Event * _ev);
static int vtk_file_expr0 (int * ip, double * tp, Event * _ev);
static int adapt (const int i, const double t, Event * _ev);
static int adapt_expr0 (int * ip, double * tp, Event * _ev);
static int defaults_1 (const int i, const double t, Event * _ev);
static int defaults_1_expr0 (int * ip, double * tp, Event * _ev);
static int stability_0 (const int i, const double t, Event * _ev);
static int stability_0_expr0 (int * ip, double * tp, Event * _ev);
static int vof_0 (const int i, const double t, Event * _ev);
static int vof_0_expr0 (int * ip, double * tp, Event * _ev);
static int defaults_2 (const int i, const double t, Event * _ev);
static int defaults_2_expr0 (int * ip, double * tp, Event * _ev);
static int tracer_advection_0 (const int i, const double t, Event * _ev);
static int tracer_advection_0_expr0 (int * ip, double * tp, Event * _ev);
static int properties_0 (const int i, const double t, Event * _ev);
static int properties_0_expr0 (int * ip, double * tp, Event * _ev);
static int defaults_3 (const int i, const double t, Event * _ev);
static int defaults_3_expr0 (int * ip, double * tp, Event * _ev);
static int acceleration_0 (const int i, const double t, Event * _ev);
static int acceleration_0_expr0 (int * ip, double * tp, Event * _ev);
static int stability_1 (const int i, const double t, Event * _ev);
static int stability_1_expr0 (int * ip, double * tp, Event * _ev);
static int acceleration_1 (const int i, const double t, Event * _ev);
static int acceleration_1_expr0 (int * ip, double * tp, Event * _ev);
static int runtime (const int i, const double t, Event * _ev);
static int runtime_expr0 (int * ip, double * tp, Event * _ev);
static int init_0 (const int i, const double t, Event * _ev);
static int init_0_expr0 (int * ip, double * tp, Event * _ev);
static int advection_term_0 (const int i, const double t, Event * _ev);
static int advection_term_0_expr0 (int * ip, double * tp, Event * _ev);
static int viscous_term_0 (const int i, const double t, Event * _ev);
static int viscous_term_0_expr0 (int * ip, double * tp, Event * _ev);
static int projection_0 (const int i, const double t, Event * _ev);
static int projection_0_expr0 (int * ip, double * tp, Event * _ev);
static int end_timestep_0 (const int i, const double t, Event * _ev);
static int end_timestep_0_expr0 (int * ip, double * tp, Event * _ev);
static int logfile (const int i, const double t, Event * _ev);
static int logfile_expr0 (int * ip, double * tp, Event * _ev);
static int snapshot (const int i, const double t, Event * _ev);
static int snapshot_expr0 (int * ip, double * tp, Event * _ev);
static int snapshot_vtk (const int i, const double t, Event * _ev);
static int snapshot_vtk_expr0 (int * ip, double * tp, Event * _ev);
static int vtk_file_0 (const int i, const double t, Event * _ev);
static int vtk_file_0_expr0 (int * ip, double * tp, Event * _ev);
static int adapt_0 (const int i, const double t, Event * _ev);
static int adapt_0_expr0 (int * ip, double * tp, Event * _ev);
static int stop (const int i, const double t, Event * _ev);
static int stop_expr0 (int * ip, double * tp, Event * _ev);
static void _set_boundary0 (void);
static void _set_boundary1 (void);
static void _set_boundary2 (void);
static void _set_boundary3 (void);
static void _set_boundary4 (void);
static void _set_boundary5 (void);
static void _set_boundary6 (void);
static void _set_boundary7 (void);
static void _set_boundary8 (void);
static void _set_boundary9 (void);
static void _set_boundary10 (void);
static void _set_boundary11 (void);
static void _set_boundary12 (void);
static void _set_boundary13 (void);
static void _set_boundary14 (void);
static void _set_boundary15 (void);
static void _set_boundary16 (void);
static void _set_boundary17 (void);
void _init_solver (void) {
  void init_solver();
  init_solver();
  Events = (Event *) malloc(sizeof (Event));
  Events[0].last = 1;
  event_register ((Event){ 0, 1, defaults, {defaults_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/src/run.h", 42, "defaults"});
  event_register ((Event){ 0, 1, defaults_0, {defaults_0_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/work/src_local/centered-weugene.h", 139, "defaults"});
  event_register ((Event){ 0, 1, defaults_1, {defaults_1_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/src/vof.h", 107, "defaults"});
  event_register ((Event){ 0, 1, defaults_2, {defaults_2_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/src/two-phase.h", 25, "defaults"});
  event_register ((Event){ 0, 1, defaults_3, {defaults_3_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/src/iforce.h", 30, "defaults"});
  event_register ((Event){ 0, 1, init, {init_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/work/src_local/centered-weugene.h", 194, "init"});
  event_register ((Event){ 0, 1, init_0, {init_0_expr0}, ((int *)0), ((double *)0),
    "tube_bp_rel.c", 305, "init"});
  event_register ((Event){ 0, 1, runtime, {runtime_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/src/maxruntime.h", 20, "runtime"});
  event_register ((Event){ 0, 1, logfile, {logfile_expr0}, ((int *)0), ((double *)0),
    "tube_bp_rel.c", 419, "logfile"});
  event_register ((Event){ 0, 1, snapshot, {snapshot_expr0}, ((int *)0), ((double *)0),
    "tube_bp_rel.c", 540, "snapshot"});
  event_register ((Event){ 0, 1, snapshot_vtk, {snapshot_vtk_expr0}, ((int *)0), ((double *)0),
    "tube_bp_rel.c", 554, "snapshot_vtk"});
  event_register ((Event){ 0, 1, stop, {stop_expr0}, ((int *)0), ((double *)0),
    "tube_bp_rel.c", 604, "stop"});
  event_register ((Event){ 0, 1, cleanup, {cleanup_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/src/run.h", 50, "cleanup"});
  event_register ((Event){ 0, 1, set_dtmax, {set_dtmax_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/work/src_local/centered-weugene.h", 222, "set_dtmax"});
  event_register ((Event){ 0, 1, stability, {stability_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/work/src_local/centered-weugene.h", 224, "stability"});
  event_register ((Event){ 0, 1, stability_0, {stability_0_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/src/vof.h", 125, "stability"});
  event_register ((Event){ 0, 1, stability_1, {stability_1_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/src/tension.h", 38, "stability"});
  event_register ((Event){ 0, 1, vof, {vof_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/work/src_local/centered-weugene.h", 236, "vof"});
  event_register ((Event){ 0, 1, vof_0, {vof_0_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/src/vof.h", 371, "vof"});
  event_register ((Event){ 0, 1, tracer_advection, {tracer_advection_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/work/src_local/centered-weugene.h", 237, "tracer_advection"});
  event_register ((Event){ 0, 1, tracer_advection_0, {tracer_advection_0_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/src/two-phase.h", 64, "tracer_advection"});
  event_register ((Event){ 0, 1, properties, {properties_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/work/src_local/centered-weugene.h", 244, "properties"});
  event_register ((Event){ 0, 1, properties_0, {properties_0_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/src/two-phase.h", 95, "properties"});
  event_register ((Event){ 0, 1, tracer_diffusion, {tracer_diffusion_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/work/src_local/centered-weugene.h", 248, "tracer_diffusion"});
  event_register ((Event){ 0, 1, advection_term, {advection_term_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/work/src_local/centered-weugene.h", 328, "advection_term"});
  event_register ((Event){ 0, 1, advection_term_0, {advection_term_0_expr0}, ((int *)0), ((double *)0),
    "tube_bp_rel.c", 373, "advection_term"});
  event_register ((Event){ 0, 1, viscous_term, {viscous_term_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/work/src_local/centered-weugene.h", 364, "viscous_term"});
  event_register ((Event){ 0, 1, viscous_term_0, {viscous_term_0_expr0}, ((int *)0), ((double *)0),
    "tube_bp_rel.c", 377, "viscous_term"});
  event_register ((Event){ 0, 1, acceleration, {acceleration_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/work/src_local/centered-weugene.h", 404, "acceleration"});
  event_register ((Event){ 0, 1, acceleration_0, {acceleration_0_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/src/iforce.h", 48, "acceleration"});
  event_register ((Event){ 0, 1, acceleration_1, {acceleration_1_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/src/tension.h", 78, "acceleration"});
  event_register ((Event){ 0, 1, projection, {projection_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/work/src_local/centered-weugene.h", 450, "projection"});
  event_register ((Event){ 0, 1, projection_0, {projection_0_expr0}, ((int *)0), ((double *)0),
    "tube_bp_rel.c", 381, "projection"});
  event_register ((Event){ 0, 1, end_timestep, {end_timestep_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/work/src_local/centered-weugene.h", 477, "end_timestep"});
  event_register ((Event){ 0, 1, end_timestep_0, {end_timestep_0_expr0}, ((int *)0), ((double *)0),
    "tube_bp_rel.c", 394, "end_timestep"});
  event_register ((Event){ 0, 1, vtk_file, {vtk_file_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/work/src_local/centered-weugene.h", 482, "vtk_file"});
  event_register ((Event){ 0, 1, vtk_file_0, {vtk_file_0_expr0}, ((int *)0), ((double *)0),
    "tube_bp_rel.c", 562, "vtk_file"});
  event_register ((Event){ 0, 1, adapt, {adapt_expr0}, ((int *)0), ((double *)0),
    "/Users/weugene/basilisk/work/src_local/centered-weugene.h", 491, "adapt"});
  event_register ((Event){ 0, 1, adapt_0, {adapt_0_expr0}, ((int *)0), ((double *)0),
    "tube_bp_rel.c", 584, "adapt"});
  _attribute = (_Attributes *) calloc(datasize/sizeof(double),sizeof (_Attributes));
  all = (scalar *) malloc(sizeof (scalar)*22);
  for (int i = 0; i < 21; i++)
    all[i].i = i;
  all[21].i = -1;
  set_fpe();
  octree_methods();
  init_scalar ((scalar){20}, "sf");
  init_scalar ((scalar){19}, "rhov");
  init_face_vector ((vector){{16},{17},{18}}, "alphav");
  init_scalar ((scalar){15}, "f");
  init_face_vector ((vector){{12},{13},{14}}, "uf");
  init_scalar ((scalar){11}, "pf");
  init_vector ((vector){{8},{9},{10}}, "g");
  init_vector ((vector){{5},{6},{7}}, "u");
  init_scalar ((scalar){4}, "p");
  init_scalar ((scalar){3}, "divutmpAfter");
  init_scalar ((scalar){2}, "divutmp");
  init_scalar ((scalar){1}, "residual_of_p");
  init_const_vector ((vector){{65536 +9},{65536 +10},{65536 +11}}, "zerocf", (double []) {0.,0.,0.});
  init_scalar ((scalar){0}, "fs");
  init_const_scalar ((scalar){65536 +7}, "zeroc", 0.);
  init_const_scalar ((scalar){65536 +6}, "unity", 1.);
  init_const_vector ((vector){{65536 +3},{65536 +4},{65536 +5}}, "unityf", (double []) {1.,1.,1.});
  init_const_vector ((vector){{65536 +0},{65536 +1},{65536 +2}}, "zerof", (double []) {0.,0.,0.});
  _set_boundary0();
  _set_boundary1();
  _set_boundary2();
  _set_boundary3();
  _set_boundary4();
  _set_boundary5();
  _set_boundary6();
  _set_boundary7();
  _set_boundary8();
  _set_boundary9();
  _set_boundary10();
  _set_boundary11();
  _set_boundary12();
  _set_boundary13();
  _set_boundary14();
  _set_boundary15();
  _set_boundary16();
  _set_boundary17();
}
